# Migration Guide: v0.7.0

This guide covers the breaking changes introduced in Warren v0.7.0 and provides step-by-step instructions for migrating your policy files.

## Overview

Warren v0.7.0 introduces **breaking changes** to policy format for improved clarity, consistency, and flexibility:

### Policy Naming Changes

| Old Name | New Name | Purpose |
|----------|----------|---------|
| **Alert Policy** | **Ingest Policy** | Transform raw events into alerts |
| Enrich Policy | Enrich Policy | *(updated)* Define enrichment prompts |
| **Commit Policy** | **Triage Policy** | Make final routing and publish decisions |

**Why these naming changes?**

- **Ingest**: Clearly represents the function of taking in external events
- **Triage**: Reflects the security industry standard term for priority judgment and routing
- Avoids naming conflicts and redundancy (e.g., `publish` rule inside `commit` policy)

### Policy Format Changes

| Component | Old Format | New Format |
|-----------|------------|------------|
| **Ingest rule name** | `alert contains` | `alerts contains` |
| **Enrich rule names** | `query contains`, `agent contains` | `prompts contains` (unified) |
| **Enrich task fields** | `prompt`, `inline` | `template`, `params`, `inline` |
| **Triage input** | `input.enrich.{task_id}` | `input.enrich[].id/result` (array) |

**Why these format changes?**

- **`alerts` (plural)**: More semantic - can generate multiple alerts from one event
- **`prompts` (unified)**: Simplifies policy - all tasks are AI prompts with tool access
- **`template` + `params`**: Enables parameterized templates using `text/template`
- **Array format**: Provides access to both prompt text and result for debugging/auditing

## Breaking Changes

### 1. Ingest Policy Rule Name: `alert` â†’ `alerts`

#### Before (v0.6.x):
```rego
package ingest.guardduty

alert contains {
    "title": "Security Finding",
    "description": "...",
} if {
    input.severity >= 5
}
```

#### After (v0.7.0):
```rego
package ingest.guardduty

alerts contains {
    "title": "Security Finding",
    "description": "...",
} if {
    input.severity >= 5
}
```

**Migration**: Simply rename `alert contains` to `alerts contains` in all ingest policy files.

### 2. Enrich Policy: Unified `prompts` Format

#### Before (v0.6.x):
```rego
package enrich

# Query tasks - simple LLM queries
query contains {
    "id": "analyze",
    "prompt": "threat_analysis.md",
    "format": "json"
} if {
    input.schema == "guardduty"
}

# Agent tasks - AI agents with tools
agent contains {
    "id": "investigate",
    "inline": "Investigate the IP",
    "format": "text"
} if {
    has_ip
}
```

#### After (v0.7.0):
```rego
package enrich

# All tasks use unified prompts format
prompts contains {
    "id": "analyze",
    "template": "threat_analysis.md",  # Renamed from prompt
    "params": {                         # New: template parameters
        "severity_threshold": "high",
        "include_context": true
    },
    "format": "json"
} if {
    input.schema == "guardduty"
}

prompts contains {
    "id": "investigate",
    "inline": "Investigate the IP",   # Inline unchanged
    "format": "text"
} if {
    has_ip
}
```

**Migration**:
1. Rename `query contains` â†’ `prompts contains`
2. Rename `agent contains` â†’ `prompts contains`
3. Rename `prompt` field â†’ `template` field
4. Optionally add `params` for template parameterization
5. **New**: Task `id` field is now optional - auto-generated if omitted

### 3. Triage Policy: Map â†’ Array Format

#### Before (v0.6.x):
```rego
package triage

title := sprintf("THREAT: %s", [input.alert.metadata.title]) if {
    input.enrich.analyze.is_malicious == true
}

channel := "security-urgent" if {
    input.enrich.analyze.severity == "critical"
}
```

#### After (v0.7.0):
```rego
package triage

# Helper function to get enrichment result
get_enrich(task_id) := result if {
    some e in input.enrich
    e.id == task_id
    result := e.result
}

title := sprintf("THREAT: %s", [input.alert.metadata.title]) if {
    get_enrich("analyze").is_malicious == true
}

channel := "security-urgent" if {
    get_enrich("analyze").severity == "critical"
}

# You can also access the prompt that was used
description := sprintf("%s\n\nPrompt used: %s", [
    input.alert.metadata.description,
    prompt_text
]) if {
    some e in input.enrich
    e.id == "analyze"
    prompt_text := e.prompt
}
```

**Migration**:
1. Add `get_enrich()` helper function
2. Replace `input.enrich.{task_id}.field` with `get_enrich("task_id").field`
3. Optionally access `input.enrich[].prompt` for debugging

### 4. Policy Package Names

#### Ingest Policy (formerly Alert Policy)

**Before (v0.6.x)**:
```rego
package alert.guardduty
```

**After (v0.7.0)**:
```rego
package ingest.guardduty
```

**OPA Query Path Changed**:
- Old: `data.alert.{schema}`
- New: `data.ingest.{schema}`

#### Triage Policy (formerly Commit Policy)

**Before (v0.6.x)**:
```rego
package commit
```

**After (v0.7.0)**:
```rego
package triage
```

**OPA Query Path Changed**:
- Old: `data.commit`
- New: `data.triage`

#### Enrich Policy (unchanged)

```rego
package enrich
```

No changes required for enrich policies.

### 2. File Organization

We recommend organizing your policy files to reflect the new naming:

**Before**:
```
policies/
â”œâ”€â”€ alert/
â”‚   â”œâ”€â”€ guardduty.rego
â”‚   â””â”€â”€ cloudtrail.rego
â”œâ”€â”€ enrich/
â”‚   â””â”€â”€ enrich.rego
â””â”€â”€ commit/
    â””â”€â”€ commit.rego
```

**After**:
```
policies/
â”œâ”€â”€ ingest/
â”‚   â”œâ”€â”€ guardduty.rego
â”‚   â””â”€â”€ cloudtrail.rego
â”œâ”€â”€ enrich/
â”‚   â””â”€â”€ enrich.rego
â””â”€â”€ triage/
    â””â”€â”€ triage.rego
```

**Note**: File and directory names are recommendations only. Warren uses the `package` declaration inside the `.rego` file to determine policy type.

### 3. Webhook Endpoints

**No changes required** - webhook endpoints remain the same:

- Package `ingest.guardduty` â†’ Endpoint `/hooks/alert/raw/guardduty`
- Package `ingest.custom` â†’ Endpoint `/hooks/alert/raw/custom`

The endpoint path still uses `/alert/` for backward compatibility and clarity.

## Migration Steps

### Step 1: Update Ingest Policies (Alert Policies)

For each alert policy file:

1. Change package name from `alert.*` to `ingest.*`
2. Review and update any comments referencing "alert policy"

**Example Migration**:

```diff
- package alert.guardduty
+ package ingest.guardduty

- # Alert policy for AWS GuardDuty findings
+ # Ingest policy for AWS GuardDuty findings

alert contains {
    "title": sprintf("%s in %s", [input.detail.type, input.detail.region]),
    "description": input.detail.description,
    "attrs": [
        {
            "key": "severity",
            "value": severity_label,
            "link": ""
        }
    ]
} if {
    input.source == "aws.guardduty"
    input.detail.severity >= 4.0
}
```

### Step 2: Update Triage Policies (Commit Policies)

For each commit policy file:

1. Change package name from `commit` to `triage`
2. Review and update any comments referencing "commit policy"

**Example Migration**:

```diff
- package commit
+ package triage

- # Commit policy for final alert routing
+ # Triage policy for final alert routing

# Override title for confirmed threats
title := sprintf("ğŸš¨ CONFIRMED THREAT: %s", [input.alert.metadata.title]) if {
    input.enrich.check_ioc.is_malicious == true
}

# Route based on severity
channel := "security-critical" if {
    input.enrich.analyze_finding.urgency == "critical"
}

# Discard false positives
publish := "discard" if {
    input.enrich.analyze_finding.is_threat == false
    input.enrich.analyze_finding.confidence > 0.9
}

# Default
channel := "security-alerts"
publish := "alert"
```

### Step 3: Update Enrich Policies (if any schema-specific references)

Enrich policies generally don't need changes unless you have schema-specific conditions:

**Before**:
```rego
query contains {
    "id": "analyze_threat",
    "prompt": "threat_analysis.md",
    "format": "json"
} if {
    input.schema == "guardduty"  # No change needed
}
```

**After**: Same (no changes needed)

### Step 4: Reorganize Files (Optional but Recommended)

Move policy files to match new naming:

```bash
# Create new directories
mkdir -p policies/ingest
mkdir -p policies/triage

# Move and rename alert policies
mv policies/alert/*.rego policies/ingest/

# Move commit policies
mv policies/commit/*.rego policies/triage/

# Remove old directories (after verifying files moved correctly)
rmdir policies/alert
rmdir policies/commit
```

### Step 5: Validate Policies

Test your policies with OPA to ensure syntax is correct:

```bash
# Validate all policies
opa check policies/

# Test specific policy
opa eval -d policies/ingest/guardduty.rego -i test_data.json "data.ingest.guardduty"
```

### Step 6: Deploy and Test

1. Deploy updated policies to your Warren instance
2. Set `WARREN_POLICY` environment variable to point to policy directory
3. Send test events to verify policies work correctly
4. Monitor Warren logs for any policy evaluation errors

## Complete Example Migration

### Before (v0.6.x)

**policies/alert/security_hub.rego**:
```rego
package alert.security_hub

# Alert policy for AWS Security Hub findings

alert contains {
    "title": input.Title,
    "description": input.Description,
    "attrs": [
        {
            "key": "severity",
            "value": input.Severity.Label,
            "link": ""
        },
        {
            "key": "compliance_status",
            "value": input.Compliance.Status,
            "link": ""
        }
    ]
} if {
    input.ProductName == "Security Hub"
    input.Severity.Label in ["CRITICAL", "HIGH", "MEDIUM"]
}

# Ignore informational findings
ignore if {
    input.Severity.Label == "INFORMATIONAL"
}
```

**policies/enrich/enrich.rego**:
```rego
package enrich

query contains {
    "id": "analyze_compliance",
    "inline": "Analyze this security finding and recommend remediation steps. Respond in JSON: {\"is_critical\": boolean, \"remediation\": string, \"timeline\": string}",
    "format": "json"
} if {
    input.schema == "security_hub"
    some attr in input.metadata.attributes
    attr.key == "compliance_status"
    attr.value == "FAILED"
}
```

**policies/commit/commit.rego**:
```rego
package commit

# Route critical compliance failures
channel := "security-compliance-critical" if {
    input.enrich.analyze_compliance.is_critical == true
}

# Add remediation as attribute
attr contains {
    "key": "remediation",
    "value": input.enrich.analyze_compliance.remediation,
    "link": ""
} if {
    input.enrich.analyze_compliance.remediation
}

# Default
channel := "security-compliance"
publish := "alert"
```

### After (v0.7.0)

**policies/ingest/security_hub.rego**:
```rego
package ingest.security_hub

# Ingest policy for AWS Security Hub findings

alert contains {
    "title": input.Title,
    "description": input.Description,
    "attrs": [
        {
            "key": "severity",
            "value": input.Severity.Label,
            "link": ""
        },
        {
            "key": "compliance_status",
            "value": input.Compliance.Status,
            "link": ""
        }
    ]
} if {
    input.ProductName == "Security Hub"
    input.Severity.Label in ["CRITICAL", "HIGH", "MEDIUM"]
}

# Ignore informational findings
ignore if {
    input.Severity.Label == "INFORMATIONAL"
}
```

**policies/enrich/enrich.rego**:
```rego
package enrich

# No changes - enrich policies unchanged

query contains {
    "id": "analyze_compliance",
    "inline": "Analyze this security finding and recommend remediation steps. Respond in JSON: {\"is_critical\": boolean, \"remediation\": string, \"timeline\": string}",
    "format": "json"
} if {
    input.schema == "security_hub"
    some attr in input.metadata.attributes
    attr.key == "compliance_status"
    attr.value == "FAILED"
}
```

**policies/triage/triage.rego**:
```rego
package triage

# Triage policy for final routing and disposition

# Route critical compliance failures
channel := "security-compliance-critical" if {
    input.enrich.analyze_compliance.is_critical == true
}

# Add remediation as attribute
attr contains {
    "key": "remediation",
    "value": input.enrich.analyze_compliance.remediation,
    "link": ""
} if {
    input.enrich.analyze_compliance.remediation
}

# Default
channel := "security-compliance"
publish := "alert"
```

## Migration Checklist

Use this checklist to ensure complete migration:

### Ingest Policy Changes
- [ ] Identify all ingest policy files
- [ ] Rename `alert contains` â†’ `alerts contains`
- [ ] Update package declarations: `alert.*` â†’ `ingest.*` (if not done yet)
- [ ] Update comments in ingest policy files

### Enrich Policy Changes
- [ ] Identify all enrich policy files
- [ ] Rename `query contains` â†’ `prompts contains`
- [ ] Rename `agent contains` â†’ `prompts contains`
- [ ] Rename `prompt` field â†’ `template` field
- [ ] Optionally add `params` for template parameterization
- [ ] Update comments in enrich policy files

### Triage Policy Changes
- [ ] Identify all triage policy files
- [ ] Add `get_enrich()` helper function
- [ ] Update all `input.enrich.{task_id}` â†’ `get_enrich("task_id")`
- [ ] Update package declarations: `commit` â†’ `triage` (if not done yet)
- [ ] Update comments in triage policy files

### Testing and Deployment
- [ ] Reorganize files into `ingest/` and `triage/` directories (optional)
- [ ] Validate all policies with `opa check`
- [ ] Test policies with sample data
- [ ] Deploy policies to Warren instance
- [ ] Send test events and verify behavior
- [ ] Monitor logs for policy evaluation errors
- [ ] Update any documentation or runbooks referencing old names

## Troubleshooting

### Policy Not Loading

**Symptoms**: Warren logs show policy evaluation errors or uses default behavior

**Solutions**:
1. Verify package name is exactly `ingest.{schema}` or `triage` (case-sensitive)
2. Check for typos in package declaration
3. Run `opa check policies/` to validate syntax
4. Ensure `WARREN_POLICY` environment variable points to correct directory

### Alerts Not Being Created

**Symptoms**: Events sent to webhook but no alerts appear

**Solutions**:
1. Check that ingest policy package name matches webhook schema
   - Endpoint: `/hooks/alert/raw/guardduty`
   - Package must be: `ingest.guardduty`
2. Verify `alert contains` rule conditions are met
3. Check if `ignore` rule is inadvertently matching
4. Review Warren logs for policy evaluation details

### Triage Policy Not Applying

**Symptoms**: Alerts created but channel/publish settings not applied

**Solutions**:
1. Verify package is exactly `triage` (not `triage.something`)
2. Check that field names are correct: `title`, `description`, `channel`, `attr`, `publish`
3. Ensure enrichment task IDs match: `input.enrich.{task_id}`
4. Add `print()` statements for debugging: `print("Channel:", channel)`

### OPA Query Not Found

**Symptoms**: Logs show "undefined" or query not found errors

**Solutions**:
1. Old query paths (`data.alert.*`, `data.commit`) are no longer valid
2. Ensure you've updated all package declarations
3. Restart Warren after updating policies
4. Clear any policy caches if applicable

## API and Code Changes

### GraphQL API

No changes to GraphQL schema or queries. The API continues to work as before.

### Custom Integrations

If you have custom code that directly queries OPA policies, update query paths:

**Before**:
```go
result, err := opaClient.Query("data.alert.guardduty", input)
result, err := opaClient.Query("data.commit", input)
```

**After**:
```go
result, err := opaClient.Query("data.ingest.guardduty", input)
result, err := opaClient.Query("data.triage", input)
```

## Rollback Plan

If you need to rollback to v0.6.x:

1. Revert policy package names:
   - `ingest.*` â†’ `alert.*`
   - `triage` â†’ `commit`
2. Move files back to original directories
3. Downgrade Warren to v0.6.x
4. Restart Warren service

## Authorization Policy Changes

Warren v0.7.0 introduces **breaking changes** to authorization policies for improved security and clarity.

### HTTP API Authorization: `auth` â†’ `auth.http`

The HTTP API authorization policy package has been renamed to provide clearer separation between different authorization contexts.

#### Before (v0.6.x):
```rego
package auth

allow {
    input.req.method == "GET"
    input.req.path == "/api/alerts"
}
```

#### After (v0.7.0):
```rego
package auth.http

allow {
    input.req.method == "GET"
    input.req.path == "/api/alerts"
}
```

**Migration**: Rename the package declaration from `auth` to `auth.http` in your HTTP API authorization policy files.

#### HTTP Authorization Input Context

The `input` object for HTTP authorization contains:

```rego
# input structure for auth.http policy
{
    "google": { ... },              # Google ID token claims (if authenticated via Google)
    "iap": { ... },                 # Google IAP JWT claims (if authenticated via IAP)
    "sns": { ... },                 # AWS SNS message (if request from SNS)
    "req": {                        # HTTP request information
        "method": "POST",           # HTTP method
        "path": "/hooks/alert/raw/guardduty",  # Request path
        "body": "...",              # Request body as string
        "header": {                 # Request headers
            "Content-Type": ["application/json"],
            ...
        }
    },
    "env": {                        # Environment variables (marked as secret)
        "WARREN_ENV": "production",
        ...
    }
}
```

**Example Policy**:
```rego
package auth.http

# Allow GET requests to public endpoints
allow {
    input.req.method == "GET"
    startswith(input.req.path, "/api/public/")
}

# Allow authenticated Google users to access alerts
allow {
    input.google.email_verified == true
    startswith(input.req.path, "/api/alerts")
}

# Allow requests from specific IAP project
allow {
    input.iap.aud == "/projects/123456789/apps/myproject"
}

# Allow SNS notifications from specific topic
allow {
    input.sns.TopicArn == "arn:aws:sns:us-east-1:123456789:security-alerts"
    input.req.path == "/hooks/alert/raw/guardduty"
}
```

### New: Agent Authorization Policy

Warren v0.7.0 introduces dedicated authorization policies for AI agent execution with a **deny-by-default** security model.

#### Agent Authorization Context

Create a new policy file `auth/agent.rego`:

```rego
package auth.agent

# Allow all authenticated Slack users
allow {
    input.auth.slack.id != ""
}

# Example: Restrict based on Slack user ID
allow {
    input.auth.slack.id == "U1234567890"
}
```

#### Agent Authorization Input Context

The `input` object for agent authorization contains:

```rego
# input structure for auth.agent policy
{
    "message": "User's message to the agent",  # The user's chat message
    "env": {                                   # Environment variables (marked as secret)
        "WARREN_ENV": "production",
        ...
    },
    "auth": {                                  # Authentication information (optional)
        "slack": {                             # Slack authentication (if from Slack)
            "id": "U1234567890"                # Slack user ID
        }
    }
}
```

**Important Notes**:
- The `auth` field is **optional** and may be `null` if the request is not from an authenticated source
- Currently, only Slack authentication is supported (`auth.slack`)
- The agent name and description are **not** included in the input context
- Use `input.auth.slack.id` to authorize based on Slack user ID

### Development Mode: Bypassing Authorization

For development and testing purposes, you can bypass agent authorization using the `--no-authorization` flag:

```bash
warren serve --no-authorization
```

**Warning**: This flag should **never** be used in production environments as it completely disables agent authorization checks.

### Migration Steps for Authorization

#### Step 1: Update HTTP API Authorization Policy

If you have an existing HTTP API authorization policy:

```bash
# Edit your authorization policy file
vi policies/auth/http.rego
```

Change:
```diff
- package auth
+ package auth.http

allow {
    input.method == "GET"
    input.path == "/api/alerts"
}
```

#### Step 2: Create Agent Authorization Policy

Create a new agent authorization policy file:

```bash
# Create agent authorization policy
cat > policies/auth/agent.rego << 'EOF'
package auth.agent

# Allow all authenticated Slack users
allow {
    input.auth.slack.id != ""
}

# Example: Allow only specific Slack users
allow {
    input.auth.slack.id in ["U1234567890", "U0987654321"]
}
EOF
```

#### Step 3: Test Agent Authorization

Test your agent authorization policy:

```bash
# Validate policy syntax
opa check policies/auth/

# Test with sample data
cat > test_agent_auth.json << 'EOF'
{
  "message": "Investigate this alert for suspicious activity",
  "env": {
    "WARREN_ENV": "production"
  },
  "auth": {
    "slack": {
      "id": "U1234567890"
    }
  }
}
EOF

# Test authorization
opa eval -d policies/auth/agent.rego -i test_agent_auth.json "data.auth.agent.allow"
```

### Authorization File Organization

**Before**:
```
policies/
â””â”€â”€ auth/
    â””â”€â”€ auth.rego
```

**After**:
```
policies/
â””â”€â”€ auth/
    â”œâ”€â”€ http.rego    # HTTP API authorization
    â””â”€â”€ agent.rego   # Agent execution authorization
```

### Authorization Checklist

- [ ] Update HTTP API authorization policy package: `auth` â†’ `auth.http`
- [ ] Create new agent authorization policy file
- [ ] Define agent authorization rules based on your security requirements
- [ ] Test authorization policies with `opa check` and `opa eval`
- [ ] Deploy policies to Warren instance
- [ ] Verify agent execution is properly authorized/denied
- [ ] Remove `--no-authorization` flag from production deployments

### Troubleshooting Authorization

#### Agent Execution Denied

**Symptoms**: Agents fail to execute with authorization errors

**Solutions**:
1. Check that `auth.agent` package exists and contains `allow` rules
2. Verify input context matches your policy conditions
3. Add debug logging to see actual input values:
   ```rego
   allow {
       print("Message:", input.message)
       print("Slack User ID:", input.auth.slack.id)
       input.auth.slack.id != ""
   }
   ```
4. Check if `input.auth` is `null` for non-Slack requests
5. Use `--no-authorization` flag temporarily for debugging (development only)

#### HTTP API Authorization Not Working

**Symptoms**: HTTP API requests fail authorization

**Solutions**:
1. Verify package is exactly `auth.http` (not `auth`)
2. Check that authorization policy file is loaded
3. Review Warren logs for policy evaluation details
4. Test policy with `opa eval` using actual request data

## Need Help?

- **Documentation**: See [doc/policy.md](../policy.md) for complete policy guide
- **Examples**: Check [examples/](../../examples/) directory for sample policies
- **Issues**: Report problems at https://github.com/secmon-lab/warren/issues

## Summary

The v0.7.0 policy naming changes improve clarity and align with security industry terminology:

- **Ingest Policy** clearly represents event ingestion and transformation
- **Triage Policy** reflects the security practice of prioritization and routing
- **Authorization Policies** now clearly separated between HTTP API (`auth.http`) and Agent execution (`auth.agent`)
- Migration is straightforward: update package declarations and reorganize files

The change requires manual updates to policy files but provides long-term benefits in code readability, maintainability, and security.
