package bigquery

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/m-mizutani/goerr/v2"
	"github.com/m-mizutani/gollem"
	"github.com/secmon-lab/warren/pkg/domain/model/memory"
	"github.com/secmon-lab/warren/pkg/domain/types"
)

// saveExecutionMemory saves task execution metadata as agent memory
// Note: Does NOT store the actual execution result (resp.String()), only metadata
func (a *Agent) saveExecutionMemory(
	ctx context.Context,
	query string,
	resp *gollem.ExecuteResponse,
	execErr error,
	duration time.Duration,
) error {
	// Build AgentMemory (QueryEmbedding will be generated by Memory Service)
	mem := &memory.AgentMemory{
		ID:        types.NewAgentMemoryID(),
		AgentID:   a.ID(),
		TaskQuery: query,
		Timestamp: time.Now(),
		Duration:  duration,
	}

	// K: Success patterns (no error case)
	if execErr == nil && resp != nil {
		mem.SuccessDescription = a.buildSuccessDescription(resp)
		mem.SuccessResult = a.extractSuccessMetadata(resp)
	}

	// P: Problem collection (error case)
	if execErr != nil {
		mem.Problems = a.extractProblems(execErr)
	}

	// T: Improvements (generated from Problems)
	mem.Improvements = a.generateImprovements(mem.Problems)

	// Save memory (with embedding generation)
	if err := a.memoryService.SaveAgentMemory(ctx, mem); err != nil {
		return goerr.Wrap(err, "failed to save memory")
	}

	return nil
}

// buildSuccessDescription generates natural language description of success
// Focuses on tool usage patterns, NOT the result content
func (a *Agent) buildSuccessDescription(resp *gollem.ExecuteResponse) string {
	if resp == nil || resp.IsEmpty() {
		return "Task completed successfully without tool calls"
	}

	// Extract response text summary
	responseText := resp.String()
	if len(responseText) > 200 {
		responseText = responseText[:200] + "..."
	}

	return fmt.Sprintf("Successfully executed task. Response: %s", responseText)
}

// extractSuccessMetadata extracts metadata from successful execution
// IMPORTANT: Does NOT include actual result data (resp.String())
// Only extracts tool usage patterns and metadata
func (a *Agent) extractSuccessMetadata(resp *gollem.ExecuteResponse) map[string]any {
	metadata := map[string]any{
		"had_response": resp != nil && !resp.IsEmpty(),
	}

	if resp != nil && !resp.IsEmpty() {
		// Extract response length as metadata (not the actual content)
		responseStr := resp.String()
		metadata["response_length"] = len(responseStr)

		// Check if response looks like query results
		if len(responseStr) > 0 {
			metadata["has_content"] = true
		}
	}

	return metadata
}

// extractProblems extracts problem descriptions from error
func (a *Agent) extractProblems(execErr error) []string {
	if execErr == nil {
		return nil
	}

	problems := []string{}

	// Extract main error message
	errMsg := execErr.Error()
	problems = append(problems, fmt.Sprintf("Execution failed: %s", errMsg))

	// Try to extract more specific error details from goerr if available
	if ge, ok := execErr.(*goerr.Error); ok {
		if ge.Unwrap() != nil {
			problems = append(problems, fmt.Sprintf("Root cause: %s", ge.Unwrap().Error()))
		}
	}

	return problems
}

// generateImprovements generates improvement suggestions from problems using LLM
func (a *Agent) generateImprovements(problems []string) []string {
	if len(problems) == 0 {
		return nil
	}

	// Use LLM to analyze problems and generate improvements
	ctx := context.Background()

	// Build prompt for LLM
	prompt := "Based on the following problems encountered during BigQuery task execution, suggest specific improvements:\n\n"
	for i, problem := range problems {
		prompt += fmt.Sprintf("%d. %s\n", i+1, problem)
	}
	prompt += "\nProvide 1-3 concise, actionable improvement suggestions. Each suggestion should be on a new line starting with '- '."

	// Generate improvements using LLM
	session, err := a.llmClient.NewSession(ctx)
	if err != nil {
		return nil
	}

	resp, err := session.GenerateContent(ctx, gollem.Text(prompt))
	if err != nil || resp == nil || len(resp.Texts) == 0 {
		return nil
	}

	// Parse LLM response into improvements list
	improvements := []string{}
	lines := strings.Split(resp.Texts[0], "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "- ") {
			improvements = append(improvements, strings.TrimPrefix(line, "- "))
		} else if strings.HasPrefix(line, "* ") {
			improvements = append(improvements, strings.TrimPrefix(line, "* "))
		} else if len(line) > 0 && !strings.HasPrefix(line, "#") {
			// Include non-empty lines that aren't headers
			improvements = append(improvements, line)
		}
	}

	return improvements
}
