package bigquery

import (
	"context"
	"time"

	"github.com/m-mizutani/goerr/v2"
	"github.com/m-mizutani/gollem"
	"github.com/secmon-lab/warren/pkg/domain/model/memory"
	"github.com/secmon-lab/warren/pkg/domain/types"
	"github.com/secmon-lab/warren/pkg/utils/logging"
)

// saveExecutionMemory saves task execution metadata as agent memory
// Note: Does NOT store the actual execution result (resp.String()), only metadata
func (a *Agent) saveExecutionMemory(
	ctx context.Context,
	query string,
	resp *gollem.ExecuteResponse,
	execErr error,
	duration time.Duration,
	session gollem.Session,
) error {
	logger := logging.From(ctx)

	// Generate KPT analysis using LLM (all components in one call)
	successes, problems, improvements, err := a.generateKPTAnalysis(ctx, query, resp, execErr, duration, session)
	if err != nil {
		// Check if error is tagged as fallback (non-critical)
		if goerr.HasTag(err, tagKPTAnalysisFallback) {
			logger.Warn("KPT analysis failed, saving memory with empty arrays", "error", err)
			// Continue with empty arrays
			successes = []string{}
			problems = []string{}
			improvements = []string{}
		} else {
			// Critical error - propagate
			return goerr.Wrap(err, "failed to generate KPT analysis")
		}
	}

	// Build AgentMemory (QueryEmbedding will be generated by Memory Service)
	mem := &memory.AgentMemory{
		ID:           types.NewAgentMemoryID(),
		AgentID:      a.ID(),
		TaskQuery:    query,
		Timestamp:    time.Now(),
		Duration:     duration,
		Successes:    successes,
		Problems:     problems,
		Improvements: improvements,
	}

	// Save memory (with embedding generation)
	if err := a.memoryService.SaveAgentMemory(ctx, mem); err != nil {
		return goerr.Wrap(err, "failed to save agent memory")
	}

	logger.Debug("Execution memory saved successfully", "memory_id", mem.ID)
	return nil
}
