package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	"context"
	"encoding/json"
	"time"

	goerr "github.com/m-mizutani/goerr/v2"
	"github.com/secmon-lab/warren/pkg/domain/model/alert"
	"github.com/secmon-lab/warren/pkg/domain/model/auth"
	graphql1 "github.com/secmon-lab/warren/pkg/domain/model/graphql"
	"github.com/secmon-lab/warren/pkg/domain/model/knowledge"
	"github.com/secmon-lab/warren/pkg/domain/model/slack"
	"github.com/secmon-lab/warren/pkg/domain/model/ticket"
	"github.com/secmon-lab/warren/pkg/domain/types"
	"github.com/secmon-lab/warren/pkg/service/clustering"
	"github.com/secmon-lab/warren/pkg/usecase"
)

// User is the resolver for the user field.
func (r *activityResolver) User(ctx context.Context, obj *graphql1.Activity) (*graphql1.User, error) {
	if obj.UserID == nil || *obj.UserID == "" {
		return nil, nil
	}

	// Use DataLoader to efficiently fetch user
	return GetUser(ctx, *obj.UserID)
}

// Alert is the resolver for the alert field.
func (r *activityResolver) Alert(ctx context.Context, obj *graphql1.Activity) (*alert.Alert, error) {
	if obj.AlertID == nil || *obj.AlertID == "" {
		return nil, nil
	}

	alertID := types.AlertID(*obj.AlertID)

	// Use DataLoader to efficiently fetch alert
	return GetAlert(ctx, alertID)
}

// Ticket is the resolver for the ticket field.
func (r *activityResolver) Ticket(ctx context.Context, obj *graphql1.Activity) (*ticket.Ticket, error) {
	if obj.TicketID == nil || *obj.TicketID == "" {
		return nil, nil
	}

	ticketID := types.TicketID(*obj.TicketID)

	// Use DataLoader to efficiently fetch ticket
	return GetTicket(ctx, ticketID)
}

// ID is the resolver for the id field.
func (r *alertResolver) ID(ctx context.Context, obj *alert.Alert) (string, error) {
	return string(obj.ID), nil
}

// Schema is the resolver for the schema field.
func (r *alertResolver) Schema(ctx context.Context, obj *alert.Alert) (string, error) {
	return string(obj.Schema), nil
}

// Data is the resolver for the data field.
func (r *alertResolver) Data(ctx context.Context, obj *alert.Alert) (string, error) {
	// Convert obj.Data to JSON string
	jsonBytes, err := json.Marshal(obj.Data)
	if err != nil {
		return "", goerr.Wrap(err, "failed to marshal alert data to JSON")
	}
	return string(jsonBytes), nil
}

// Attributes is the resolver for the attributes field.
func (r *alertResolver) Attributes(ctx context.Context, obj *alert.Alert) ([]*graphql1.AlertAttribute, error) {
	attributes := make([]*graphql1.AlertAttribute, len(obj.Attributes))
	for i, attr := range obj.Attributes {
		var link *string
		if attr.Link != "" {
			link = &attr.Link
		}
		attributes[i] = &graphql1.AlertAttribute{
			Key:   attr.Key,
			Value: attr.Value,
			Link:  link,
			Auto:  attr.Auto,
		}
	}
	return attributes, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *alertResolver) CreatedAt(ctx context.Context, obj *alert.Alert) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// Ticket is the resolver for the ticket field.
func (r *alertResolver) Ticket(ctx context.Context, obj *alert.Alert) (*ticket.Ticket, error) {
	if obj.TicketID == types.EmptyTicketID {
		return nil, nil
	}
	return r.repo.GetTicket(ctx, obj.TicketID)
}

// TagObjects is the resolver for the tagObjects field.
func (r *alertResolver) TagObjects(ctx context.Context, obj *alert.Alert) ([]*graphql1.TagObject, error) {
	if r.uc == nil || len(obj.TagIDs) == 0 {
		return []*graphql1.TagObject{}, nil
	}

	// Get tag IDs as slice
	tagIDSlice := make([]string, 0, len(obj.TagIDs))
	for tagID := range obj.TagIDs {
		tagIDSlice = append(tagIDSlice, tagID)
	}

	// Get tag metadata using tag getter
	tags, err := r.createTagGetter()(ctx, tagIDSlice)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL TagObject
	tagObjects := make([]*graphql1.TagObject, 0, len(tags))
	for _, tag := range tags {
		tagObjects = append(tagObjects, &graphql1.TagObject{
			ID:   tag.ID,
			Name: tag.Name,
		})
	}

	return tagObjects, nil
}

// ID is the resolver for the id field.
func (r *commentResolver) ID(ctx context.Context, obj *ticket.Comment) (string, error) {
	return string(obj.ID), nil
}

// Content is the resolver for the content field.
func (r *commentResolver) Content(ctx context.Context, obj *ticket.Comment) (string, error) {
	if r.mrkdwnConv != nil {
		converted := r.mrkdwnConv.ConvertToMarkdown(ctx, obj.Comment)
		return converted, nil
	}
	return obj.Comment, nil
}

// User is the resolver for the user field.
func (r *commentResolver) User(ctx context.Context, obj *ticket.Comment) (*graphql1.User, error) {
	if obj.User == nil {
		return nil, nil
	}
	return &graphql1.User{
		ID:   obj.User.ID,
		Name: obj.User.Name,
	}, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *commentResolver) CreatedAt(ctx context.Context, obj *ticket.Comment) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *commentResolver) UpdatedAt(ctx context.Context, obj *ticket.Comment) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// Severity is the resolver for the severity field.
func (r *findingResolver) Severity(ctx context.Context, obj *ticket.Finding) (string, error) {
	return string(obj.Severity), nil
}

// Author is the resolver for the author field.
func (r *knowledgeResolver) Author(ctx context.Context, obj *graphql1.Knowledge) (*graphql1.User, error) {
	if obj.AuthorID == "" {
		return nil, nil
	}

	// Use DataLoader to efficiently fetch user from Slack
	return GetUser(ctx, obj.AuthorID)
}

// UpdateTicketStatus is the resolver for the updateTicketStatus field.
func (r *mutationResolver) UpdateTicketStatus(ctx context.Context, id string, status string) (*ticket.Ticket, error) {
	// Validate status
	ticketStatus := types.TicketStatus(status)
	if err := ticketStatus.Validate(); err != nil {
		return nil, goerr.Wrap(err, "invalid ticket status", goerr.V("status", status))
	}

	// Call the use case to update ticket status with Slack notification
	updatedTicket, err := r.uc.UpdateTicketStatus(ctx, types.TicketID(id), ticketStatus)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to update ticket status")
	}

	return updatedTicket, nil
}

// UpdateMultipleTicketsStatus is the resolver for the updateMultipleTicketsStatus field.
func (r *mutationResolver) UpdateMultipleTicketsStatus(ctx context.Context, ids []string, status string) ([]*ticket.Ticket, error) {
	// Status validation
	ticketStatus := types.TicketStatus(status)
	if err := ticketStatus.Validate(); err != nil {
		return nil, goerr.Wrap(err, "invalid ticket status", goerr.V("status", status))
	}

	// Convert and validate ticket IDs
	ticketIDs := make([]types.TicketID, len(ids))
	for i, id := range ids {
		ticketID := types.TicketID(id)
		if err := ticketID.Validate(); err != nil {
			return nil, goerr.Wrap(err, "invalid ticket ID", goerr.V("id", id))
		}
		ticketIDs[i] = ticketID
	}

	// Call the use case to update multiple tickets status with Slack notification
	tickets, err := r.uc.UpdateMultipleTicketsStatus(ctx, ticketIDs, ticketStatus)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to update multiple tickets status")
	}

	return tickets, nil
}

// UpdateTicketConclusion is the resolver for the updateTicketConclusion field.
func (r *mutationResolver) UpdateTicketConclusion(ctx context.Context, id string, conclusion string, reason string) (*ticket.Ticket, error) {
	// Validate conclusion value
	alertConclusion := types.AlertConclusion(conclusion)
	if err := alertConclusion.Validate(); err != nil {
		return nil, goerr.Wrap(err, "invalid conclusion", goerr.V("conclusion", conclusion))
	}

	// Call the use case to update ticket conclusion with Slack notification
	updatedTicket, err := r.uc.UpdateTicketConclusion(ctx, types.TicketID(id), alertConclusion, reason)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to update ticket conclusion")
	}

	return updatedTicket, nil
}

// UpdateTicket is the resolver for the updateTicket field.
func (r *mutationResolver) UpdateTicket(ctx context.Context, id string, title string, description *string) (*ticket.Ticket, error) {
	// Extract user information from authentication context
	token, err := auth.TokenFromContext(ctx)
	if err != nil {
		return nil, goerr.Wrap(err, "authentication required")
	}

	// Create user from authentication token
	user := &slack.User{
		ID:   token.Sub,
		Name: token.Name,
	}

	// Set default value for description if not provided
	desc := ""
	if description != nil {
		desc = *description
	}

	// Call the use case to update ticket
	updatedTicket, err := r.uc.UpdateTicket(ctx, types.TicketID(id), title, desc, user)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to update ticket")
	}

	return updatedTicket, nil
}

// CreateTicket is the resolver for the createTicket field.
func (r *mutationResolver) CreateTicket(ctx context.Context, title string, description string, isTest *bool) (*ticket.Ticket, error) {
	// Extract user information from authentication context
	token, err := auth.TokenFromContext(ctx)
	if err != nil {
		return nil, goerr.Wrap(err, "authentication required")
	}

	// Create user from authentication token
	user := &slack.User{
		ID:   token.Sub,
		Name: token.Name,
	}

	// Set default value for isTest if not provided
	testFlag := false
	if isTest != nil {
		testFlag = *isTest
	}

	// Call the use case to create manual ticket
	newTicket, err := r.uc.CreateManualTicketWithTest(ctx, title, description, user, testFlag)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to create ticket")
	}

	return newTicket, nil
}

// CreateTicketFromAlerts is the resolver for the createTicketFromAlerts field.
func (r *mutationResolver) CreateTicketFromAlerts(ctx context.Context, alertIds []string, title *string, description *string) (*ticket.Ticket, error) {
	// Extract user information from authentication context
	token, err := auth.TokenFromContext(ctx)
	if err != nil {
		return nil, goerr.Wrap(err, "authentication required")
	}

	// Create user from authentication token
	user := &slack.User{
		ID:   token.Sub,
		Name: token.Name,
	}

	// Convert string IDs to typed IDs
	alertIDsTyped := make([]types.AlertID, len(alertIds))
	for i, id := range alertIds {
		alertIDsTyped[i] = types.AlertID(id)
	}

	// Prepare title and description
	titleStr := ""
	if title != nil {
		titleStr = *title
	}
	descStr := ""
	if description != nil {
		descStr = *description
	}

	// For auto-generation when title is empty
	if titleStr == "" {
		createdTicket, err := r.uc.CreateTicketFromAlerts(ctx, alertIDsTyped, user, nil)
		if err != nil {
			return nil, goerr.Wrap(err, "failed to create ticket from alerts")
		}
		return createdTicket, nil
	}

	// When title is provided, create a manual ticket first, then bind alerts
	createdTicket, err := r.uc.CreateManualTicket(ctx, titleStr, descStr, user)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to create manual ticket")
	}

	// Bind alerts to the created ticket
	err = r.uc.BindAlertsToTicket(ctx, createdTicket.ID, alertIDsTyped)
	if err != nil {
		// If binding fails, we should ideally delete the ticket, but for now just return error
		return nil, goerr.Wrap(err, "failed to bind alerts to ticket")
	}

	// Get the updated ticket with alerts
	updatedTicket, err := r.repo.GetTicket(ctx, createdTicket.ID)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get updated ticket")
	}

	return updatedTicket, nil
}

// BindAlertsToTicket is the resolver for the bindAlertsToTicket field.
func (r *mutationResolver) BindAlertsToTicket(ctx context.Context, ticketID string, alertIds []string) (*ticket.Ticket, error) {
	// Convert string IDs to typed IDs
	alertIDsTyped := make([]types.AlertID, len(alertIds))
	for i, id := range alertIds {
		alertIDsTyped[i] = types.AlertID(id)
	}

	// Bind alerts to ticket using UseCase
	err := r.uc.BindAlertsToTicket(ctx, types.TicketID(ticketID), alertIDsTyped)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to bind alerts to ticket")
	}

	// Get updated ticket
	updatedTicket, err := r.repo.GetTicket(ctx, types.TicketID(ticketID))
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get updated ticket")
	}

	return updatedTicket, nil
}

// UpdateAlertTags is the resolver for the updateAlertTags field.
func (r *mutationResolver) UpdateAlertTags(ctx context.Context, alertID string, tagIds []string) (*alert.Alert, error) {
	if r.uc.TagUC == nil {
		return nil, goerr.New("tag service not configured")
	}

	a, err := r.uc.TagUC.UpdateAlertTagsByID(ctx, types.AlertID(alertID), tagIds)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to update alert tags")
	}

	return a, nil
}

// UpdateTicketTags is the resolver for the updateTicketTags field.
func (r *mutationResolver) UpdateTicketTags(ctx context.Context, ticketID string, tagIds []string) (*ticket.Ticket, error) {
	if r.uc.TagUC == nil {
		return nil, goerr.New("tag service not configured")
	}

	t, err := r.uc.TagUC.UpdateTicketTagsByID(ctx, types.TicketID(ticketID), tagIds)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to update ticket tags")
	}

	return t, nil
}

// CreateTag is the resolver for the createTag field.
func (r *mutationResolver) CreateTag(ctx context.Context, name string) (*graphql1.TagMetadata, error) {
	if r.uc.TagUC == nil {
		return nil, goerr.New("tag service not configured")
	}

	tag, err := r.uc.TagUC.CreateTag(ctx, name)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to create tag")
	}

	var desc *string
	if tag.Description != "" {
		desc = &tag.Description
	}

	return &graphql1.TagMetadata{
		ID:          tag.ID,
		Name:        string(tag.Name),
		Description: desc,
		Color:       tag.Color,
		CreatedAt:   tag.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
		UpdatedAt:   tag.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
	}, nil
}

// DeleteTag is the resolver for the deleteTag field.
func (r *mutationResolver) DeleteTag(ctx context.Context, id string) (bool, error) {
	if r.uc.TagUC == nil {
		return false, goerr.New("tag service not configured")
	}

	err := r.uc.TagUC.DeleteTagByID(ctx, id)
	if err != nil {
		return false, goerr.Wrap(err, "failed to delete tag")
	}

	return true, nil
}

// UpdateTag is the resolver for the updateTag field.
func (r *mutationResolver) UpdateTag(ctx context.Context, input graphql1.UpdateTagInput) (*graphql1.TagMetadata, error) {
	if r.uc.TagUC == nil {
		return nil, goerr.New("tag service not configured")
	}

	description := ""
	if input.Description != nil {
		description = *input.Description
	}

	tag, err := r.uc.TagUC.UpdateTag(ctx, input.ID, input.Name, input.Color, description)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to update tag")
	}

	var desc *string
	if tag.Description != "" {
		desc = &tag.Description
	}

	return &graphql1.TagMetadata{
		ID:          tag.ID,
		Name:        tag.Name,
		Description: desc,
		Color:       tag.Color,
		CreatedAt:   tag.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
		UpdatedAt:   tag.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
	}, nil
}

// CreateKnowledge is the resolver for the createKnowledge field.
func (r *mutationResolver) CreateKnowledge(ctx context.Context, input graphql1.CreateKnowledgeInput) (*graphql1.Knowledge, error) {
	// Extract user information from authentication context
	token, err := auth.TokenFromContext(ctx)
	if err != nil {
		return nil, goerr.Wrap(err, "authentication required")
	}

	// Convert and validate input
	topicTyped := types.KnowledgeTopic(input.Topic)
	if err := topicTyped.Validate(); err != nil {
		return nil, goerr.Wrap(err, "invalid topic", goerr.V("topic", input.Topic))
	}

	slugTyped := types.KnowledgeSlug(input.Slug)
	if err := slugTyped.Validate(); err != nil {
		return nil, goerr.Wrap(err, "invalid slug", goerr.V("slug", input.Slug))
	}

	// Check if knowledge already exists
	existing, err := r.repo.GetKnowledge(ctx, topicTyped, slugTyped)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to check existing knowledge")
	}
	if existing != nil {
		return nil, goerr.New("knowledge already exists", goerr.V("topic", input.Topic), goerr.V("slug", input.Slug))
	}

	// Create new knowledge
	now := time.Now()
	author := types.UserID(token.Sub)

	k := &knowledge.Knowledge{
		Slug:      slugTyped,
		Name:      input.Name,
		Topic:     topicTyped,
		Content:   input.Content,
		CommitID:  knowledge.GenerateCommitID(now, author, input.Content),
		Author:    author,
		CreatedAt: now,
		UpdatedAt: now,
		State:     types.KnowledgeStateActive,
	}

	// Validate knowledge
	if err := k.Validate(); err != nil {
		return nil, goerr.Wrap(err, "invalid knowledge")
	}

	// Save to repository
	if err := r.repo.PutKnowledge(ctx, k); err != nil {
		return nil, goerr.Wrap(err, "failed to create knowledge")
	}

	// Convert to GraphQL model
	return &graphql1.Knowledge{
		Slug:      k.Slug.String(),
		Name:      k.Name,
		Topic:     k.Topic.String(),
		Content:   k.Content,
		CommitID:  k.CommitID,
		AuthorID:  k.Author.String(),
		CreatedAt: k.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
		UpdatedAt: k.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
		State:     k.State.String(),
	}, nil
}

// UpdateKnowledge is the resolver for the updateKnowledge field.
func (r *mutationResolver) UpdateKnowledge(ctx context.Context, input graphql1.UpdateKnowledgeInput) (*graphql1.Knowledge, error) {
	// Extract user information from authentication context
	token, err := auth.TokenFromContext(ctx)
	if err != nil {
		return nil, goerr.Wrap(err, "authentication required")
	}

	// Convert and validate input
	topicTyped := types.KnowledgeTopic(input.Topic)
	if err := topicTyped.Validate(); err != nil {
		return nil, goerr.Wrap(err, "invalid topic", goerr.V("topic", input.Topic))
	}

	slugTyped := types.KnowledgeSlug(input.Slug)
	if err := slugTyped.Validate(); err != nil {
		return nil, goerr.Wrap(err, "invalid slug", goerr.V("slug", input.Slug))
	}

	// Get existing knowledge
	existing, err := r.repo.GetKnowledge(ctx, topicTyped, slugTyped)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get existing knowledge")
	}
	if existing == nil {
		return nil, goerr.New("knowledge not found", goerr.V("topic", input.Topic), goerr.V("slug", input.Slug))
	}

	// Create updated knowledge with new commit
	now := time.Now()
	author := types.UserID(token.Sub)

	k := &knowledge.Knowledge{
		Slug:      slugTyped,
		Name:      input.Name,
		Topic:     topicTyped,
		Content:   input.Content,
		CommitID:  knowledge.GenerateCommitID(now, author, input.Content),
		Author:    author,
		CreatedAt: existing.CreatedAt, // Preserve original creation time
		UpdatedAt: now,
		State:     types.KnowledgeStateActive,
	}

	// Validate knowledge
	if err := k.Validate(); err != nil {
		return nil, goerr.Wrap(err, "invalid knowledge")
	}

	// Save new version to repository
	if err := r.repo.PutKnowledge(ctx, k); err != nil {
		return nil, goerr.Wrap(err, "failed to update knowledge")
	}

	// Convert to GraphQL model
	return &graphql1.Knowledge{
		Slug:      k.Slug.String(),
		Name:      k.Name,
		Topic:     k.Topic.String(),
		Content:   k.Content,
		CommitID:  k.CommitID,
		AuthorID:  k.Author.String(),
		CreatedAt: k.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
		UpdatedAt: k.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
		State:     k.State.String(),
	}, nil
}

// ArchiveKnowledge is the resolver for the archiveKnowledge field.
func (r *mutationResolver) ArchiveKnowledge(ctx context.Context, topic string, slug string) (bool, error) {
	// Extract user information from authentication context
	_, err := auth.TokenFromContext(ctx)
	if err != nil {
		return false, goerr.Wrap(err, "authentication required")
	}

	// Convert and validate input
	topicTyped := types.KnowledgeTopic(topic)
	if err := topicTyped.Validate(); err != nil {
		return false, goerr.Wrap(err, "invalid topic", goerr.V("topic", topic))
	}

	slugTyped := types.KnowledgeSlug(slug)
	if err := slugTyped.Validate(); err != nil {
		return false, goerr.Wrap(err, "invalid slug", goerr.V("slug", slug))
	}

	// Archive the knowledge
	if err := r.repo.ArchiveKnowledge(ctx, topicTyped, slugTyped); err != nil {
		return false, goerr.Wrap(err, "failed to archive knowledge")
	}

	return true, nil
}

// Ticket is the resolver for the ticket field.
func (r *queryResolver) Ticket(ctx context.Context, id string) (*ticket.Ticket, error) {
	t, err := r.repo.GetTicket(ctx, types.TicketID(id))
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get ticket")
	}
	return t, nil
}

// Tickets is the resolver for the tickets field.
func (r *queryResolver) Tickets(ctx context.Context, statuses []string, offset *int, limit *int) (*graphql1.TicketsResponse, error) {
	var ticketStatuses []types.TicketStatus
	for _, s := range statuses {
		status := types.TicketStatus(s)
		if err := status.Validate(); err != nil {
			return nil, goerr.Wrap(err, "invalid ticket status", goerr.V("status", s))
		}
		ticketStatuses = append(ticketStatuses, status)
	}

	var offsetVal, limitVal int
	if offset != nil {
		offsetVal = *offset
	}
	if limit != nil {
		limitVal = *limit
	}

	tickets, err := r.repo.GetTicketsByStatus(ctx, ticketStatuses, offsetVal, limitVal)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to list tickets")
	}

	totalCount, err := r.repo.CountTicketsByStatus(ctx, ticketStatuses)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to count tickets")
	}

	return &graphql1.TicketsResponse{
		Tickets:    tickets,
		TotalCount: totalCount,
	}, nil
}

// SimilarTickets is the resolver for the similarTickets field.
func (r *queryResolver) SimilarTickets(ctx context.Context, ticketID string, threshold float64, offset *int, limit *int) (*graphql1.TicketsResponse, error) {
	// Get target ticket
	targetTicket, err := r.repo.GetTicket(ctx, types.TicketID(ticketID))
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get target ticket")
	}

	// If target ticket has no embedding, return empty results
	if len(targetTicket.Embedding) == 0 {
		return &graphql1.TicketsResponse{
			Tickets:    []*ticket.Ticket{},
			TotalCount: 0,
		}, nil
	}

	// Set default values for offset and limit
	var offsetVal, limitVal int
	if offset != nil {
		offsetVal = *offset
	}
	if limit != nil {
		limitVal = *limit
	} else {
		limitVal = defaultSimilarTicketsLimit
	}

	// Fetch a fixed, large number of nearest neighbors to ensure stable pagination
	candidates, err := r.repo.FindNearestTickets(ctx, targetTicket.Embedding, maxSimilarTicketsCandidates)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to find nearest tickets")
	}

	// Filter by threshold and exclude target ticket to get complete result set
	var filteredTickets []*ticket.Ticket
	for _, candidate := range candidates {
		// Exclude the target ticket itself
		if candidate.ID == targetTicket.ID {
			continue
		}

		// Only include tickets with embeddings
		if len(candidate.Embedding) == 0 {
			continue
		}

		// Calculate cosine similarity and apply threshold
		similarity := cosineSimilarity(targetTicket.Embedding, candidate.Embedding)
		if float64(similarity) >= threshold {
			filteredTickets = append(filteredTickets, candidate)
		}
	}

	// Calculate correct total count from complete filtered result set
	totalCount := len(filteredTickets)

	// Apply pagination to the complete filtered result set
	start := offsetVal
	if start > len(filteredTickets) {
		start = len(filteredTickets)
	}

	end := start + limitVal
	if end > len(filteredTickets) {
		end = len(filteredTickets)
	}

	result := filteredTickets[start:end]

	return &graphql1.TicketsResponse{
		Tickets:    result,
		TotalCount: totalCount,
	}, nil
}

// SimilarTicketsForAlert is the resolver for the similarTicketsForAlert field.
func (r *queryResolver) SimilarTicketsForAlert(ctx context.Context, alertID string, threshold float64, offset *int, limit *int) (*graphql1.TicketsResponse, error) {
	// Set default values for offset and limit
	var offsetVal, limitVal int
	if offset != nil {
		offsetVal = *offset
	}
	if limit != nil {
		limitVal = *limit
	} else {
		limitVal = defaultSimilarTicketsLimit
	}

	// Delegate to usecase
	tickets, totalCount, err := r.uc.GetSimilarTicketsForAlert(ctx, types.AlertID(alertID), threshold, offsetVal, limitVal)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get similar tickets for alert")
	}

	return &graphql1.TicketsResponse{
		Tickets:    tickets,
		TotalCount: totalCount,
	}, nil
}

// TicketComments is the resolver for the ticketComments field.
func (r *queryResolver) TicketComments(ctx context.Context, ticketID string, offset *int, limit *int) (*graphql1.CommentsResponse, error) {
	// Set default values for offset and limit
	var offsetVal, limitVal int
	if offset != nil {
		offsetVal = *offset
	}
	if limit != nil {
		limitVal = *limit
		// Restrict limit to allowed values: 20, 50, 100
		if limitVal != 20 && limitVal != 50 && limitVal != 100 {
			limitVal = defaultCommentsLimit
		}
	} else {
		limitVal = defaultCommentsLimit
	}

	// Get paginated comments sorted by timestamp descending (newest first)
	comments, err := r.repo.GetTicketCommentsPaginated(ctx, types.TicketID(ticketID), offsetVal, limitVal)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get ticket comments")
	}

	// Get total count for pagination
	totalCount, err := r.repo.CountTicketComments(ctx, types.TicketID(ticketID))
	if err != nil {
		return nil, goerr.Wrap(err, "failed to count ticket comments")
	}

	// Convert []ticket.Comment to []*ticket.Comment
	commentPtrs := make([]*ticket.Comment, len(comments))
	for i := range comments {
		commentPtrs[i] = &comments[i]
	}

	return &graphql1.CommentsResponse{
		Comments:   commentPtrs,
		TotalCount: totalCount,
	}, nil
}

// Alert is the resolver for the alert field.
func (r *queryResolver) Alert(ctx context.Context, id string) (*alert.Alert, error) {
	a, err := r.repo.GetAlert(ctx, types.AlertID(id))
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get alert")
	}
	return a, nil
}

// Alerts is the resolver for the alerts field.
func (r *queryResolver) Alerts(ctx context.Context, offset *int, limit *int) (*graphql1.AlertsResponse, error) {
	var offsetVal, limitVal int
	if offset != nil {
		offsetVal = *offset
	}
	if limit != nil {
		limitVal = *limit
	}

	alerts, err := r.repo.GetAlertWithoutTicket(ctx, offsetVal, limitVal)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to list alerts")
	}

	totalCount, err := r.repo.CountAlertsWithoutTicket(ctx)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to count alerts")
	}

	return &graphql1.AlertsResponse{
		Alerts:     alerts,
		TotalCount: totalCount,
	}, nil
}

// UnboundAlerts is the resolver for the unboundAlerts field.
func (r *queryResolver) UnboundAlerts(ctx context.Context, threshold *float64, keyword *string, ticketID *string, offset *int, limit *int) (*graphql1.AlertsResponse, error) {
	var offsetVal, limitVal int
	if offset != nil {
		offsetVal = *offset
	}
	if limit != nil {
		limitVal = *limit
	}

	var ticketIDTyped *types.TicketID
	if ticketID != nil && *ticketID != "" {
		tid := types.TicketID(*ticketID)
		ticketIDTyped = &tid
	}

	alerts, totalCount, err := r.uc.GetUnboundAlertsFiltered(ctx, threshold, keyword, ticketIDTyped, offsetVal, limitVal)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get unbound alerts")
	}

	return &graphql1.AlertsResponse{
		Alerts:     alerts,
		TotalCount: totalCount,
	}, nil
}

// Dashboard is the resolver for the dashboard field.
func (r *queryResolver) Dashboard(ctx context.Context) (*graphql1.DashboardStats, error) {
	// Get open tickets count and list
	openTickets, err := r.repo.GetTicketsByStatus(ctx, []types.TicketStatus{types.TicketStatusOpen}, 0, 5)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get open tickets")
	}

	openTicketsCount, err := r.repo.CountTicketsByStatus(ctx, []types.TicketStatus{types.TicketStatusOpen})
	if err != nil {
		return nil, goerr.Wrap(err, "failed to count open tickets")
	}

	// Get unbound alerts count (for accurate count, we need to get all first)
	allUnboundAlerts, err := r.repo.GetAlertWithoutTicket(ctx, 0, 0) // Get all for count
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get unbound alerts count")
	}
	unboundAlertsCount := len(allUnboundAlerts)

	// Get only the first 5 unbound alerts
	unboundAlerts, err := r.repo.GetAlertWithoutTicket(ctx, 0, 5)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get unbound alerts")
	}

	return &graphql1.DashboardStats{
		OpenTicketsCount:   openTicketsCount,
		UnboundAlertsCount: unboundAlertsCount,
		OpenTickets:        openTickets,
		UnboundAlerts:      unboundAlerts,
	}, nil
}

// Activities is the resolver for the activities field.
func (r *queryResolver) Activities(ctx context.Context, offset *int, limit *int) (*graphql1.ActivitiesResponse, error) {
	const defaultActivitiesLimit = 10
	const maxActivitiesLimit = 50

	// Set default values for offset and limit
	var offsetVal, limitVal int
	if offset != nil {
		offsetVal = *offset
	}
	if limit != nil {
		limitVal = *limit
		if limitVal > maxActivitiesLimit {
			limitVal = maxActivitiesLimit
		}
	} else {
		limitVal = defaultActivitiesLimit
	}

	// Get paginated activities
	activities, err := r.repo.GetActivities(ctx, offsetVal, limitVal)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get activities")
	}

	// Get total count for pagination
	totalCount, err := r.repo.CountActivities(ctx)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to count activities")
	}

	// Convert to GraphQL activities
	graphqlActivities := make([]*graphql1.Activity, len(activities))
	for i, a := range activities {
		graphqlActivity := &graphql1.Activity{
			ID:        string(a.ID),
			Type:      string(a.Type),
			CreatedAt: a.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
		}

		if a.UserID != "" {
			graphqlActivity.UserID = &a.UserID
		}
		if a.AlertID != types.AlertID("") {
			alertID := string(a.AlertID)
			graphqlActivity.AlertID = &alertID
		}
		if a.TicketID != types.TicketID("") {
			ticketID := string(a.TicketID)
			graphqlActivity.TicketID = &ticketID
		}
		if a.CommentID != types.CommentID("") {
			commentID := string(a.CommentID)
			graphqlActivity.CommentID = &commentID
		}
		if a.Metadata != nil {
			metadataBytes, err := json.Marshal(a.Metadata)
			if err == nil {
				metadataStr := string(metadataBytes)
				graphqlActivity.Metadata = &metadataStr
			}
		}

		graphqlActivities[i] = graphqlActivity
	}

	return &graphql1.ActivitiesResponse{
		Activities: graphqlActivities,
		TotalCount: totalCount,
	}, nil
}

// AlertClusters is the resolver for the alertClusters field.
func (r *queryResolver) AlertClusters(ctx context.Context, limit *int, offset *int, minClusterSize *int, eps *float64, minSamples *int, keyword *string) (*graphql1.ClusteringSummary, error) {
	// Authentication check
	token, err := auth.TokenFromContext(ctx)
	if err != nil {
		return nil, goerr.Wrap(err, "authentication required")
	}
	_ = token // For now, just check authentication

	// Set default values
	l := 50
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}
	mcs := 1
	if minClusterSize != nil {
		mcs = *minClusterSize
	}

	// Set DBSCAN parameters with defaults
	epsVal := 0.15 // Default adjusted for cosine distance
	if eps != nil {
		epsVal = *eps
	}
	minSamplesVal := 2
	if minSamples != nil {
		minSamplesVal = *minSamples
	}

	// Get keyword if provided
	kw := ""
	if keyword != nil {
		kw = *keyword
	}

	// Call clustering use case
	params := usecase.GetClustersParams{
		MinClusterSize: mcs,
		Limit:          l,
		Offset:         o,
		Keyword:        kw,
		DBSCANParams: clustering.DBSCANParams{
			Eps:        epsVal,
			MinSamples: minSamplesVal,
		},
	}

	summary, err := r.uc.ClusteringUC.GetAlertClusters(ctx, params)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get alert clusters")
	}

	// Convert to GraphQL model
	result, err := r.convertToGraphQLClusteringSummary(ctx, summary)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to convert clustering summary")
	}
	return result, nil
}

// ClusterAlerts is the resolver for the clusterAlerts field.
func (r *queryResolver) ClusterAlerts(ctx context.Context, clusterID string, keyword *string, limit *int, offset *int) (*graphql1.AlertsConnection, error) {
	// Authentication check
	token, err := auth.TokenFromContext(ctx)
	if err != nil {
		return nil, goerr.Wrap(err, "authentication required")
	}
	_ = token

	// Set default values
	l := 50
	if limit != nil {
		l = *limit
	}
	o := 0
	if offset != nil {
		o = *offset
	}
	kw := ""
	if keyword != nil {
		kw = *keyword
	}

	// Call clustering use case
	alerts, totalCount, err := r.uc.ClusteringUC.GetClusterAlerts(ctx, clusterID, kw, l, o)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get cluster alerts")
	}

	return &graphql1.AlertsConnection{
		Alerts:     alerts,
		TotalCount: totalCount,
	}, nil
}

// Tags is the resolver for the tags field.
func (r *queryResolver) Tags(ctx context.Context) ([]*graphql1.TagMetadata, error) {
	if r.uc.TagUC == nil {
		return nil, goerr.New("tag service not configured")
	}

	tags, err := r.uc.TagUC.ListTags(ctx)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to list tags")
	}

	result := make([]*graphql1.TagMetadata, len(tags))
	for i, tag := range tags {
		var desc *string
		if tag.Description != "" {
			desc = &tag.Description
		}

		result[i] = &graphql1.TagMetadata{
			ID:          tag.ID,
			Name:        string(tag.Name),
			Description: desc,
			Color:       tag.Color,
			CreatedAt:   tag.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
			UpdatedAt:   tag.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
		}
	}

	return result, nil
}

// AvailableTagColors is the resolver for the availableTagColors field.
func (r *queryResolver) AvailableTagColors(ctx context.Context) ([]string, error) {
	if r.uc.TagUC == nil {
		return nil, goerr.New("tag service not configured")
	}

	colors, err := r.uc.TagUC.GetAvailableColors()
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get available colors")
	}

	return colors, nil
}

// AvailableTagColorNames is the resolver for the availableTagColorNames field.
func (r *queryResolver) AvailableTagColorNames(ctx context.Context) ([]string, error) {
	if r.uc.TagUC == nil {
		return nil, goerr.New("tag service not configured")
	}

	names, err := r.uc.TagUC.GetAvailableColorNames()
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get available color names")
	}

	return names, nil
}

// KnowledgeTopics is the resolver for the knowledgeTopics field.
func (r *queryResolver) KnowledgeTopics(ctx context.Context) ([]*graphql1.TopicSummary, error) {
	topicSummaries, err := r.repo.ListKnowledgeTopics(ctx)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to list knowledge topics")
	}

	// Convert to GraphQL model
	result := make([]*graphql1.TopicSummary, len(topicSummaries))
	for i, ts := range topicSummaries {
		result[i] = &graphql1.TopicSummary{
			Topic: ts.Topic.String(),
			Count: ts.Count,
		}
	}

	return result, nil
}

// KnowledgesByTopic is the resolver for the knowledgesByTopic field.
func (r *queryResolver) KnowledgesByTopic(ctx context.Context, topic string) ([]*graphql1.Knowledge, error) {
	knowledges, err := r.repo.GetKnowledges(ctx, types.KnowledgeTopic(topic))
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get knowledges by topic", goerr.V("topic", topic))
	}

	// Convert to GraphQL model
	result := make([]*graphql1.Knowledge, len(knowledges))
	for i, k := range knowledges {
		result[i] = &graphql1.Knowledge{
			Slug:      k.Slug.String(),
			Name:      k.Name,
			Topic:     k.Topic.String(),
			Content:   k.Content,
			CommitID:  k.CommitID,
			AuthorID:  k.Author.String(),
			CreatedAt: k.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
			UpdatedAt: k.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
			State:     k.State.String(),
		}
	}

	return result, nil
}

// TicketSessions is the resolver for the ticketSessions field.
func (r *queryResolver) TicketSessions(ctx context.Context, ticketID string) ([]*graphql1.Session, error) {
	sessions, err := r.repo.GetSessionsByTicket(ctx, types.TicketID(ticketID))
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get sessions by ticket", goerr.V("ticketID", ticketID))
	}

	// Convert to GraphQL model
	result := make([]*graphql1.Session, len(sessions))
	for i, s := range sessions {
		var userID, query, slackURL, intent *string
		if s.UserID != "" {
			uid := string(s.UserID)
			userID = &uid
		}
		if s.Query != "" {
			query = &s.Query
		}
		if s.SlackURL != "" {
			slackURL = &s.SlackURL
		}
		if s.Intent != "" {
			intent = &s.Intent
		}

		result[i] = &graphql1.Session{
			ID:        string(s.ID),
			TicketID:  string(s.TicketID),
			Status:    s.Status.String(),
			UserID:    userID,
			Query:     query,
			SlackURL:  slackURL,
			Intent:    intent,
			CreatedAt: s.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
			UpdatedAt: s.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
		}
	}

	return result, nil
}

// Session is the resolver for the session field.
func (r *queryResolver) Session(ctx context.Context, id string) (*graphql1.Session, error) {
	s, err := r.repo.GetSession(ctx, types.SessionID(id))
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get session", goerr.V("sessionID", id))
	}

	if s == nil {
		return nil, nil
	}

	var userID, query, slackURL, intent *string
	if s.UserID != "" {
		uid := string(s.UserID)
		userID = &uid
	}
	if s.Query != "" {
		query = &s.Query
	}
	if s.SlackURL != "" {
		slackURL = &s.SlackURL
	}
	if s.Intent != "" {
		intent = &s.Intent
	}

	return &graphql1.Session{
		ID:        string(s.ID),
		TicketID:  string(s.TicketID),
		Status:    s.Status.String(),
		UserID:    userID,
		Query:     query,
		SlackURL:  slackURL,
		Intent:    intent,
		CreatedAt: s.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
		UpdatedAt: s.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
	}, nil
}

// SessionMessages is the resolver for the sessionMessages field.
func (r *queryResolver) SessionMessages(ctx context.Context, sessionID string) ([]*graphql1.SessionMessage, error) {
	messages, err := r.repo.GetSessionMessages(ctx, types.SessionID(sessionID))
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get session messages", goerr.V("sessionID", sessionID))
	}

	// Convert to GraphQL model
	result := make([]*graphql1.SessionMessage, len(messages))
	for i, m := range messages {
		result[i] = &graphql1.SessionMessage{
			ID:        string(m.ID),
			SessionID: string(m.SessionID),
			Type:      string(m.Type),
			Content:   m.Content,
			CreatedAt: m.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
			UpdatedAt: m.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
		}
	}

	return result, nil
}

// User is the resolver for the user field.
func (r *sessionResolver) User(ctx context.Context, obj *graphql1.Session) (*graphql1.User, error) {
	if obj.UserID == nil || *obj.UserID == "" {
		return nil, nil
	}

	// Use DataLoader to efficiently fetch user
	return GetUser(ctx, *obj.UserID)
}

// ID is the resolver for the id field.
func (r *ticketResolver) ID(ctx context.Context, obj *ticket.Ticket) (string, error) {
	return string(obj.ID), nil
}

// Status is the resolver for the status field.
func (r *ticketResolver) Status(ctx context.Context, obj *ticket.Ticket) (string, error) {
	return string(obj.Status), nil
}

// Assignee is the resolver for the assignee field.
func (r *ticketResolver) Assignee(ctx context.Context, obj *ticket.Ticket) (*graphql1.User, error) {
	if obj.Assignee == nil {
		return nil, nil
	}
	return &graphql1.User{
		ID:   obj.Assignee.ID,
		Name: obj.Assignee.Name,
	}, nil
}

// Alerts is the resolver for the alerts field.
func (r *ticketResolver) Alerts(ctx context.Context, obj *ticket.Ticket) ([]*alert.Alert, error) {
	alerts, err := r.repo.BatchGetAlerts(ctx, obj.AlertIDs)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get ticket alerts")
	}
	return alerts, nil
}

// AlertsPaginated is the resolver for the alertsPaginated field.
func (r *ticketResolver) AlertsPaginated(ctx context.Context, obj *ticket.Ticket, offset *int, limit *int) (*graphql1.AlertsResponse, error) {
	// Set default values
	defaultOffset := 0
	defaultLimit := 5

	if offset == nil {
		offset = &defaultOffset
	}
	if limit == nil {
		limit = &defaultLimit
	}

	// Get total count
	totalCount := len(obj.AlertIDs)

	// Calculate pagination bounds
	start := *offset
	end := start + *limit

	var paginatedAlertIDs []types.AlertID
	if start < totalCount {
		if end > totalCount {
			end = totalCount
		}
		paginatedAlertIDs = obj.AlertIDs[start:end]
	}

	// Get alerts for this page
	alerts, err := r.repo.BatchGetAlerts(ctx, paginatedAlertIDs)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get paginated ticket alerts")
	}

	return &graphql1.AlertsResponse{
		Alerts:     alerts,
		TotalCount: totalCount,
	}, nil
}

// Comments is the resolver for the comments field.
func (r *ticketResolver) Comments(ctx context.Context, obj *ticket.Ticket) ([]*ticket.Comment, error) {
	comments, err := r.repo.GetTicketComments(ctx, obj.ID)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get ticket comments")
	}

	// Convert []ticket.Comment to []*ticket.Comment
	commentPtrs := make([]*ticket.Comment, len(comments))
	for i := range comments {
		commentPtrs[i] = &comments[i]
	}
	return commentPtrs, nil
}

// AlertsCount is the resolver for the alertsCount field.
func (r *ticketResolver) AlertsCount(ctx context.Context, obj *ticket.Ticket) (int, error) {
	return len(obj.AlertIDs), nil
}

// CommentsCount is the resolver for the commentsCount field.
func (r *ticketResolver) CommentsCount(ctx context.Context, obj *ticket.Ticket) (int, error) {
	return r.repo.CountTicketComments(ctx, obj.ID)
}

// Conclusion is the resolver for the conclusion field.
func (r *ticketResolver) Conclusion(ctx context.Context, obj *ticket.Ticket) (*string, error) {
	if obj.Conclusion == "" {
		return nil, nil
	}
	conclusion := string(obj.Conclusion)
	return &conclusion, nil
}

// SlackLink is the resolver for the slackLink field.
func (r *ticketResolver) SlackLink(ctx context.Context, obj *ticket.Ticket) (*string, error) {
	if obj.SlackThread == nil || r.slackService == nil {
		return nil, nil
	}

	slackURL := r.slackService.ToExternalMsgURL(obj.SlackThread.ChannelID, obj.SlackThread.ThreadID)
	if slackURL == "" {
		return nil, nil
	}

	return &slackURL, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *ticketResolver) CreatedAt(ctx context.Context, obj *ticket.Ticket) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *ticketResolver) UpdatedAt(ctx context.Context, obj *ticket.Ticket) (string, error) {
	return obj.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// Tags is the resolver for the tags field.
func (r *ticketResolver) Tags(ctx context.Context, obj *ticket.Ticket) ([]string, error) {
	if r.uc == nil || len(obj.TagIDs) == 0 {
		return []string{}, nil
	}

	// Use the compatibility method to get tag names
	return obj.GetTagNames(ctx, r.createTagGetter())
}

// TagObjects is the resolver for the tagObjects field.
func (r *ticketResolver) TagObjects(ctx context.Context, obj *ticket.Ticket) ([]*graphql1.TagObject, error) {
	if r.uc == nil || len(obj.TagIDs) == 0 {
		return []*graphql1.TagObject{}, nil
	}

	// Get tag IDs as slice
	tagIDSlice := make([]string, 0, len(obj.TagIDs))
	for tagID := range obj.TagIDs {
		tagIDSlice = append(tagIDSlice, tagID)
	}

	// Get tag metadata using tag getter
	tags, err := r.createTagGetter()(ctx, tagIDSlice)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL TagObject
	tagObjects := make([]*graphql1.TagObject, 0, len(tags))
	for _, tag := range tags {
		tagObjects = append(tagObjects, &graphql1.TagObject{
			ID:   tag.ID,
			Name: tag.Name,
		})
	}

	return tagObjects, nil
}

// Activity returns ActivityResolver implementation.
func (r *Resolver) Activity() ActivityResolver { return &activityResolver{r} }

// Alert returns AlertResolver implementation.
func (r *Resolver) Alert() AlertResolver { return &alertResolver{r} }

// Comment returns CommentResolver implementation.
func (r *Resolver) Comment() CommentResolver { return &commentResolver{r} }

// Finding returns FindingResolver implementation.
func (r *Resolver) Finding() FindingResolver { return &findingResolver{r} }

// Knowledge returns KnowledgeResolver implementation.
func (r *Resolver) Knowledge() KnowledgeResolver { return &knowledgeResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Session returns SessionResolver implementation.
func (r *Resolver) Session() SessionResolver { return &sessionResolver{r} }

// Ticket returns TicketResolver implementation.
func (r *Resolver) Ticket() TicketResolver { return &ticketResolver{r} }

type activityResolver struct{ *Resolver }
type alertResolver struct{ *Resolver }
type commentResolver struct{ *Resolver }
type findingResolver struct{ *Resolver }
type knowledgeResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type sessionResolver struct{ *Resolver }
type ticketResolver struct{ *Resolver }
