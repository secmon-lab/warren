package usecase

import (
	"context"
	"encoding/json"
	"errors"
	"strings"
	"time"

	"github.com/m-mizutani/goerr/v2"
	"github.com/m-mizutani/gollem"
	"github.com/m-mizutani/opaq"
	"github.com/secmon-lab/warren/pkg/domain/interfaces"
	"github.com/secmon-lab/warren/pkg/domain/model/action"
	"github.com/secmon-lab/warren/pkg/domain/model/alert"
	"github.com/secmon-lab/warren/pkg/domain/model/notice"
	"github.com/secmon-lab/warren/pkg/domain/types"
	"github.com/secmon-lab/warren/pkg/utils/clock"
	"github.com/secmon-lab/warren/pkg/utils/logging"
)

// evaluateAction evaluates an action policy for the given alert and LLM response
func evaluateAction(ctx context.Context, policyClient interfaces.PolicyClient, alert *alert.Alert, llmResponse any) (*action.PolicyResult, error) {
	// Use the parsed LLM response directly for structured data access in policy
	genAIData := llmResponse

	queryInput := action.QueryInput{
		Alert: alert,
		GenAI: genAIData,
	}

	var result action.PolicyResult
	query := "data.action"
	hook := func(ctx context.Context, loc opaq.PrintLocation, msg string) error {
		logging.From(ctx).Debug("[rego.print] "+msg, "location", loc)
		return nil
	}

	err := policyClient.Query(ctx, query, queryInput, &result, opaq.WithPrintHook(hook))
	if err != nil {
		if errors.Is(err, opaq.ErrNoEvalResult) {
			// Default behavior when no action policy is defined: publish as alert
			return &action.PolicyResult{
				Publish: types.PublishTypeAlert,
			}, nil
		}
		return nil, goerr.Wrap(err, "failed to evaluate action policy")
	}

	return &result, nil
}

func (uc *UseCases) HandleAlert(ctx context.Context, schema types.AlertSchema, alertData any) ([]*alert.Alert, error) {
	logger := logging.From(ctx)

	var result alert.QueryOutput
	query := "data.alert." + string(schema)
	hook := func(ctx context.Context, loc opaq.PrintLocation, msg string) error {
		logging.From(ctx).Debug("[rego.print] "+msg, "location", loc)
		return nil
	}

	err := uc.policyClient.Query(ctx, query, alertData, &result, opaq.WithPrintHook(hook))
	if err != nil {
		// Check if it's a "no evaluation result" error (package not found)
		if errors.Is(err, opaq.ErrNoEvalResult) {
			if uc.strictAlert {
				// In strict mode, return error for missing policy package
				return nil, goerr.Wrap(err, "no policy package found for schema",
					goerr.V("schema", schema),
					goerr.V("alert", alertData))
			}

			// Default mode: generate default alert
			logger.Info("no policy package found, generating default alert",
				"schema", schema)

			defaultAlert := alert.New(ctx, schema, alertData, alert.Metadata{
				// Title and Description will be generated by FillMetadata
			})

			newAlert, err := uc.handleAlert(ctx, defaultAlert)
			if err != nil {
				return nil, goerr.Wrap(err, "failed to handle default alert")
			}
			return []*alert.Alert{newAlert}, nil
		}

		// Other errors should be returned as-is
		return nil, goerr.Wrap(err, "failed to query policy",
			goerr.V("schema", schema),
			goerr.V("alert", alertData))
	}

	logger.Info("policy query result", "input", alertData, "output", result, "query", query)

	var results []*alert.Alert
	for _, a := range result.Alert {
		alert := alert.New(ctx, schema, alertData, a)
		if alert.Data == nil {
			alert.Data = alertData
		}

		newAlert, err := uc.handleAlert(ctx, alert)
		if err != nil {
			return nil, goerr.Wrap(err, "failed to handle alert", goerr.V("alert", a))
		}
		results = append(results, newAlert)
	}

	return results, nil
}

func (uc *UseCases) handleAlert(ctx context.Context, newAlert alert.Alert) (*alert.Alert, error) {
	logger := logging.From(ctx)

	// Convert metadata tags (string names) to tag IDs and store in Alert.Tags
	if len(newAlert.Metadata.Tags) > 0 && uc.tagService != nil {
		// Use the tag service to convert names to IDs (creates tags if they don't exist)
		tags, err := uc.tagService.ConvertNamesToTags(ctx, newAlert.Metadata.Tags)
		if err != nil {
			return nil, goerr.Wrap(err, "failed to convert tag names")
		}
		if newAlert.TagIDs == nil {
			newAlert.TagIDs = make(map[string]bool)
		}
		for _, tagID := range tags {
			newAlert.TagIDs[tagID] = true
		}
	}

	if err := newAlert.FillMetadata(ctx, uc.llmClient); err != nil {
		return nil, goerr.Wrap(err, "failed to fill alert metadata")
	}

	// Process GenAI if configured
	if newAlert.Metadata.GenAI != nil {
		llmResponse, err := uc.processGenAI(ctx, &newAlert)
		if err != nil {
			return nil, goerr.Wrap(err, "failed to process GenAI")
		}

		// Evaluate action policy if LLM response is not empty
		if llmResponse != nil {
			policyResult, err := evaluateAction(ctx, uc.policyClient, &newAlert, llmResponse)
			if err != nil {
				return nil, goerr.Wrap(err, "failed to evaluate action policy")
			}

			// Apply metadata updates from policy result
			if policyResult.Title != "" {
				newAlert.Metadata.Title = policyResult.Title
				newAlert.Metadata.TitleSource = types.SourcePolicy
			}
			if policyResult.Description != "" {
				newAlert.Metadata.Description = policyResult.Description
				newAlert.Metadata.DescriptionSource = types.SourcePolicy
			}
			// Apply additional attributes
			if len(policyResult.Attr) > 0 {
				for key, value := range policyResult.Attr {
					newAlert.Metadata.Attributes = append(newAlert.Metadata.Attributes, alert.Attribute{
						Key:   key,
						Value: value,
						Auto:  true, // Set by policy, mark as auto-generated
					})
				}
			}
			// Apply channel configuration from policy result
			if policyResult.Channel != "" {
				newAlert.Metadata.Channel = policyResult.Channel
			}

			// Handle publish type from policy result
			switch policyResult.Publish {
			case types.PublishTypeDiscard:
				// Discard alert, just log and return
				logger.Info("alert discarded by GenAI policy", "alert", newAlert)
				return &newAlert, nil

			case types.PublishTypeNotice:
				// Create notice instead of full alert
				genaiResponse := &alert.GenAIResponse{
					Data:   llmResponse,
					Format: newAlert.Metadata.GenAI.Format,
				}
				if err := uc.handleNotice(ctx, &newAlert, policyResult.Channel, genaiResponse); err != nil {
					return nil, goerr.Wrap(err, "failed to handle notice")
				}
				logger.Info("alert processed as notice", "alert", newAlert)
				return &newAlert, nil

			case types.PublishTypeAlert, "":
				// Continue with normal alert processing
				logger.Info("alert will be processed normally", "alert", newAlert)

			default:
				logger.Warn("unknown publish type, defaulting to alert", "publish", policyResult.Publish)
			}
		}
	}

	// Get alerts from the last 24 hours and search for those not bound to tickets
	now := clock.Now(ctx)
	begin := now.Add(-24 * time.Hour)
	end := now

	recentAlerts, err := uc.repository.GetAlertsBySpan(ctx, begin, end)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get recent alerts")
	}

	// Filter alerts that are not bound to tickets
	var unboundAlerts []*alert.Alert
	for _, recentAlert := range recentAlerts {
		if recentAlert.TicketID == types.EmptyTicketID && len(recentAlert.Embedding) > 0 {
			unboundAlerts = append(unboundAlerts, recentAlert)
		}
	}

	var existingAlert *alert.Alert
	var bestSimilarity float64

	// Search for the alert with the closest embedding (similarity >= 0.99)
	if len(unboundAlerts) > 0 {
		for _, unboundAlert := range unboundAlerts {
			similarity := newAlert.CosineSimilarity(unboundAlert.Embedding)
			if similarity >= 0.99 && similarity > bestSimilarity {
				bestSimilarity = similarity
				existingAlert = unboundAlert
			}
		}
	}

	if existingAlert != nil && existingAlert.HasSlackThread() && uc.slackService != nil {
		// Post to existing thread
		thread := uc.slackService.NewThread(*existingAlert.SlackThread)
		if err := thread.PostAlert(ctx, &newAlert); err != nil {
			return nil, goerr.Wrap(err, "failed to post alert to existing thread", goerr.V("alert", newAlert), goerr.V("existing_alert", existingAlert))
		}
		newAlert.SlackThread = existingAlert.SlackThread
		logger.Info("alert posted to existing thread", "alert", newAlert, "existing_alert", existingAlert, "similarity", bestSimilarity)
	} else if uc.slackService != nil {
		// Post to new thread (normal posting)
		newThread, err := uc.slackService.PostAlert(ctx, &newAlert)
		if err != nil {
			return nil, goerr.Wrap(err, "failed to post alert", goerr.V("alert", newAlert))
		}
		if newThread != nil {
			newAlert.SlackThread = newThread.Entity()
		}
		logger.Info("alert posted to new thread", "alert", newAlert)
	}

	if err := uc.repository.PutAlert(ctx, newAlert); err != nil {
		return nil, goerr.Wrap(err, "failed to put alert", goerr.V("alert", newAlert))
	}
	logger.Info("alert created", "alert", newAlert)

	return &newAlert, nil
}

// GetUnboundAlertsFiltered returns unbound alerts filtered by similarity threshold and keyword
func (uc *UseCases) GetUnboundAlertsFiltered(ctx context.Context, threshold *float64, keyword *string, ticketID *types.TicketID, offset, limit int) ([]*alert.Alert, int, error) {
	var candidateAlerts []*alert.Alert
	var err error

	// Step 1: Get candidate alerts - always start with unbound alerts for salvage search
	if threshold != nil && ticketID != nil && *ticketID != types.EmptyTicketID {
		// Get ticket for similarity comparison
		ticketObj, err := uc.repository.GetTicket(ctx, *ticketID)
		if err != nil {
			return nil, 0, goerr.Wrap(err, "failed to get ticket for similarity filtering")
		}

		// Get ALL unbound alerts first, then filter by similarity
		allUnboundAlerts, err := uc.repository.GetAlertWithoutTicket(ctx, 0, 0) // Get all unbound alerts
		if err != nil {
			return nil, 0, goerr.Wrap(err, "failed to get unbound alerts")
		}

		if len(ticketObj.Embedding) > 0 {
			// Filter unbound alerts by similarity threshold
			for _, a := range allUnboundAlerts {
				// Only check alerts that have embeddings
				if len(a.Embedding) > 0 {
					similarity := a.CosineSimilarity(ticketObj.Embedding)
					if float64(similarity) >= *threshold {
						candidateAlerts = append(candidateAlerts, a)
					}
				}
			}
		} else {
			candidateAlerts = allUnboundAlerts
		}
	} else {
		// Get all unbound alerts as candidates
		candidateAlerts, err = uc.repository.GetAlertWithoutTicket(ctx, 0, 0) // Get all for filtering
		if err != nil {
			return nil, 0, goerr.Wrap(err, "failed to get unbound alerts")
		}
	}

	// Step 2: Apply keyword filter to candidate alerts
	var filteredAlerts []*alert.Alert
	if keyword != nil && *keyword != "" {
		for _, a := range candidateAlerts {
			// Convert data to JSON string for keyword search
			dataBytes, err := json.Marshal(a.Data)
			if err != nil {
				continue
			}
			dataStr := string(dataBytes)

			// Check if keyword exists in title, description, or data
			if containsIgnoreCase(a.Title, *keyword) ||
				containsIgnoreCase(a.Description, *keyword) ||
				containsIgnoreCase(dataStr, *keyword) {
				filteredAlerts = append(filteredAlerts, a)
			}
		}
	} else {
		// No keyword filter, use all candidates
		filteredAlerts = candidateAlerts
	}

	// Step 3: Calculate total count from fully filtered results
	totalCount := len(filteredAlerts)

	// Step 4: Apply pagination to the filtered results
	start := offset
	if start > len(filteredAlerts) {
		start = len(filteredAlerts)
	}

	end := start + limit
	if limit > 0 && end > len(filteredAlerts) {
		end = len(filteredAlerts)
	}
	if limit == 0 {
		end = len(filteredAlerts)
	}

	result := filteredAlerts[start:end]

	return result, totalCount, nil
}

// BindAlertsToTicket binds multiple alerts to a ticket, recalculates embedding, and updates Slack display
func (uc *UseCases) BindAlertsToTicket(ctx context.Context, ticketID types.TicketID, alertIDs []types.AlertID) error {
	// Bind alerts to ticket (repository handles bidirectional binding)
	err := uc.repository.BindAlertsToTicket(ctx, alertIDs, ticketID)
	if err != nil {
		return goerr.Wrap(err, "failed to bind alerts to ticket")
	}

	// Get the updated ticket with new AlertIDs
	ticket, err := uc.repository.GetTicket(ctx, ticketID)
	if err != nil {
		return goerr.Wrap(err, "failed to get updated ticket")
	}

	// Recalculate ticket embedding with all bound alerts
	if err := ticket.CalculateEmbedding(ctx, uc.llmClient, uc.repository); err != nil {
		return goerr.Wrap(err, "failed to recalculate ticket embedding")
	}

	// Update ticket metadata based on existing title/description and new alert information
	if err := ticket.FillMetadata(ctx, uc.llmClient, uc.repository); err != nil {
		return goerr.Wrap(err, "failed to update ticket metadata with new alert information")
	}

	// Save the updated ticket with new embedding and metadata
	if err := uc.repository.PutTicket(ctx, *ticket); err != nil {
		return goerr.Wrap(err, "failed to save ticket with updated embedding and metadata")
	}

	// Update Slack display for both ticket and individual alerts (using updated metadata)
	// Update ticket display if it has a Slack thread
	if ticket.HasSlackThread() {
		// Get all alerts bound to the ticket for display
		alerts, err := uc.repository.BatchGetAlerts(ctx, ticket.AlertIDs)
		if err != nil {
			logging.From(ctx).Warn("failed to get alerts for Slack update", "error", err, "ticket_id", ticketID)
		} else if uc.slackService != nil {
			thread := uc.slackService.NewThread(*ticket.SlackThread)
			if _, err := thread.PostTicket(ctx, ticket, alerts); err != nil {
				// Log error but don't fail the operation
				logging.From(ctx).Warn("failed to update Slack thread after binding alerts", "error", err, "ticket_id", ticketID)
			}
		}
	}

	// Update individual alert displays in their respective threads
	boundAlerts, err := uc.repository.BatchGetAlerts(ctx, alertIDs)
	if err != nil {
		logging.From(ctx).Warn("failed to get bound alerts for individual Slack updates", "error", err, "alert_ids", alertIDs)
	} else {
		for _, alert := range boundAlerts {
			if alert.HasSlackThread() && uc.slackService != nil {
				alertThread := uc.slackService.NewThread(*alert.SlackThread)
				if err := alertThread.UpdateAlert(ctx, *alert); err != nil {
					// Log error but don't fail the operation
					logging.From(ctx).Warn("failed to update alert Slack display", "error", err, "alert_id", alert.ID)
				}
			}
		}
	}

	return nil
}

// containsIgnoreCase checks if substr exists in s (case insensitive)
func containsIgnoreCase(s, substr string) bool {
	return strings.Contains(strings.ToLower(s), strings.ToLower(substr))
}

// processGenAI processes GenAI configuration for the given alert
func (uc *UseCases) processGenAI(ctx context.Context, alert *alert.Alert) (any, error) {
	if alert.Metadata.GenAI == nil {
		return "", nil
	}

	if uc.promptService == nil {
		return "", goerr.New("prompt service not configured")
	}

	genaiConfig := alert.Metadata.GenAI

	// Generate prompt using PromptService
	prompt, err := uc.promptService.GeneratePrompt(ctx, genaiConfig.Prompt, alert)
	if err != nil {
		return "", goerr.Wrap(err, "failed to generate prompt", goerr.V("prompt", genaiConfig.Prompt))
	}

	var options []gollem.SessionOption
	if genaiConfig.Format == types.GenAIContentFormatJSON {
		options = append(options, gollem.WithSessionContentType(gollem.ContentTypeJSON))
	}

	// Query LLM with JSON response format
	session, err := uc.llmClient.NewSession(ctx, options...)
	if err != nil {
		return "", goerr.Wrap(err, "failed to create LLM session")
	}

	response, err := session.GenerateContent(ctx, gollem.Text(prompt))
	if err != nil {
		return "", goerr.Wrap(err, "failed to query LLM", goerr.V("prompt", prompt))
	}

	var responseText string
	if len(response.Texts) > 0 {
		responseText = response.Texts[0]
	}

	var responseData any = responseText
	logger := logging.From(ctx)

	// Parse JSON response if format is JSON
	if genaiConfig.Format == types.GenAIContentFormatJSON {
		var parsedResponse any
		if err := json.Unmarshal([]byte(responseText), &parsedResponse); err != nil {
			// If JSON parsing fails, return raw string
			logger.Warn("failed to parse LLM response as JSON", "text", responseText)
		} else {
			responseData = parsedResponse
		}
	}

	logger.Info("Got GenAI response", "response", responseData)
	return responseData, nil
}

// handleNotice handles notice creation and simple notification
func (uc *UseCases) handleNotice(ctx context.Context, alert *alert.Alert, channel string, llmResponse *alert.GenAIResponse) error {
	logger := logging.From(ctx)

	// Create notice
	notice := &notice.Notice{
		ID:        types.NewNoticeID(),
		Alert:     *alert,
		CreatedAt: clock.Now(ctx),
		Escalated: false,
	}

	// Store notice in repository
	if err := uc.repository.CreateNotice(ctx, notice); err != nil {
		return goerr.Wrap(err, "failed to create notice")
	}

	// Send simple notification to Slack
	if uc.slackService != nil {
		slackTS, err := uc.sendSimpleNotification(ctx, notice, channel, llmResponse)
		if err != nil {
			logger.Warn("failed to send simple notification", "error", err, "notice_id", notice.ID)
		} else {
			// Update notice with Slack timestamp
			notice.SlackTS = slackTS
			if err := uc.repository.UpdateNotice(ctx, notice); err != nil {
				logger.Warn("failed to update notice with slack timestamp", "error", err, "notice_id", notice.ID)
			}
		}
	}

	logger.Info("notice created", "notice_id", notice.ID, "alert_id", alert.ID)
	return nil
}

// sendSimpleNotification sends a simple notification to Slack
func (uc *UseCases) sendSimpleNotification(ctx context.Context, notice *notice.Notice, channel string, llmResponse *alert.GenAIResponse) (string, error) {
	if uc.slackService == nil {
		return "", goerr.New("slack service not available")
	}

	alert := &notice.Alert

	// Create simple message with only title for main channel
	var mainMessage string
	if alert.Metadata.Title != "" {
		mainMessage = "ðŸ”” " + alert.Metadata.Title
	} else {
		mainMessage = "ðŸ”” Security Notice"
	}

	// Resolve target channel (use default if empty)
	targetChannel := channel
	if targetChannel == "" {
		targetChannel = uc.slackService.DefaultChannelID()
	}

	// Post main notice message
	timestamp, err := uc.slackService.PostNotice(ctx, targetChannel, mainMessage, notice.ID)
	if err != nil {
		return "", goerr.Wrap(err, "failed to post notice to Slack", goerr.V("channel", targetChannel))
	}

	// Post detailed information in thread
	if err := uc.slackService.PostNoticeThreadDetails(ctx, targetChannel, timestamp, alert, llmResponse); err != nil {
		// Log error but don't fail the main operation
		logging.From(ctx).Warn("failed to post notice thread details", "error", err, "channel", targetChannel)
	}

	return timestamp, nil
}

// EscalateNotice escalates a notice to a full alert
func (uc *UseCases) EscalateNotice(ctx context.Context, noticeID types.NoticeID) error {
	logger := logging.From(ctx)

	// Get notice from repository
	notice, err := uc.repository.GetNotice(ctx, noticeID)
	if err != nil {
		return goerr.Wrap(err, "failed to get notice", goerr.V("notice_id", noticeID))
	}

	// Mark notice as escalated
	notice.Escalated = true
	if err := uc.repository.UpdateNotice(ctx, notice); err != nil {
		return goerr.Wrap(err, "failed to update notice", goerr.V("notice_id", noticeID))
	}

	// Process the alert normally (without GenAI processing to avoid recursion)
	alert := notice.Alert
	escalatedAlert, err := uc.handleAlertWithoutGenAI(ctx, alert)
	if err != nil {
		return goerr.Wrap(err, "failed to handle escalated alert", goerr.V("notice_id", noticeID))
	}

	logger.Info("notice escalated to alert", "notice_id", noticeID, "alert_id", escalatedAlert.ID)
	return nil
}

// handleAlertWithoutGenAI handles alert without GenAI processing (used for escalation)
func (uc *UseCases) handleAlertWithoutGenAI(ctx context.Context, alert alert.Alert) (*alert.Alert, error) {
	// This method processes alerts that have already been through tag processing and metadata filling
	// Used for escalation from notices to avoid reprocessing
	logger := logging.From(ctx)

	// Post to Slack
	if uc.slackService != nil {
		newThread, err := uc.slackService.PostAlert(ctx, &alert)
		if err != nil {
			return nil, goerr.Wrap(err, "failed to post alert")
		}
		if newThread != nil {
			alert.SlackThread = newThread.Entity()
		}
		logger.Info("escalated alert posted to new thread", "alert", alert)
	}

	// Store alert
	if err := uc.repository.PutAlert(ctx, alert); err != nil {
		return nil, goerr.Wrap(err, "failed to put alert")
	}
	logger.Info("escalated alert created", "alert", alert)

	return &alert, nil
}
