// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/m-mizutani/gollem"
	"github.com/m-mizutani/opaq"
	"github.com/secmon-lab/warren/pkg/domain/event"
	"github.com/secmon-lab/warren/pkg/domain/model/activity"
	"github.com/secmon-lab/warren/pkg/domain/model/alert"
	"github.com/secmon-lab/warren/pkg/domain/model/auth"
	"github.com/secmon-lab/warren/pkg/domain/model/knowledge"
	"github.com/secmon-lab/warren/pkg/domain/model/memory"
	"github.com/secmon-lab/warren/pkg/domain/model/notice"
	"github.com/secmon-lab/warren/pkg/domain/model/session"
	"github.com/secmon-lab/warren/pkg/domain/model/slack"
	"github.com/secmon-lab/warren/pkg/domain/model/tag"
	"github.com/secmon-lab/warren/pkg/domain/model/ticket"
	"github.com/secmon-lab/warren/pkg/domain/types"
	slackSDK "github.com/slack-go/slack"
	"io"
	"sync"
	"time"
)

// SlackClientMock is a mock implementation of interfaces.SlackClient.
//
//	func TestSomethingThatUsesSlackClient(t *testing.T) {
//
//		// make and configure a mocked interfaces.SlackClient
//		mockedSlackClient := &SlackClientMock{
//			AuthTestFunc: func() (*slackSDK.AuthTestResponse, error) {
//				panic("mock out the AuthTest method")
//			},
//			DeleteMessageContextFunc: func(ctx context.Context, channelID string, timestamp string) (string, string, error) {
//				panic("mock out the DeleteMessageContext method")
//			},
//			GetBotInfoContextFunc: func(ctx context.Context, parameters slackSDK.GetBotInfoParameters) (*slackSDK.Bot, error) {
//				panic("mock out the GetBotInfoContext method")
//			},
//			GetConversationHistoryContextFunc: func(ctx context.Context, params *slackSDK.GetConversationHistoryParameters) (*slackSDK.GetConversationHistoryResponse, error) {
//				panic("mock out the GetConversationHistoryContext method")
//			},
//			GetConversationInfoFunc: func(input *slackSDK.GetConversationInfoInput) (*slackSDK.Channel, error) {
//				panic("mock out the GetConversationInfo method")
//			},
//			GetConversationRepliesContextFunc: func(ctx context.Context, params *slackSDK.GetConversationRepliesParameters) ([]slackSDK.Message, bool, string, error) {
//				panic("mock out the GetConversationRepliesContext method")
//			},
//			GetTeamInfoFunc: func() (*slackSDK.TeamInfo, error) {
//				panic("mock out the GetTeamInfo method")
//			},
//			GetUserGroupsFunc: func(options ...slackSDK.GetUserGroupsOption) ([]slackSDK.UserGroup, error) {
//				panic("mock out the GetUserGroups method")
//			},
//			GetUserInfoFunc: func(userID string) (*slackSDK.User, error) {
//				panic("mock out the GetUserInfo method")
//			},
//			GetUsersInfoFunc: func(users ...string) (*[]slackSDK.User, error) {
//				panic("mock out the GetUsersInfo method")
//			},
//			OpenViewFunc: func(triggerID string, view slackSDK.ModalViewRequest) (*slackSDK.ViewResponse, error) {
//				panic("mock out the OpenView method")
//			},
//			PostMessageContextFunc: func(ctx context.Context, channelID string, options ...slackSDK.MsgOption) (string, string, error) {
//				panic("mock out the PostMessageContext method")
//			},
//			SearchMessagesContextFunc: func(ctx context.Context, query string, params slackSDK.SearchParameters) (*slackSDK.SearchMessages, error) {
//				panic("mock out the SearchMessagesContext method")
//			},
//			UpdateMessageContextFunc: func(ctx context.Context, channelID string, timestamp string, options ...slackSDK.MsgOption) (string, string, string, error) {
//				panic("mock out the UpdateMessageContext method")
//			},
//			UpdateViewFunc: func(view slackSDK.ModalViewRequest, externalID string, hash string, viewID string) (*slackSDK.ViewResponse, error) {
//				panic("mock out the UpdateView method")
//			},
//			UploadFileV2ContextFunc: func(ctx context.Context, params slackSDK.UploadFileV2Parameters) (*slackSDK.FileSummary, error) {
//				panic("mock out the UploadFileV2Context method")
//			},
//		}
//
//		// use mockedSlackClient in code that requires interfaces.SlackClient
//		// and then make assertions.
//
//	}
type SlackClientMock struct {
	// AuthTestFunc mocks the AuthTest method.
	AuthTestFunc func() (*slackSDK.AuthTestResponse, error)

	// DeleteMessageContextFunc mocks the DeleteMessageContext method.
	DeleteMessageContextFunc func(ctx context.Context, channelID string, timestamp string) (string, string, error)

	// GetBotInfoContextFunc mocks the GetBotInfoContext method.
	GetBotInfoContextFunc func(ctx context.Context, parameters slackSDK.GetBotInfoParameters) (*slackSDK.Bot, error)

	// GetConversationHistoryContextFunc mocks the GetConversationHistoryContext method.
	GetConversationHistoryContextFunc func(ctx context.Context, params *slackSDK.GetConversationHistoryParameters) (*slackSDK.GetConversationHistoryResponse, error)

	// GetConversationInfoFunc mocks the GetConversationInfo method.
	GetConversationInfoFunc func(input *slackSDK.GetConversationInfoInput) (*slackSDK.Channel, error)

	// GetConversationRepliesContextFunc mocks the GetConversationRepliesContext method.
	GetConversationRepliesContextFunc func(ctx context.Context, params *slackSDK.GetConversationRepliesParameters) ([]slackSDK.Message, bool, string, error)

	// GetTeamInfoFunc mocks the GetTeamInfo method.
	GetTeamInfoFunc func() (*slackSDK.TeamInfo, error)

	// GetUserGroupsFunc mocks the GetUserGroups method.
	GetUserGroupsFunc func(options ...slackSDK.GetUserGroupsOption) ([]slackSDK.UserGroup, error)

	// GetUserInfoFunc mocks the GetUserInfo method.
	GetUserInfoFunc func(userID string) (*slackSDK.User, error)

	// GetUsersInfoFunc mocks the GetUsersInfo method.
	GetUsersInfoFunc func(users ...string) (*[]slackSDK.User, error)

	// OpenViewFunc mocks the OpenView method.
	OpenViewFunc func(triggerID string, view slackSDK.ModalViewRequest) (*slackSDK.ViewResponse, error)

	// PostMessageContextFunc mocks the PostMessageContext method.
	PostMessageContextFunc func(ctx context.Context, channelID string, options ...slackSDK.MsgOption) (string, string, error)

	// SearchMessagesContextFunc mocks the SearchMessagesContext method.
	SearchMessagesContextFunc func(ctx context.Context, query string, params slackSDK.SearchParameters) (*slackSDK.SearchMessages, error)

	// UpdateMessageContextFunc mocks the UpdateMessageContext method.
	UpdateMessageContextFunc func(ctx context.Context, channelID string, timestamp string, options ...slackSDK.MsgOption) (string, string, string, error)

	// UpdateViewFunc mocks the UpdateView method.
	UpdateViewFunc func(view slackSDK.ModalViewRequest, externalID string, hash string, viewID string) (*slackSDK.ViewResponse, error)

	// UploadFileV2ContextFunc mocks the UploadFileV2Context method.
	UploadFileV2ContextFunc func(ctx context.Context, params slackSDK.UploadFileV2Parameters) (*slackSDK.FileSummary, error)

	// calls tracks calls to the methods.
	calls struct {
		// AuthTest holds details about calls to the AuthTest method.
		AuthTest []struct {
		}
		// DeleteMessageContext holds details about calls to the DeleteMessageContext method.
		DeleteMessageContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ChannelID is the channelID argument value.
			ChannelID string
			// Timestamp is the timestamp argument value.
			Timestamp string
		}
		// GetBotInfoContext holds details about calls to the GetBotInfoContext method.
		GetBotInfoContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Parameters is the parameters argument value.
			Parameters slackSDK.GetBotInfoParameters
		}
		// GetConversationHistoryContext holds details about calls to the GetConversationHistoryContext method.
		GetConversationHistoryContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params *slackSDK.GetConversationHistoryParameters
		}
		// GetConversationInfo holds details about calls to the GetConversationInfo method.
		GetConversationInfo []struct {
			// Input is the input argument value.
			Input *slackSDK.GetConversationInfoInput
		}
		// GetConversationRepliesContext holds details about calls to the GetConversationRepliesContext method.
		GetConversationRepliesContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params *slackSDK.GetConversationRepliesParameters
		}
		// GetTeamInfo holds details about calls to the GetTeamInfo method.
		GetTeamInfo []struct {
		}
		// GetUserGroups holds details about calls to the GetUserGroups method.
		GetUserGroups []struct {
			// Options is the options argument value.
			Options []slackSDK.GetUserGroupsOption
		}
		// GetUserInfo holds details about calls to the GetUserInfo method.
		GetUserInfo []struct {
			// UserID is the userID argument value.
			UserID string
		}
		// GetUsersInfo holds details about calls to the GetUsersInfo method.
		GetUsersInfo []struct {
			// Users is the users argument value.
			Users []string
		}
		// OpenView holds details about calls to the OpenView method.
		OpenView []struct {
			// TriggerID is the triggerID argument value.
			TriggerID string
			// View is the view argument value.
			View slackSDK.ModalViewRequest
		}
		// PostMessageContext holds details about calls to the PostMessageContext method.
		PostMessageContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ChannelID is the channelID argument value.
			ChannelID string
			// Options is the options argument value.
			Options []slackSDK.MsgOption
		}
		// SearchMessagesContext holds details about calls to the SearchMessagesContext method.
		SearchMessagesContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Query is the query argument value.
			Query string
			// Params is the params argument value.
			Params slackSDK.SearchParameters
		}
		// UpdateMessageContext holds details about calls to the UpdateMessageContext method.
		UpdateMessageContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ChannelID is the channelID argument value.
			ChannelID string
			// Timestamp is the timestamp argument value.
			Timestamp string
			// Options is the options argument value.
			Options []slackSDK.MsgOption
		}
		// UpdateView holds details about calls to the UpdateView method.
		UpdateView []struct {
			// View is the view argument value.
			View slackSDK.ModalViewRequest
			// ExternalID is the externalID argument value.
			ExternalID string
			// Hash is the hash argument value.
			Hash string
			// ViewID is the viewID argument value.
			ViewID string
		}
		// UploadFileV2Context holds details about calls to the UploadFileV2Context method.
		UploadFileV2Context []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params slackSDK.UploadFileV2Parameters
		}
	}
	lockAuthTest                      sync.RWMutex
	lockDeleteMessageContext          sync.RWMutex
	lockGetBotInfoContext             sync.RWMutex
	lockGetConversationHistoryContext sync.RWMutex
	lockGetConversationInfo           sync.RWMutex
	lockGetConversationRepliesContext sync.RWMutex
	lockGetTeamInfo                   sync.RWMutex
	lockGetUserGroups                 sync.RWMutex
	lockGetUserInfo                   sync.RWMutex
	lockGetUsersInfo                  sync.RWMutex
	lockOpenView                      sync.RWMutex
	lockPostMessageContext            sync.RWMutex
	lockSearchMessagesContext         sync.RWMutex
	lockUpdateMessageContext          sync.RWMutex
	lockUpdateView                    sync.RWMutex
	lockUploadFileV2Context           sync.RWMutex
}

// AuthTest calls AuthTestFunc.
func (mock *SlackClientMock) AuthTest() (*slackSDK.AuthTestResponse, error) {
	callInfo := struct {
	}{}
	mock.lockAuthTest.Lock()
	mock.calls.AuthTest = append(mock.calls.AuthTest, callInfo)
	mock.lockAuthTest.Unlock()
	if mock.AuthTestFunc == nil {
		var (
			authTestResponseOut *slackSDK.AuthTestResponse
			errOut              error
		)
		return authTestResponseOut, errOut
	}
	return mock.AuthTestFunc()
}

// AuthTestCalls gets all the calls that were made to AuthTest.
// Check the length with:
//
//	len(mockedSlackClient.AuthTestCalls())
func (mock *SlackClientMock) AuthTestCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockAuthTest.RLock()
	calls = mock.calls.AuthTest
	mock.lockAuthTest.RUnlock()
	return calls
}

// DeleteMessageContext calls DeleteMessageContextFunc.
func (mock *SlackClientMock) DeleteMessageContext(ctx context.Context, channelID string, timestamp string) (string, string, error) {
	callInfo := struct {
		Ctx       context.Context
		ChannelID string
		Timestamp string
	}{
		Ctx:       ctx,
		ChannelID: channelID,
		Timestamp: timestamp,
	}
	mock.lockDeleteMessageContext.Lock()
	mock.calls.DeleteMessageContext = append(mock.calls.DeleteMessageContext, callInfo)
	mock.lockDeleteMessageContext.Unlock()
	if mock.DeleteMessageContextFunc == nil {
		var (
			sOut1  string
			sOut2  string
			errOut error
		)
		return sOut1, sOut2, errOut
	}
	return mock.DeleteMessageContextFunc(ctx, channelID, timestamp)
}

// DeleteMessageContextCalls gets all the calls that were made to DeleteMessageContext.
// Check the length with:
//
//	len(mockedSlackClient.DeleteMessageContextCalls())
func (mock *SlackClientMock) DeleteMessageContextCalls() []struct {
	Ctx       context.Context
	ChannelID string
	Timestamp string
} {
	var calls []struct {
		Ctx       context.Context
		ChannelID string
		Timestamp string
	}
	mock.lockDeleteMessageContext.RLock()
	calls = mock.calls.DeleteMessageContext
	mock.lockDeleteMessageContext.RUnlock()
	return calls
}

// GetBotInfoContext calls GetBotInfoContextFunc.
func (mock *SlackClientMock) GetBotInfoContext(ctx context.Context, parameters slackSDK.GetBotInfoParameters) (*slackSDK.Bot, error) {
	callInfo := struct {
		Ctx        context.Context
		Parameters slackSDK.GetBotInfoParameters
	}{
		Ctx:        ctx,
		Parameters: parameters,
	}
	mock.lockGetBotInfoContext.Lock()
	mock.calls.GetBotInfoContext = append(mock.calls.GetBotInfoContext, callInfo)
	mock.lockGetBotInfoContext.Unlock()
	if mock.GetBotInfoContextFunc == nil {
		var (
			botOut *slackSDK.Bot
			errOut error
		)
		return botOut, errOut
	}
	return mock.GetBotInfoContextFunc(ctx, parameters)
}

// GetBotInfoContextCalls gets all the calls that were made to GetBotInfoContext.
// Check the length with:
//
//	len(mockedSlackClient.GetBotInfoContextCalls())
func (mock *SlackClientMock) GetBotInfoContextCalls() []struct {
	Ctx        context.Context
	Parameters slackSDK.GetBotInfoParameters
} {
	var calls []struct {
		Ctx        context.Context
		Parameters slackSDK.GetBotInfoParameters
	}
	mock.lockGetBotInfoContext.RLock()
	calls = mock.calls.GetBotInfoContext
	mock.lockGetBotInfoContext.RUnlock()
	return calls
}

// GetConversationHistoryContext calls GetConversationHistoryContextFunc.
func (mock *SlackClientMock) GetConversationHistoryContext(ctx context.Context, params *slackSDK.GetConversationHistoryParameters) (*slackSDK.GetConversationHistoryResponse, error) {
	callInfo := struct {
		Ctx    context.Context
		Params *slackSDK.GetConversationHistoryParameters
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockGetConversationHistoryContext.Lock()
	mock.calls.GetConversationHistoryContext = append(mock.calls.GetConversationHistoryContext, callInfo)
	mock.lockGetConversationHistoryContext.Unlock()
	if mock.GetConversationHistoryContextFunc == nil {
		var (
			getConversationHistoryResponseOut *slackSDK.GetConversationHistoryResponse
			errOut                            error
		)
		return getConversationHistoryResponseOut, errOut
	}
	return mock.GetConversationHistoryContextFunc(ctx, params)
}

// GetConversationHistoryContextCalls gets all the calls that were made to GetConversationHistoryContext.
// Check the length with:
//
//	len(mockedSlackClient.GetConversationHistoryContextCalls())
func (mock *SlackClientMock) GetConversationHistoryContextCalls() []struct {
	Ctx    context.Context
	Params *slackSDK.GetConversationHistoryParameters
} {
	var calls []struct {
		Ctx    context.Context
		Params *slackSDK.GetConversationHistoryParameters
	}
	mock.lockGetConversationHistoryContext.RLock()
	calls = mock.calls.GetConversationHistoryContext
	mock.lockGetConversationHistoryContext.RUnlock()
	return calls
}

// GetConversationInfo calls GetConversationInfoFunc.
func (mock *SlackClientMock) GetConversationInfo(input *slackSDK.GetConversationInfoInput) (*slackSDK.Channel, error) {
	callInfo := struct {
		Input *slackSDK.GetConversationInfoInput
	}{
		Input: input,
	}
	mock.lockGetConversationInfo.Lock()
	mock.calls.GetConversationInfo = append(mock.calls.GetConversationInfo, callInfo)
	mock.lockGetConversationInfo.Unlock()
	if mock.GetConversationInfoFunc == nil {
		var (
			channelOut *slackSDK.Channel
			errOut     error
		)
		return channelOut, errOut
	}
	return mock.GetConversationInfoFunc(input)
}

// GetConversationInfoCalls gets all the calls that were made to GetConversationInfo.
// Check the length with:
//
//	len(mockedSlackClient.GetConversationInfoCalls())
func (mock *SlackClientMock) GetConversationInfoCalls() []struct {
	Input *slackSDK.GetConversationInfoInput
} {
	var calls []struct {
		Input *slackSDK.GetConversationInfoInput
	}
	mock.lockGetConversationInfo.RLock()
	calls = mock.calls.GetConversationInfo
	mock.lockGetConversationInfo.RUnlock()
	return calls
}

// GetConversationRepliesContext calls GetConversationRepliesContextFunc.
func (mock *SlackClientMock) GetConversationRepliesContext(ctx context.Context, params *slackSDK.GetConversationRepliesParameters) ([]slackSDK.Message, bool, string, error) {
	callInfo := struct {
		Ctx    context.Context
		Params *slackSDK.GetConversationRepliesParameters
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockGetConversationRepliesContext.Lock()
	mock.calls.GetConversationRepliesContext = append(mock.calls.GetConversationRepliesContext, callInfo)
	mock.lockGetConversationRepliesContext.Unlock()
	if mock.GetConversationRepliesContextFunc == nil {
		var (
			messagesOut []slackSDK.Message
			bOut        bool
			sOut        string
			errOut      error
		)
		return messagesOut, bOut, sOut, errOut
	}
	return mock.GetConversationRepliesContextFunc(ctx, params)
}

// GetConversationRepliesContextCalls gets all the calls that were made to GetConversationRepliesContext.
// Check the length with:
//
//	len(mockedSlackClient.GetConversationRepliesContextCalls())
func (mock *SlackClientMock) GetConversationRepliesContextCalls() []struct {
	Ctx    context.Context
	Params *slackSDK.GetConversationRepliesParameters
} {
	var calls []struct {
		Ctx    context.Context
		Params *slackSDK.GetConversationRepliesParameters
	}
	mock.lockGetConversationRepliesContext.RLock()
	calls = mock.calls.GetConversationRepliesContext
	mock.lockGetConversationRepliesContext.RUnlock()
	return calls
}

// GetTeamInfo calls GetTeamInfoFunc.
func (mock *SlackClientMock) GetTeamInfo() (*slackSDK.TeamInfo, error) {
	callInfo := struct {
	}{}
	mock.lockGetTeamInfo.Lock()
	mock.calls.GetTeamInfo = append(mock.calls.GetTeamInfo, callInfo)
	mock.lockGetTeamInfo.Unlock()
	if mock.GetTeamInfoFunc == nil {
		var (
			teamInfoOut *slackSDK.TeamInfo
			errOut      error
		)
		return teamInfoOut, errOut
	}
	return mock.GetTeamInfoFunc()
}

// GetTeamInfoCalls gets all the calls that were made to GetTeamInfo.
// Check the length with:
//
//	len(mockedSlackClient.GetTeamInfoCalls())
func (mock *SlackClientMock) GetTeamInfoCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetTeamInfo.RLock()
	calls = mock.calls.GetTeamInfo
	mock.lockGetTeamInfo.RUnlock()
	return calls
}

// GetUserGroups calls GetUserGroupsFunc.
func (mock *SlackClientMock) GetUserGroups(options ...slackSDK.GetUserGroupsOption) ([]slackSDK.UserGroup, error) {
	callInfo := struct {
		Options []slackSDK.GetUserGroupsOption
	}{
		Options: options,
	}
	mock.lockGetUserGroups.Lock()
	mock.calls.GetUserGroups = append(mock.calls.GetUserGroups, callInfo)
	mock.lockGetUserGroups.Unlock()
	if mock.GetUserGroupsFunc == nil {
		var (
			userGroupsOut []slackSDK.UserGroup
			errOut        error
		)
		return userGroupsOut, errOut
	}
	return mock.GetUserGroupsFunc(options...)
}

// GetUserGroupsCalls gets all the calls that were made to GetUserGroups.
// Check the length with:
//
//	len(mockedSlackClient.GetUserGroupsCalls())
func (mock *SlackClientMock) GetUserGroupsCalls() []struct {
	Options []slackSDK.GetUserGroupsOption
} {
	var calls []struct {
		Options []slackSDK.GetUserGroupsOption
	}
	mock.lockGetUserGroups.RLock()
	calls = mock.calls.GetUserGroups
	mock.lockGetUserGroups.RUnlock()
	return calls
}

// GetUserInfo calls GetUserInfoFunc.
func (mock *SlackClientMock) GetUserInfo(userID string) (*slackSDK.User, error) {
	callInfo := struct {
		UserID string
	}{
		UserID: userID,
	}
	mock.lockGetUserInfo.Lock()
	mock.calls.GetUserInfo = append(mock.calls.GetUserInfo, callInfo)
	mock.lockGetUserInfo.Unlock()
	if mock.GetUserInfoFunc == nil {
		var (
			userOut *slackSDK.User
			errOut  error
		)
		return userOut, errOut
	}
	return mock.GetUserInfoFunc(userID)
}

// GetUserInfoCalls gets all the calls that were made to GetUserInfo.
// Check the length with:
//
//	len(mockedSlackClient.GetUserInfoCalls())
func (mock *SlackClientMock) GetUserInfoCalls() []struct {
	UserID string
} {
	var calls []struct {
		UserID string
	}
	mock.lockGetUserInfo.RLock()
	calls = mock.calls.GetUserInfo
	mock.lockGetUserInfo.RUnlock()
	return calls
}

// GetUsersInfo calls GetUsersInfoFunc.
func (mock *SlackClientMock) GetUsersInfo(users ...string) (*[]slackSDK.User, error) {
	callInfo := struct {
		Users []string
	}{
		Users: users,
	}
	mock.lockGetUsersInfo.Lock()
	mock.calls.GetUsersInfo = append(mock.calls.GetUsersInfo, callInfo)
	mock.lockGetUsersInfo.Unlock()
	if mock.GetUsersInfoFunc == nil {
		var (
			usersOut *[]slackSDK.User
			errOut   error
		)
		return usersOut, errOut
	}
	return mock.GetUsersInfoFunc(users...)
}

// GetUsersInfoCalls gets all the calls that were made to GetUsersInfo.
// Check the length with:
//
//	len(mockedSlackClient.GetUsersInfoCalls())
func (mock *SlackClientMock) GetUsersInfoCalls() []struct {
	Users []string
} {
	var calls []struct {
		Users []string
	}
	mock.lockGetUsersInfo.RLock()
	calls = mock.calls.GetUsersInfo
	mock.lockGetUsersInfo.RUnlock()
	return calls
}

// OpenView calls OpenViewFunc.
func (mock *SlackClientMock) OpenView(triggerID string, view slackSDK.ModalViewRequest) (*slackSDK.ViewResponse, error) {
	callInfo := struct {
		TriggerID string
		View      slackSDK.ModalViewRequest
	}{
		TriggerID: triggerID,
		View:      view,
	}
	mock.lockOpenView.Lock()
	mock.calls.OpenView = append(mock.calls.OpenView, callInfo)
	mock.lockOpenView.Unlock()
	if mock.OpenViewFunc == nil {
		var (
			viewResponseOut *slackSDK.ViewResponse
			errOut          error
		)
		return viewResponseOut, errOut
	}
	return mock.OpenViewFunc(triggerID, view)
}

// OpenViewCalls gets all the calls that were made to OpenView.
// Check the length with:
//
//	len(mockedSlackClient.OpenViewCalls())
func (mock *SlackClientMock) OpenViewCalls() []struct {
	TriggerID string
	View      slackSDK.ModalViewRequest
} {
	var calls []struct {
		TriggerID string
		View      slackSDK.ModalViewRequest
	}
	mock.lockOpenView.RLock()
	calls = mock.calls.OpenView
	mock.lockOpenView.RUnlock()
	return calls
}

// PostMessageContext calls PostMessageContextFunc.
func (mock *SlackClientMock) PostMessageContext(ctx context.Context, channelID string, options ...slackSDK.MsgOption) (string, string, error) {
	callInfo := struct {
		Ctx       context.Context
		ChannelID string
		Options   []slackSDK.MsgOption
	}{
		Ctx:       ctx,
		ChannelID: channelID,
		Options:   options,
	}
	mock.lockPostMessageContext.Lock()
	mock.calls.PostMessageContext = append(mock.calls.PostMessageContext, callInfo)
	mock.lockPostMessageContext.Unlock()
	if mock.PostMessageContextFunc == nil {
		var (
			sOut1  string
			sOut2  string
			errOut error
		)
		return sOut1, sOut2, errOut
	}
	return mock.PostMessageContextFunc(ctx, channelID, options...)
}

// PostMessageContextCalls gets all the calls that were made to PostMessageContext.
// Check the length with:
//
//	len(mockedSlackClient.PostMessageContextCalls())
func (mock *SlackClientMock) PostMessageContextCalls() []struct {
	Ctx       context.Context
	ChannelID string
	Options   []slackSDK.MsgOption
} {
	var calls []struct {
		Ctx       context.Context
		ChannelID string
		Options   []slackSDK.MsgOption
	}
	mock.lockPostMessageContext.RLock()
	calls = mock.calls.PostMessageContext
	mock.lockPostMessageContext.RUnlock()
	return calls
}

// SearchMessagesContext calls SearchMessagesContextFunc.
func (mock *SlackClientMock) SearchMessagesContext(ctx context.Context, query string, params slackSDK.SearchParameters) (*slackSDK.SearchMessages, error) {
	callInfo := struct {
		Ctx    context.Context
		Query  string
		Params slackSDK.SearchParameters
	}{
		Ctx:    ctx,
		Query:  query,
		Params: params,
	}
	mock.lockSearchMessagesContext.Lock()
	mock.calls.SearchMessagesContext = append(mock.calls.SearchMessagesContext, callInfo)
	mock.lockSearchMessagesContext.Unlock()
	if mock.SearchMessagesContextFunc == nil {
		var (
			searchMessagesOut *slackSDK.SearchMessages
			errOut            error
		)
		return searchMessagesOut, errOut
	}
	return mock.SearchMessagesContextFunc(ctx, query, params)
}

// SearchMessagesContextCalls gets all the calls that were made to SearchMessagesContext.
// Check the length with:
//
//	len(mockedSlackClient.SearchMessagesContextCalls())
func (mock *SlackClientMock) SearchMessagesContextCalls() []struct {
	Ctx    context.Context
	Query  string
	Params slackSDK.SearchParameters
} {
	var calls []struct {
		Ctx    context.Context
		Query  string
		Params slackSDK.SearchParameters
	}
	mock.lockSearchMessagesContext.RLock()
	calls = mock.calls.SearchMessagesContext
	mock.lockSearchMessagesContext.RUnlock()
	return calls
}

// UpdateMessageContext calls UpdateMessageContextFunc.
func (mock *SlackClientMock) UpdateMessageContext(ctx context.Context, channelID string, timestamp string, options ...slackSDK.MsgOption) (string, string, string, error) {
	callInfo := struct {
		Ctx       context.Context
		ChannelID string
		Timestamp string
		Options   []slackSDK.MsgOption
	}{
		Ctx:       ctx,
		ChannelID: channelID,
		Timestamp: timestamp,
		Options:   options,
	}
	mock.lockUpdateMessageContext.Lock()
	mock.calls.UpdateMessageContext = append(mock.calls.UpdateMessageContext, callInfo)
	mock.lockUpdateMessageContext.Unlock()
	if mock.UpdateMessageContextFunc == nil {
		var (
			sOut1  string
			sOut2  string
			sOut3  string
			errOut error
		)
		return sOut1, sOut2, sOut3, errOut
	}
	return mock.UpdateMessageContextFunc(ctx, channelID, timestamp, options...)
}

// UpdateMessageContextCalls gets all the calls that were made to UpdateMessageContext.
// Check the length with:
//
//	len(mockedSlackClient.UpdateMessageContextCalls())
func (mock *SlackClientMock) UpdateMessageContextCalls() []struct {
	Ctx       context.Context
	ChannelID string
	Timestamp string
	Options   []slackSDK.MsgOption
} {
	var calls []struct {
		Ctx       context.Context
		ChannelID string
		Timestamp string
		Options   []slackSDK.MsgOption
	}
	mock.lockUpdateMessageContext.RLock()
	calls = mock.calls.UpdateMessageContext
	mock.lockUpdateMessageContext.RUnlock()
	return calls
}

// UpdateView calls UpdateViewFunc.
func (mock *SlackClientMock) UpdateView(view slackSDK.ModalViewRequest, externalID string, hash string, viewID string) (*slackSDK.ViewResponse, error) {
	callInfo := struct {
		View       slackSDK.ModalViewRequest
		ExternalID string
		Hash       string
		ViewID     string
	}{
		View:       view,
		ExternalID: externalID,
		Hash:       hash,
		ViewID:     viewID,
	}
	mock.lockUpdateView.Lock()
	mock.calls.UpdateView = append(mock.calls.UpdateView, callInfo)
	mock.lockUpdateView.Unlock()
	if mock.UpdateViewFunc == nil {
		var (
			viewResponseOut *slackSDK.ViewResponse
			errOut          error
		)
		return viewResponseOut, errOut
	}
	return mock.UpdateViewFunc(view, externalID, hash, viewID)
}

// UpdateViewCalls gets all the calls that were made to UpdateView.
// Check the length with:
//
//	len(mockedSlackClient.UpdateViewCalls())
func (mock *SlackClientMock) UpdateViewCalls() []struct {
	View       slackSDK.ModalViewRequest
	ExternalID string
	Hash       string
	ViewID     string
} {
	var calls []struct {
		View       slackSDK.ModalViewRequest
		ExternalID string
		Hash       string
		ViewID     string
	}
	mock.lockUpdateView.RLock()
	calls = mock.calls.UpdateView
	mock.lockUpdateView.RUnlock()
	return calls
}

// UploadFileV2Context calls UploadFileV2ContextFunc.
func (mock *SlackClientMock) UploadFileV2Context(ctx context.Context, params slackSDK.UploadFileV2Parameters) (*slackSDK.FileSummary, error) {
	callInfo := struct {
		Ctx    context.Context
		Params slackSDK.UploadFileV2Parameters
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockUploadFileV2Context.Lock()
	mock.calls.UploadFileV2Context = append(mock.calls.UploadFileV2Context, callInfo)
	mock.lockUploadFileV2Context.Unlock()
	if mock.UploadFileV2ContextFunc == nil {
		var (
			fileSummaryOut *slackSDK.FileSummary
			errOut         error
		)
		return fileSummaryOut, errOut
	}
	return mock.UploadFileV2ContextFunc(ctx, params)
}

// UploadFileV2ContextCalls gets all the calls that were made to UploadFileV2Context.
// Check the length with:
//
//	len(mockedSlackClient.UploadFileV2ContextCalls())
func (mock *SlackClientMock) UploadFileV2ContextCalls() []struct {
	Ctx    context.Context
	Params slackSDK.UploadFileV2Parameters
} {
	var calls []struct {
		Ctx    context.Context
		Params slackSDK.UploadFileV2Parameters
	}
	mock.lockUploadFileV2Context.RLock()
	calls = mock.calls.UploadFileV2Context
	mock.lockUploadFileV2Context.RUnlock()
	return calls
}

// SlackThreadServiceMock is a mock implementation of interfaces.SlackThreadService.
//
//	func TestSomethingThatUsesSlackThreadService(t *testing.T) {
//
//		// make and configure a mocked interfaces.SlackThreadService
//		mockedSlackThreadService := &SlackThreadServiceMock{
//			AttachFileFunc: func(ctx context.Context, title string, fileName string, data []byte) error {
//				panic("mock out the AttachFile method")
//			},
//			ChannelIDFunc: func() string {
//				panic("mock out the ChannelID method")
//			},
//			EntityFunc: func() *slack.Thread {
//				panic("mock out the Entity method")
//			},
//			NewStateFuncFunc: func(ctx context.Context, message string) func(ctx context.Context, msg string) {
//				panic("mock out the NewStateFunc method")
//			},
//			NewTraceMessageFunc: func(ctx context.Context, initialMessage string) func(ctx context.Context, traceMsg string) {
//				panic("mock out the NewTraceMessage method")
//			},
//			NewUpdatableMessageFunc: func(ctx context.Context, initialMessage string) func(ctx context.Context, newMsg string) {
//				panic("mock out the NewUpdatableMessage method")
//			},
//			PostAlertFunc: func(ctx context.Context, alertMoqParam *alert.Alert) error {
//				panic("mock out the PostAlert method")
//			},
//			PostAlertListFunc: func(ctx context.Context, list *alert.List) (string, error) {
//				panic("mock out the PostAlertList method")
//			},
//			PostAlertListsFunc: func(ctx context.Context, clusters []*alert.List) error {
//				panic("mock out the PostAlertLists method")
//			},
//			PostAlertsFunc: func(ctx context.Context, alerts alert.Alerts) error {
//				panic("mock out the PostAlerts method")
//			},
//			PostCommentFunc: func(ctx context.Context, comment string) error {
//				panic("mock out the PostComment method")
//			},
//			PostCommentWithMessageIDFunc: func(ctx context.Context, comment string) (string, error) {
//				panic("mock out the PostCommentWithMessageID method")
//			},
//			PostContextBlockFunc: func(ctx context.Context, text string) error {
//				panic("mock out the PostContextBlock method")
//			},
//			PostFindingFunc: func(ctx context.Context, finding *ticket.Finding) error {
//				panic("mock out the PostFinding method")
//			},
//			PostLinkToTicketFunc: func(ctx context.Context, ticketURL string, ticketTitle string) error {
//				panic("mock out the PostLinkToTicket method")
//			},
//			PostTicketFunc: func(ctx context.Context, ticketMoqParam *ticket.Ticket, alerts alert.Alerts) (string, error) {
//				panic("mock out the PostTicket method")
//			},
//			PostTicketListFunc: func(ctx context.Context, tickets []*ticket.Ticket) error {
//				panic("mock out the PostTicketList method")
//			},
//			ReplyFunc: func(ctx context.Context, message string)  {
//				panic("mock out the Reply method")
//			},
//			ThreadIDFunc: func() string {
//				panic("mock out the ThreadID method")
//			},
//			UpdateAlertFunc: func(ctx context.Context, alertMoqParam alert.Alert) error {
//				panic("mock out the UpdateAlert method")
//			},
//			UpdateAlertListFunc: func(ctx context.Context, list *alert.List, status string) error {
//				panic("mock out the UpdateAlertList method")
//			},
//		}
//
//		// use mockedSlackThreadService in code that requires interfaces.SlackThreadService
//		// and then make assertions.
//
//	}
type SlackThreadServiceMock struct {
	// AttachFileFunc mocks the AttachFile method.
	AttachFileFunc func(ctx context.Context, title string, fileName string, data []byte) error

	// ChannelIDFunc mocks the ChannelID method.
	ChannelIDFunc func() string

	// EntityFunc mocks the Entity method.
	EntityFunc func() *slack.Thread

	// NewStateFuncFunc mocks the NewStateFunc method.
	NewStateFuncFunc func(ctx context.Context, message string) func(ctx context.Context, msg string)

	// NewTraceMessageFunc mocks the NewTraceMessage method.
	NewTraceMessageFunc func(ctx context.Context, initialMessage string) func(ctx context.Context, traceMsg string)

	// NewUpdatableMessageFunc mocks the NewUpdatableMessage method.
	NewUpdatableMessageFunc func(ctx context.Context, initialMessage string) func(ctx context.Context, newMsg string)

	// PostAlertFunc mocks the PostAlert method.
	PostAlertFunc func(ctx context.Context, alertMoqParam *alert.Alert) error

	// PostAlertListFunc mocks the PostAlertList method.
	PostAlertListFunc func(ctx context.Context, list *alert.List) (string, error)

	// PostAlertListsFunc mocks the PostAlertLists method.
	PostAlertListsFunc func(ctx context.Context, clusters []*alert.List) error

	// PostAlertsFunc mocks the PostAlerts method.
	PostAlertsFunc func(ctx context.Context, alerts alert.Alerts) error

	// PostCommentFunc mocks the PostComment method.
	PostCommentFunc func(ctx context.Context, comment string) error

	// PostCommentWithMessageIDFunc mocks the PostCommentWithMessageID method.
	PostCommentWithMessageIDFunc func(ctx context.Context, comment string) (string, error)

	// PostContextBlockFunc mocks the PostContextBlock method.
	PostContextBlockFunc func(ctx context.Context, text string) error

	// PostFindingFunc mocks the PostFinding method.
	PostFindingFunc func(ctx context.Context, finding *ticket.Finding) error

	// PostLinkToTicketFunc mocks the PostLinkToTicket method.
	PostLinkToTicketFunc func(ctx context.Context, ticketURL string, ticketTitle string) error

	// PostTicketFunc mocks the PostTicket method.
	PostTicketFunc func(ctx context.Context, ticketMoqParam *ticket.Ticket, alerts alert.Alerts) (string, error)

	// PostTicketListFunc mocks the PostTicketList method.
	PostTicketListFunc func(ctx context.Context, tickets []*ticket.Ticket) error

	// ReplyFunc mocks the Reply method.
	ReplyFunc func(ctx context.Context, message string)

	// ThreadIDFunc mocks the ThreadID method.
	ThreadIDFunc func() string

	// UpdateAlertFunc mocks the UpdateAlert method.
	UpdateAlertFunc func(ctx context.Context, alertMoqParam alert.Alert) error

	// UpdateAlertListFunc mocks the UpdateAlertList method.
	UpdateAlertListFunc func(ctx context.Context, list *alert.List, status string) error

	// calls tracks calls to the methods.
	calls struct {
		// AttachFile holds details about calls to the AttachFile method.
		AttachFile []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Title is the title argument value.
			Title string
			// FileName is the fileName argument value.
			FileName string
			// Data is the data argument value.
			Data []byte
		}
		// ChannelID holds details about calls to the ChannelID method.
		ChannelID []struct {
		}
		// Entity holds details about calls to the Entity method.
		Entity []struct {
		}
		// NewStateFunc holds details about calls to the NewStateFunc method.
		NewStateFunc []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Message is the message argument value.
			Message string
		}
		// NewTraceMessage holds details about calls to the NewTraceMessage method.
		NewTraceMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InitialMessage is the initialMessage argument value.
			InitialMessage string
		}
		// NewUpdatableMessage holds details about calls to the NewUpdatableMessage method.
		NewUpdatableMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InitialMessage is the initialMessage argument value.
			InitialMessage string
		}
		// PostAlert holds details about calls to the PostAlert method.
		PostAlert []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AlertMoqParam is the alertMoqParam argument value.
			AlertMoqParam *alert.Alert
		}
		// PostAlertList holds details about calls to the PostAlertList method.
		PostAlertList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// List is the list argument value.
			List *alert.List
		}
		// PostAlertLists holds details about calls to the PostAlertLists method.
		PostAlertLists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Clusters is the clusters argument value.
			Clusters []*alert.List
		}
		// PostAlerts holds details about calls to the PostAlerts method.
		PostAlerts []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Alerts is the alerts argument value.
			Alerts alert.Alerts
		}
		// PostComment holds details about calls to the PostComment method.
		PostComment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Comment is the comment argument value.
			Comment string
		}
		// PostCommentWithMessageID holds details about calls to the PostCommentWithMessageID method.
		PostCommentWithMessageID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Comment is the comment argument value.
			Comment string
		}
		// PostContextBlock holds details about calls to the PostContextBlock method.
		PostContextBlock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Text is the text argument value.
			Text string
		}
		// PostFinding holds details about calls to the PostFinding method.
		PostFinding []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Finding is the finding argument value.
			Finding *ticket.Finding
		}
		// PostLinkToTicket holds details about calls to the PostLinkToTicket method.
		PostLinkToTicket []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketURL is the ticketURL argument value.
			TicketURL string
			// TicketTitle is the ticketTitle argument value.
			TicketTitle string
		}
		// PostTicket holds details about calls to the PostTicket method.
		PostTicket []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketMoqParam is the ticketMoqParam argument value.
			TicketMoqParam *ticket.Ticket
			// Alerts is the alerts argument value.
			Alerts alert.Alerts
		}
		// PostTicketList holds details about calls to the PostTicketList method.
		PostTicketList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tickets is the tickets argument value.
			Tickets []*ticket.Ticket
		}
		// Reply holds details about calls to the Reply method.
		Reply []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Message is the message argument value.
			Message string
		}
		// ThreadID holds details about calls to the ThreadID method.
		ThreadID []struct {
		}
		// UpdateAlert holds details about calls to the UpdateAlert method.
		UpdateAlert []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AlertMoqParam is the alertMoqParam argument value.
			AlertMoqParam alert.Alert
		}
		// UpdateAlertList holds details about calls to the UpdateAlertList method.
		UpdateAlertList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// List is the list argument value.
			List *alert.List
			// Status is the status argument value.
			Status string
		}
	}
	lockAttachFile               sync.RWMutex
	lockChannelID                sync.RWMutex
	lockEntity                   sync.RWMutex
	lockNewStateFunc             sync.RWMutex
	lockNewTraceMessage          sync.RWMutex
	lockNewUpdatableMessage      sync.RWMutex
	lockPostAlert                sync.RWMutex
	lockPostAlertList            sync.RWMutex
	lockPostAlertLists           sync.RWMutex
	lockPostAlerts               sync.RWMutex
	lockPostComment              sync.RWMutex
	lockPostCommentWithMessageID sync.RWMutex
	lockPostContextBlock         sync.RWMutex
	lockPostFinding              sync.RWMutex
	lockPostLinkToTicket         sync.RWMutex
	lockPostTicket               sync.RWMutex
	lockPostTicketList           sync.RWMutex
	lockReply                    sync.RWMutex
	lockThreadID                 sync.RWMutex
	lockUpdateAlert              sync.RWMutex
	lockUpdateAlertList          sync.RWMutex
}

// AttachFile calls AttachFileFunc.
func (mock *SlackThreadServiceMock) AttachFile(ctx context.Context, title string, fileName string, data []byte) error {
	callInfo := struct {
		Ctx      context.Context
		Title    string
		FileName string
		Data     []byte
	}{
		Ctx:      ctx,
		Title:    title,
		FileName: fileName,
		Data:     data,
	}
	mock.lockAttachFile.Lock()
	mock.calls.AttachFile = append(mock.calls.AttachFile, callInfo)
	mock.lockAttachFile.Unlock()
	if mock.AttachFileFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.AttachFileFunc(ctx, title, fileName, data)
}

// AttachFileCalls gets all the calls that were made to AttachFile.
// Check the length with:
//
//	len(mockedSlackThreadService.AttachFileCalls())
func (mock *SlackThreadServiceMock) AttachFileCalls() []struct {
	Ctx      context.Context
	Title    string
	FileName string
	Data     []byte
} {
	var calls []struct {
		Ctx      context.Context
		Title    string
		FileName string
		Data     []byte
	}
	mock.lockAttachFile.RLock()
	calls = mock.calls.AttachFile
	mock.lockAttachFile.RUnlock()
	return calls
}

// ChannelID calls ChannelIDFunc.
func (mock *SlackThreadServiceMock) ChannelID() string {
	callInfo := struct {
	}{}
	mock.lockChannelID.Lock()
	mock.calls.ChannelID = append(mock.calls.ChannelID, callInfo)
	mock.lockChannelID.Unlock()
	if mock.ChannelIDFunc == nil {
		var (
			sOut string
		)
		return sOut
	}
	return mock.ChannelIDFunc()
}

// ChannelIDCalls gets all the calls that were made to ChannelID.
// Check the length with:
//
//	len(mockedSlackThreadService.ChannelIDCalls())
func (mock *SlackThreadServiceMock) ChannelIDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockChannelID.RLock()
	calls = mock.calls.ChannelID
	mock.lockChannelID.RUnlock()
	return calls
}

// Entity calls EntityFunc.
func (mock *SlackThreadServiceMock) Entity() *slack.Thread {
	callInfo := struct {
	}{}
	mock.lockEntity.Lock()
	mock.calls.Entity = append(mock.calls.Entity, callInfo)
	mock.lockEntity.Unlock()
	if mock.EntityFunc == nil {
		var (
			threadOut *slack.Thread
		)
		return threadOut
	}
	return mock.EntityFunc()
}

// EntityCalls gets all the calls that were made to Entity.
// Check the length with:
//
//	len(mockedSlackThreadService.EntityCalls())
func (mock *SlackThreadServiceMock) EntityCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockEntity.RLock()
	calls = mock.calls.Entity
	mock.lockEntity.RUnlock()
	return calls
}

// NewStateFunc calls NewStateFuncFunc.
func (mock *SlackThreadServiceMock) NewStateFunc(ctx context.Context, message string) func(ctx context.Context, msg string) {
	callInfo := struct {
		Ctx     context.Context
		Message string
	}{
		Ctx:     ctx,
		Message: message,
	}
	mock.lockNewStateFunc.Lock()
	mock.calls.NewStateFunc = append(mock.calls.NewStateFunc, callInfo)
	mock.lockNewStateFunc.Unlock()
	if mock.NewStateFuncFunc == nil {
		var (
			fnOut func(ctx context.Context, msg string)
		)
		return fnOut
	}
	return mock.NewStateFuncFunc(ctx, message)
}

// NewStateFuncCalls gets all the calls that were made to NewStateFunc.
// Check the length with:
//
//	len(mockedSlackThreadService.NewStateFuncCalls())
func (mock *SlackThreadServiceMock) NewStateFuncCalls() []struct {
	Ctx     context.Context
	Message string
} {
	var calls []struct {
		Ctx     context.Context
		Message string
	}
	mock.lockNewStateFunc.RLock()
	calls = mock.calls.NewStateFunc
	mock.lockNewStateFunc.RUnlock()
	return calls
}

// NewTraceMessage calls NewTraceMessageFunc.
func (mock *SlackThreadServiceMock) NewTraceMessage(ctx context.Context, initialMessage string) func(ctx context.Context, traceMsg string) {
	callInfo := struct {
		Ctx            context.Context
		InitialMessage string
	}{
		Ctx:            ctx,
		InitialMessage: initialMessage,
	}
	mock.lockNewTraceMessage.Lock()
	mock.calls.NewTraceMessage = append(mock.calls.NewTraceMessage, callInfo)
	mock.lockNewTraceMessage.Unlock()
	if mock.NewTraceMessageFunc == nil {
		var (
			fnOut func(ctx context.Context, traceMsg string)
		)
		return fnOut
	}
	return mock.NewTraceMessageFunc(ctx, initialMessage)
}

// NewTraceMessageCalls gets all the calls that were made to NewTraceMessage.
// Check the length with:
//
//	len(mockedSlackThreadService.NewTraceMessageCalls())
func (mock *SlackThreadServiceMock) NewTraceMessageCalls() []struct {
	Ctx            context.Context
	InitialMessage string
} {
	var calls []struct {
		Ctx            context.Context
		InitialMessage string
	}
	mock.lockNewTraceMessage.RLock()
	calls = mock.calls.NewTraceMessage
	mock.lockNewTraceMessage.RUnlock()
	return calls
}

// NewUpdatableMessage calls NewUpdatableMessageFunc.
func (mock *SlackThreadServiceMock) NewUpdatableMessage(ctx context.Context, initialMessage string) func(ctx context.Context, newMsg string) {
	callInfo := struct {
		Ctx            context.Context
		InitialMessage string
	}{
		Ctx:            ctx,
		InitialMessage: initialMessage,
	}
	mock.lockNewUpdatableMessage.Lock()
	mock.calls.NewUpdatableMessage = append(mock.calls.NewUpdatableMessage, callInfo)
	mock.lockNewUpdatableMessage.Unlock()
	if mock.NewUpdatableMessageFunc == nil {
		var (
			fnOut func(ctx context.Context, newMsg string)
		)
		return fnOut
	}
	return mock.NewUpdatableMessageFunc(ctx, initialMessage)
}

// NewUpdatableMessageCalls gets all the calls that were made to NewUpdatableMessage.
// Check the length with:
//
//	len(mockedSlackThreadService.NewUpdatableMessageCalls())
func (mock *SlackThreadServiceMock) NewUpdatableMessageCalls() []struct {
	Ctx            context.Context
	InitialMessage string
} {
	var calls []struct {
		Ctx            context.Context
		InitialMessage string
	}
	mock.lockNewUpdatableMessage.RLock()
	calls = mock.calls.NewUpdatableMessage
	mock.lockNewUpdatableMessage.RUnlock()
	return calls
}

// PostAlert calls PostAlertFunc.
func (mock *SlackThreadServiceMock) PostAlert(ctx context.Context, alertMoqParam *alert.Alert) error {
	callInfo := struct {
		Ctx           context.Context
		AlertMoqParam *alert.Alert
	}{
		Ctx:           ctx,
		AlertMoqParam: alertMoqParam,
	}
	mock.lockPostAlert.Lock()
	mock.calls.PostAlert = append(mock.calls.PostAlert, callInfo)
	mock.lockPostAlert.Unlock()
	if mock.PostAlertFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PostAlertFunc(ctx, alertMoqParam)
}

// PostAlertCalls gets all the calls that were made to PostAlert.
// Check the length with:
//
//	len(mockedSlackThreadService.PostAlertCalls())
func (mock *SlackThreadServiceMock) PostAlertCalls() []struct {
	Ctx           context.Context
	AlertMoqParam *alert.Alert
} {
	var calls []struct {
		Ctx           context.Context
		AlertMoqParam *alert.Alert
	}
	mock.lockPostAlert.RLock()
	calls = mock.calls.PostAlert
	mock.lockPostAlert.RUnlock()
	return calls
}

// PostAlertList calls PostAlertListFunc.
func (mock *SlackThreadServiceMock) PostAlertList(ctx context.Context, list *alert.List) (string, error) {
	callInfo := struct {
		Ctx  context.Context
		List *alert.List
	}{
		Ctx:  ctx,
		List: list,
	}
	mock.lockPostAlertList.Lock()
	mock.calls.PostAlertList = append(mock.calls.PostAlertList, callInfo)
	mock.lockPostAlertList.Unlock()
	if mock.PostAlertListFunc == nil {
		var (
			sOut   string
			errOut error
		)
		return sOut, errOut
	}
	return mock.PostAlertListFunc(ctx, list)
}

// PostAlertListCalls gets all the calls that were made to PostAlertList.
// Check the length with:
//
//	len(mockedSlackThreadService.PostAlertListCalls())
func (mock *SlackThreadServiceMock) PostAlertListCalls() []struct {
	Ctx  context.Context
	List *alert.List
} {
	var calls []struct {
		Ctx  context.Context
		List *alert.List
	}
	mock.lockPostAlertList.RLock()
	calls = mock.calls.PostAlertList
	mock.lockPostAlertList.RUnlock()
	return calls
}

// PostAlertLists calls PostAlertListsFunc.
func (mock *SlackThreadServiceMock) PostAlertLists(ctx context.Context, clusters []*alert.List) error {
	callInfo := struct {
		Ctx      context.Context
		Clusters []*alert.List
	}{
		Ctx:      ctx,
		Clusters: clusters,
	}
	mock.lockPostAlertLists.Lock()
	mock.calls.PostAlertLists = append(mock.calls.PostAlertLists, callInfo)
	mock.lockPostAlertLists.Unlock()
	if mock.PostAlertListsFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PostAlertListsFunc(ctx, clusters)
}

// PostAlertListsCalls gets all the calls that were made to PostAlertLists.
// Check the length with:
//
//	len(mockedSlackThreadService.PostAlertListsCalls())
func (mock *SlackThreadServiceMock) PostAlertListsCalls() []struct {
	Ctx      context.Context
	Clusters []*alert.List
} {
	var calls []struct {
		Ctx      context.Context
		Clusters []*alert.List
	}
	mock.lockPostAlertLists.RLock()
	calls = mock.calls.PostAlertLists
	mock.lockPostAlertLists.RUnlock()
	return calls
}

// PostAlerts calls PostAlertsFunc.
func (mock *SlackThreadServiceMock) PostAlerts(ctx context.Context, alerts alert.Alerts) error {
	callInfo := struct {
		Ctx    context.Context
		Alerts alert.Alerts
	}{
		Ctx:    ctx,
		Alerts: alerts,
	}
	mock.lockPostAlerts.Lock()
	mock.calls.PostAlerts = append(mock.calls.PostAlerts, callInfo)
	mock.lockPostAlerts.Unlock()
	if mock.PostAlertsFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PostAlertsFunc(ctx, alerts)
}

// PostAlertsCalls gets all the calls that were made to PostAlerts.
// Check the length with:
//
//	len(mockedSlackThreadService.PostAlertsCalls())
func (mock *SlackThreadServiceMock) PostAlertsCalls() []struct {
	Ctx    context.Context
	Alerts alert.Alerts
} {
	var calls []struct {
		Ctx    context.Context
		Alerts alert.Alerts
	}
	mock.lockPostAlerts.RLock()
	calls = mock.calls.PostAlerts
	mock.lockPostAlerts.RUnlock()
	return calls
}

// PostComment calls PostCommentFunc.
func (mock *SlackThreadServiceMock) PostComment(ctx context.Context, comment string) error {
	callInfo := struct {
		Ctx     context.Context
		Comment string
	}{
		Ctx:     ctx,
		Comment: comment,
	}
	mock.lockPostComment.Lock()
	mock.calls.PostComment = append(mock.calls.PostComment, callInfo)
	mock.lockPostComment.Unlock()
	if mock.PostCommentFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PostCommentFunc(ctx, comment)
}

// PostCommentCalls gets all the calls that were made to PostComment.
// Check the length with:
//
//	len(mockedSlackThreadService.PostCommentCalls())
func (mock *SlackThreadServiceMock) PostCommentCalls() []struct {
	Ctx     context.Context
	Comment string
} {
	var calls []struct {
		Ctx     context.Context
		Comment string
	}
	mock.lockPostComment.RLock()
	calls = mock.calls.PostComment
	mock.lockPostComment.RUnlock()
	return calls
}

// PostCommentWithMessageID calls PostCommentWithMessageIDFunc.
func (mock *SlackThreadServiceMock) PostCommentWithMessageID(ctx context.Context, comment string) (string, error) {
	callInfo := struct {
		Ctx     context.Context
		Comment string
	}{
		Ctx:     ctx,
		Comment: comment,
	}
	mock.lockPostCommentWithMessageID.Lock()
	mock.calls.PostCommentWithMessageID = append(mock.calls.PostCommentWithMessageID, callInfo)
	mock.lockPostCommentWithMessageID.Unlock()
	if mock.PostCommentWithMessageIDFunc == nil {
		var (
			sOut   string
			errOut error
		)
		return sOut, errOut
	}
	return mock.PostCommentWithMessageIDFunc(ctx, comment)
}

// PostCommentWithMessageIDCalls gets all the calls that were made to PostCommentWithMessageID.
// Check the length with:
//
//	len(mockedSlackThreadService.PostCommentWithMessageIDCalls())
func (mock *SlackThreadServiceMock) PostCommentWithMessageIDCalls() []struct {
	Ctx     context.Context
	Comment string
} {
	var calls []struct {
		Ctx     context.Context
		Comment string
	}
	mock.lockPostCommentWithMessageID.RLock()
	calls = mock.calls.PostCommentWithMessageID
	mock.lockPostCommentWithMessageID.RUnlock()
	return calls
}

// PostContextBlock calls PostContextBlockFunc.
func (mock *SlackThreadServiceMock) PostContextBlock(ctx context.Context, text string) error {
	callInfo := struct {
		Ctx  context.Context
		Text string
	}{
		Ctx:  ctx,
		Text: text,
	}
	mock.lockPostContextBlock.Lock()
	mock.calls.PostContextBlock = append(mock.calls.PostContextBlock, callInfo)
	mock.lockPostContextBlock.Unlock()
	if mock.PostContextBlockFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PostContextBlockFunc(ctx, text)
}

// PostContextBlockCalls gets all the calls that were made to PostContextBlock.
// Check the length with:
//
//	len(mockedSlackThreadService.PostContextBlockCalls())
func (mock *SlackThreadServiceMock) PostContextBlockCalls() []struct {
	Ctx  context.Context
	Text string
} {
	var calls []struct {
		Ctx  context.Context
		Text string
	}
	mock.lockPostContextBlock.RLock()
	calls = mock.calls.PostContextBlock
	mock.lockPostContextBlock.RUnlock()
	return calls
}

// PostFinding calls PostFindingFunc.
func (mock *SlackThreadServiceMock) PostFinding(ctx context.Context, finding *ticket.Finding) error {
	callInfo := struct {
		Ctx     context.Context
		Finding *ticket.Finding
	}{
		Ctx:     ctx,
		Finding: finding,
	}
	mock.lockPostFinding.Lock()
	mock.calls.PostFinding = append(mock.calls.PostFinding, callInfo)
	mock.lockPostFinding.Unlock()
	if mock.PostFindingFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PostFindingFunc(ctx, finding)
}

// PostFindingCalls gets all the calls that were made to PostFinding.
// Check the length with:
//
//	len(mockedSlackThreadService.PostFindingCalls())
func (mock *SlackThreadServiceMock) PostFindingCalls() []struct {
	Ctx     context.Context
	Finding *ticket.Finding
} {
	var calls []struct {
		Ctx     context.Context
		Finding *ticket.Finding
	}
	mock.lockPostFinding.RLock()
	calls = mock.calls.PostFinding
	mock.lockPostFinding.RUnlock()
	return calls
}

// PostLinkToTicket calls PostLinkToTicketFunc.
func (mock *SlackThreadServiceMock) PostLinkToTicket(ctx context.Context, ticketURL string, ticketTitle string) error {
	callInfo := struct {
		Ctx         context.Context
		TicketURL   string
		TicketTitle string
	}{
		Ctx:         ctx,
		TicketURL:   ticketURL,
		TicketTitle: ticketTitle,
	}
	mock.lockPostLinkToTicket.Lock()
	mock.calls.PostLinkToTicket = append(mock.calls.PostLinkToTicket, callInfo)
	mock.lockPostLinkToTicket.Unlock()
	if mock.PostLinkToTicketFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PostLinkToTicketFunc(ctx, ticketURL, ticketTitle)
}

// PostLinkToTicketCalls gets all the calls that were made to PostLinkToTicket.
// Check the length with:
//
//	len(mockedSlackThreadService.PostLinkToTicketCalls())
func (mock *SlackThreadServiceMock) PostLinkToTicketCalls() []struct {
	Ctx         context.Context
	TicketURL   string
	TicketTitle string
} {
	var calls []struct {
		Ctx         context.Context
		TicketURL   string
		TicketTitle string
	}
	mock.lockPostLinkToTicket.RLock()
	calls = mock.calls.PostLinkToTicket
	mock.lockPostLinkToTicket.RUnlock()
	return calls
}

// PostTicket calls PostTicketFunc.
func (mock *SlackThreadServiceMock) PostTicket(ctx context.Context, ticketMoqParam *ticket.Ticket, alerts alert.Alerts) (string, error) {
	callInfo := struct {
		Ctx            context.Context
		TicketMoqParam *ticket.Ticket
		Alerts         alert.Alerts
	}{
		Ctx:            ctx,
		TicketMoqParam: ticketMoqParam,
		Alerts:         alerts,
	}
	mock.lockPostTicket.Lock()
	mock.calls.PostTicket = append(mock.calls.PostTicket, callInfo)
	mock.lockPostTicket.Unlock()
	if mock.PostTicketFunc == nil {
		var (
			sOut   string
			errOut error
		)
		return sOut, errOut
	}
	return mock.PostTicketFunc(ctx, ticketMoqParam, alerts)
}

// PostTicketCalls gets all the calls that were made to PostTicket.
// Check the length with:
//
//	len(mockedSlackThreadService.PostTicketCalls())
func (mock *SlackThreadServiceMock) PostTicketCalls() []struct {
	Ctx            context.Context
	TicketMoqParam *ticket.Ticket
	Alerts         alert.Alerts
} {
	var calls []struct {
		Ctx            context.Context
		TicketMoqParam *ticket.Ticket
		Alerts         alert.Alerts
	}
	mock.lockPostTicket.RLock()
	calls = mock.calls.PostTicket
	mock.lockPostTicket.RUnlock()
	return calls
}

// PostTicketList calls PostTicketListFunc.
func (mock *SlackThreadServiceMock) PostTicketList(ctx context.Context, tickets []*ticket.Ticket) error {
	callInfo := struct {
		Ctx     context.Context
		Tickets []*ticket.Ticket
	}{
		Ctx:     ctx,
		Tickets: tickets,
	}
	mock.lockPostTicketList.Lock()
	mock.calls.PostTicketList = append(mock.calls.PostTicketList, callInfo)
	mock.lockPostTicketList.Unlock()
	if mock.PostTicketListFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PostTicketListFunc(ctx, tickets)
}

// PostTicketListCalls gets all the calls that were made to PostTicketList.
// Check the length with:
//
//	len(mockedSlackThreadService.PostTicketListCalls())
func (mock *SlackThreadServiceMock) PostTicketListCalls() []struct {
	Ctx     context.Context
	Tickets []*ticket.Ticket
} {
	var calls []struct {
		Ctx     context.Context
		Tickets []*ticket.Ticket
	}
	mock.lockPostTicketList.RLock()
	calls = mock.calls.PostTicketList
	mock.lockPostTicketList.RUnlock()
	return calls
}

// Reply calls ReplyFunc.
func (mock *SlackThreadServiceMock) Reply(ctx context.Context, message string) {
	callInfo := struct {
		Ctx     context.Context
		Message string
	}{
		Ctx:     ctx,
		Message: message,
	}
	mock.lockReply.Lock()
	mock.calls.Reply = append(mock.calls.Reply, callInfo)
	mock.lockReply.Unlock()
	if mock.ReplyFunc == nil {
		return
	}
	mock.ReplyFunc(ctx, message)
}

// ReplyCalls gets all the calls that were made to Reply.
// Check the length with:
//
//	len(mockedSlackThreadService.ReplyCalls())
func (mock *SlackThreadServiceMock) ReplyCalls() []struct {
	Ctx     context.Context
	Message string
} {
	var calls []struct {
		Ctx     context.Context
		Message string
	}
	mock.lockReply.RLock()
	calls = mock.calls.Reply
	mock.lockReply.RUnlock()
	return calls
}

// ThreadID calls ThreadIDFunc.
func (mock *SlackThreadServiceMock) ThreadID() string {
	callInfo := struct {
	}{}
	mock.lockThreadID.Lock()
	mock.calls.ThreadID = append(mock.calls.ThreadID, callInfo)
	mock.lockThreadID.Unlock()
	if mock.ThreadIDFunc == nil {
		var (
			sOut string
		)
		return sOut
	}
	return mock.ThreadIDFunc()
}

// ThreadIDCalls gets all the calls that were made to ThreadID.
// Check the length with:
//
//	len(mockedSlackThreadService.ThreadIDCalls())
func (mock *SlackThreadServiceMock) ThreadIDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockThreadID.RLock()
	calls = mock.calls.ThreadID
	mock.lockThreadID.RUnlock()
	return calls
}

// UpdateAlert calls UpdateAlertFunc.
func (mock *SlackThreadServiceMock) UpdateAlert(ctx context.Context, alertMoqParam alert.Alert) error {
	callInfo := struct {
		Ctx           context.Context
		AlertMoqParam alert.Alert
	}{
		Ctx:           ctx,
		AlertMoqParam: alertMoqParam,
	}
	mock.lockUpdateAlert.Lock()
	mock.calls.UpdateAlert = append(mock.calls.UpdateAlert, callInfo)
	mock.lockUpdateAlert.Unlock()
	if mock.UpdateAlertFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.UpdateAlertFunc(ctx, alertMoqParam)
}

// UpdateAlertCalls gets all the calls that were made to UpdateAlert.
// Check the length with:
//
//	len(mockedSlackThreadService.UpdateAlertCalls())
func (mock *SlackThreadServiceMock) UpdateAlertCalls() []struct {
	Ctx           context.Context
	AlertMoqParam alert.Alert
} {
	var calls []struct {
		Ctx           context.Context
		AlertMoqParam alert.Alert
	}
	mock.lockUpdateAlert.RLock()
	calls = mock.calls.UpdateAlert
	mock.lockUpdateAlert.RUnlock()
	return calls
}

// UpdateAlertList calls UpdateAlertListFunc.
func (mock *SlackThreadServiceMock) UpdateAlertList(ctx context.Context, list *alert.List, status string) error {
	callInfo := struct {
		Ctx    context.Context
		List   *alert.List
		Status string
	}{
		Ctx:    ctx,
		List:   list,
		Status: status,
	}
	mock.lockUpdateAlertList.Lock()
	mock.calls.UpdateAlertList = append(mock.calls.UpdateAlertList, callInfo)
	mock.lockUpdateAlertList.Unlock()
	if mock.UpdateAlertListFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.UpdateAlertListFunc(ctx, list, status)
}

// UpdateAlertListCalls gets all the calls that were made to UpdateAlertList.
// Check the length with:
//
//	len(mockedSlackThreadService.UpdateAlertListCalls())
func (mock *SlackThreadServiceMock) UpdateAlertListCalls() []struct {
	Ctx    context.Context
	List   *alert.List
	Status string
} {
	var calls []struct {
		Ctx    context.Context
		List   *alert.List
		Status string
	}
	mock.lockUpdateAlertList.RLock()
	calls = mock.calls.UpdateAlertList
	mock.lockUpdateAlertList.RUnlock()
	return calls
}

// ChatNotifierMock is a mock implementation of interfaces.ChatNotifier.
//
//	func TestSomethingThatUsesChatNotifier(t *testing.T) {
//
//		// make and configure a mocked interfaces.ChatNotifier
//		mockedChatNotifier := &ChatNotifierMock{
//			NotifyMessageFunc: func(ctx context.Context, ticketID types.TicketID, message string) error {
//				panic("mock out the NotifyMessage method")
//			},
//			NotifyTraceFunc: func(ctx context.Context, ticketID types.TicketID, message string) error {
//				panic("mock out the NotifyTrace method")
//			},
//		}
//
//		// use mockedChatNotifier in code that requires interfaces.ChatNotifier
//		// and then make assertions.
//
//	}
type ChatNotifierMock struct {
	// NotifyMessageFunc mocks the NotifyMessage method.
	NotifyMessageFunc func(ctx context.Context, ticketID types.TicketID, message string) error

	// NotifyTraceFunc mocks the NotifyTrace method.
	NotifyTraceFunc func(ctx context.Context, ticketID types.TicketID, message string) error

	// calls tracks calls to the methods.
	calls struct {
		// NotifyMessage holds details about calls to the NotifyMessage method.
		NotifyMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketID is the ticketID argument value.
			TicketID types.TicketID
			// Message is the message argument value.
			Message string
		}
		// NotifyTrace holds details about calls to the NotifyTrace method.
		NotifyTrace []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketID is the ticketID argument value.
			TicketID types.TicketID
			// Message is the message argument value.
			Message string
		}
	}
	lockNotifyMessage sync.RWMutex
	lockNotifyTrace   sync.RWMutex
}

// NotifyMessage calls NotifyMessageFunc.
func (mock *ChatNotifierMock) NotifyMessage(ctx context.Context, ticketID types.TicketID, message string) error {
	callInfo := struct {
		Ctx      context.Context
		TicketID types.TicketID
		Message  string
	}{
		Ctx:      ctx,
		TicketID: ticketID,
		Message:  message,
	}
	mock.lockNotifyMessage.Lock()
	mock.calls.NotifyMessage = append(mock.calls.NotifyMessage, callInfo)
	mock.lockNotifyMessage.Unlock()
	if mock.NotifyMessageFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.NotifyMessageFunc(ctx, ticketID, message)
}

// NotifyMessageCalls gets all the calls that were made to NotifyMessage.
// Check the length with:
//
//	len(mockedChatNotifier.NotifyMessageCalls())
func (mock *ChatNotifierMock) NotifyMessageCalls() []struct {
	Ctx      context.Context
	TicketID types.TicketID
	Message  string
} {
	var calls []struct {
		Ctx      context.Context
		TicketID types.TicketID
		Message  string
	}
	mock.lockNotifyMessage.RLock()
	calls = mock.calls.NotifyMessage
	mock.lockNotifyMessage.RUnlock()
	return calls
}

// NotifyTrace calls NotifyTraceFunc.
func (mock *ChatNotifierMock) NotifyTrace(ctx context.Context, ticketID types.TicketID, message string) error {
	callInfo := struct {
		Ctx      context.Context
		TicketID types.TicketID
		Message  string
	}{
		Ctx:      ctx,
		TicketID: ticketID,
		Message:  message,
	}
	mock.lockNotifyTrace.Lock()
	mock.calls.NotifyTrace = append(mock.calls.NotifyTrace, callInfo)
	mock.lockNotifyTrace.Unlock()
	if mock.NotifyTraceFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.NotifyTraceFunc(ctx, ticketID, message)
}

// NotifyTraceCalls gets all the calls that were made to NotifyTrace.
// Check the length with:
//
//	len(mockedChatNotifier.NotifyTraceCalls())
func (mock *ChatNotifierMock) NotifyTraceCalls() []struct {
	Ctx      context.Context
	TicketID types.TicketID
	Message  string
} {
	var calls []struct {
		Ctx      context.Context
		TicketID types.TicketID
		Message  string
	}
	mock.lockNotifyTrace.RLock()
	calls = mock.calls.NotifyTrace
	mock.lockNotifyTrace.RUnlock()
	return calls
}

// NotifierMock is a mock implementation of interfaces.Notifier.
//
//	func TestSomethingThatUsesNotifier(t *testing.T) {
//
//		// make and configure a mocked interfaces.Notifier
//		mockedNotifier := &NotifierMock{
//			NotifyEnrichPolicyResultFunc: func(ctx context.Context, ev *event.EnrichPolicyResultEvent)  {
//				panic("mock out the NotifyEnrichPolicyResult method")
//			},
//			NotifyEnrichTaskPromptFunc: func(ctx context.Context, ev *event.EnrichTaskPromptEvent)  {
//				panic("mock out the NotifyEnrichTaskPrompt method")
//			},
//			NotifyEnrichTaskResponseFunc: func(ctx context.Context, ev *event.EnrichTaskResponseEvent)  {
//				panic("mock out the NotifyEnrichTaskResponse method")
//			},
//			NotifyErrorFunc: func(ctx context.Context, ev *event.ErrorEvent)  {
//				panic("mock out the NotifyError method")
//			},
//			NotifyIngestPolicyResultFunc: func(ctx context.Context, ev *event.IngestPolicyResultEvent)  {
//				panic("mock out the NotifyIngestPolicyResult method")
//			},
//			NotifyTriagePolicyResultFunc: func(ctx context.Context, ev *event.TriagePolicyResultEvent)  {
//				panic("mock out the NotifyTriagePolicyResult method")
//			},
//		}
//
//		// use mockedNotifier in code that requires interfaces.Notifier
//		// and then make assertions.
//
//	}
type NotifierMock struct {
	// NotifyEnrichPolicyResultFunc mocks the NotifyEnrichPolicyResult method.
	NotifyEnrichPolicyResultFunc func(ctx context.Context, ev *event.EnrichPolicyResultEvent)

	// NotifyEnrichTaskPromptFunc mocks the NotifyEnrichTaskPrompt method.
	NotifyEnrichTaskPromptFunc func(ctx context.Context, ev *event.EnrichTaskPromptEvent)

	// NotifyEnrichTaskResponseFunc mocks the NotifyEnrichTaskResponse method.
	NotifyEnrichTaskResponseFunc func(ctx context.Context, ev *event.EnrichTaskResponseEvent)

	// NotifyErrorFunc mocks the NotifyError method.
	NotifyErrorFunc func(ctx context.Context, ev *event.ErrorEvent)

	// NotifyIngestPolicyResultFunc mocks the NotifyIngestPolicyResult method.
	NotifyIngestPolicyResultFunc func(ctx context.Context, ev *event.IngestPolicyResultEvent)

	// NotifyTriagePolicyResultFunc mocks the NotifyTriagePolicyResult method.
	NotifyTriagePolicyResultFunc func(ctx context.Context, ev *event.TriagePolicyResultEvent)

	// calls tracks calls to the methods.
	calls struct {
		// NotifyEnrichPolicyResult holds details about calls to the NotifyEnrichPolicyResult method.
		NotifyEnrichPolicyResult []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ev is the ev argument value.
			Ev *event.EnrichPolicyResultEvent
		}
		// NotifyEnrichTaskPrompt holds details about calls to the NotifyEnrichTaskPrompt method.
		NotifyEnrichTaskPrompt []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ev is the ev argument value.
			Ev *event.EnrichTaskPromptEvent
		}
		// NotifyEnrichTaskResponse holds details about calls to the NotifyEnrichTaskResponse method.
		NotifyEnrichTaskResponse []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ev is the ev argument value.
			Ev *event.EnrichTaskResponseEvent
		}
		// NotifyError holds details about calls to the NotifyError method.
		NotifyError []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ev is the ev argument value.
			Ev *event.ErrorEvent
		}
		// NotifyIngestPolicyResult holds details about calls to the NotifyIngestPolicyResult method.
		NotifyIngestPolicyResult []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ev is the ev argument value.
			Ev *event.IngestPolicyResultEvent
		}
		// NotifyTriagePolicyResult holds details about calls to the NotifyTriagePolicyResult method.
		NotifyTriagePolicyResult []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ev is the ev argument value.
			Ev *event.TriagePolicyResultEvent
		}
	}
	lockNotifyEnrichPolicyResult sync.RWMutex
	lockNotifyEnrichTaskPrompt   sync.RWMutex
	lockNotifyEnrichTaskResponse sync.RWMutex
	lockNotifyError              sync.RWMutex
	lockNotifyIngestPolicyResult sync.RWMutex
	lockNotifyTriagePolicyResult sync.RWMutex
}

// NotifyEnrichPolicyResult calls NotifyEnrichPolicyResultFunc.
func (mock *NotifierMock) NotifyEnrichPolicyResult(ctx context.Context, ev *event.EnrichPolicyResultEvent) {
	callInfo := struct {
		Ctx context.Context
		Ev  *event.EnrichPolicyResultEvent
	}{
		Ctx: ctx,
		Ev:  ev,
	}
	mock.lockNotifyEnrichPolicyResult.Lock()
	mock.calls.NotifyEnrichPolicyResult = append(mock.calls.NotifyEnrichPolicyResult, callInfo)
	mock.lockNotifyEnrichPolicyResult.Unlock()
	if mock.NotifyEnrichPolicyResultFunc == nil {
		return
	}
	mock.NotifyEnrichPolicyResultFunc(ctx, ev)
}

// NotifyEnrichPolicyResultCalls gets all the calls that were made to NotifyEnrichPolicyResult.
// Check the length with:
//
//	len(mockedNotifier.NotifyEnrichPolicyResultCalls())
func (mock *NotifierMock) NotifyEnrichPolicyResultCalls() []struct {
	Ctx context.Context
	Ev  *event.EnrichPolicyResultEvent
} {
	var calls []struct {
		Ctx context.Context
		Ev  *event.EnrichPolicyResultEvent
	}
	mock.lockNotifyEnrichPolicyResult.RLock()
	calls = mock.calls.NotifyEnrichPolicyResult
	mock.lockNotifyEnrichPolicyResult.RUnlock()
	return calls
}

// NotifyEnrichTaskPrompt calls NotifyEnrichTaskPromptFunc.
func (mock *NotifierMock) NotifyEnrichTaskPrompt(ctx context.Context, ev *event.EnrichTaskPromptEvent) {
	callInfo := struct {
		Ctx context.Context
		Ev  *event.EnrichTaskPromptEvent
	}{
		Ctx: ctx,
		Ev:  ev,
	}
	mock.lockNotifyEnrichTaskPrompt.Lock()
	mock.calls.NotifyEnrichTaskPrompt = append(mock.calls.NotifyEnrichTaskPrompt, callInfo)
	mock.lockNotifyEnrichTaskPrompt.Unlock()
	if mock.NotifyEnrichTaskPromptFunc == nil {
		return
	}
	mock.NotifyEnrichTaskPromptFunc(ctx, ev)
}

// NotifyEnrichTaskPromptCalls gets all the calls that were made to NotifyEnrichTaskPrompt.
// Check the length with:
//
//	len(mockedNotifier.NotifyEnrichTaskPromptCalls())
func (mock *NotifierMock) NotifyEnrichTaskPromptCalls() []struct {
	Ctx context.Context
	Ev  *event.EnrichTaskPromptEvent
} {
	var calls []struct {
		Ctx context.Context
		Ev  *event.EnrichTaskPromptEvent
	}
	mock.lockNotifyEnrichTaskPrompt.RLock()
	calls = mock.calls.NotifyEnrichTaskPrompt
	mock.lockNotifyEnrichTaskPrompt.RUnlock()
	return calls
}

// NotifyEnrichTaskResponse calls NotifyEnrichTaskResponseFunc.
func (mock *NotifierMock) NotifyEnrichTaskResponse(ctx context.Context, ev *event.EnrichTaskResponseEvent) {
	callInfo := struct {
		Ctx context.Context
		Ev  *event.EnrichTaskResponseEvent
	}{
		Ctx: ctx,
		Ev:  ev,
	}
	mock.lockNotifyEnrichTaskResponse.Lock()
	mock.calls.NotifyEnrichTaskResponse = append(mock.calls.NotifyEnrichTaskResponse, callInfo)
	mock.lockNotifyEnrichTaskResponse.Unlock()
	if mock.NotifyEnrichTaskResponseFunc == nil {
		return
	}
	mock.NotifyEnrichTaskResponseFunc(ctx, ev)
}

// NotifyEnrichTaskResponseCalls gets all the calls that were made to NotifyEnrichTaskResponse.
// Check the length with:
//
//	len(mockedNotifier.NotifyEnrichTaskResponseCalls())
func (mock *NotifierMock) NotifyEnrichTaskResponseCalls() []struct {
	Ctx context.Context
	Ev  *event.EnrichTaskResponseEvent
} {
	var calls []struct {
		Ctx context.Context
		Ev  *event.EnrichTaskResponseEvent
	}
	mock.lockNotifyEnrichTaskResponse.RLock()
	calls = mock.calls.NotifyEnrichTaskResponse
	mock.lockNotifyEnrichTaskResponse.RUnlock()
	return calls
}

// NotifyError calls NotifyErrorFunc.
func (mock *NotifierMock) NotifyError(ctx context.Context, ev *event.ErrorEvent) {
	callInfo := struct {
		Ctx context.Context
		Ev  *event.ErrorEvent
	}{
		Ctx: ctx,
		Ev:  ev,
	}
	mock.lockNotifyError.Lock()
	mock.calls.NotifyError = append(mock.calls.NotifyError, callInfo)
	mock.lockNotifyError.Unlock()
	if mock.NotifyErrorFunc == nil {
		return
	}
	mock.NotifyErrorFunc(ctx, ev)
}

// NotifyErrorCalls gets all the calls that were made to NotifyError.
// Check the length with:
//
//	len(mockedNotifier.NotifyErrorCalls())
func (mock *NotifierMock) NotifyErrorCalls() []struct {
	Ctx context.Context
	Ev  *event.ErrorEvent
} {
	var calls []struct {
		Ctx context.Context
		Ev  *event.ErrorEvent
	}
	mock.lockNotifyError.RLock()
	calls = mock.calls.NotifyError
	mock.lockNotifyError.RUnlock()
	return calls
}

// NotifyIngestPolicyResult calls NotifyIngestPolicyResultFunc.
func (mock *NotifierMock) NotifyIngestPolicyResult(ctx context.Context, ev *event.IngestPolicyResultEvent) {
	callInfo := struct {
		Ctx context.Context
		Ev  *event.IngestPolicyResultEvent
	}{
		Ctx: ctx,
		Ev:  ev,
	}
	mock.lockNotifyIngestPolicyResult.Lock()
	mock.calls.NotifyIngestPolicyResult = append(mock.calls.NotifyIngestPolicyResult, callInfo)
	mock.lockNotifyIngestPolicyResult.Unlock()
	if mock.NotifyIngestPolicyResultFunc == nil {
		return
	}
	mock.NotifyIngestPolicyResultFunc(ctx, ev)
}

// NotifyIngestPolicyResultCalls gets all the calls that were made to NotifyIngestPolicyResult.
// Check the length with:
//
//	len(mockedNotifier.NotifyIngestPolicyResultCalls())
func (mock *NotifierMock) NotifyIngestPolicyResultCalls() []struct {
	Ctx context.Context
	Ev  *event.IngestPolicyResultEvent
} {
	var calls []struct {
		Ctx context.Context
		Ev  *event.IngestPolicyResultEvent
	}
	mock.lockNotifyIngestPolicyResult.RLock()
	calls = mock.calls.NotifyIngestPolicyResult
	mock.lockNotifyIngestPolicyResult.RUnlock()
	return calls
}

// NotifyTriagePolicyResult calls NotifyTriagePolicyResultFunc.
func (mock *NotifierMock) NotifyTriagePolicyResult(ctx context.Context, ev *event.TriagePolicyResultEvent) {
	callInfo := struct {
		Ctx context.Context
		Ev  *event.TriagePolicyResultEvent
	}{
		Ctx: ctx,
		Ev:  ev,
	}
	mock.lockNotifyTriagePolicyResult.Lock()
	mock.calls.NotifyTriagePolicyResult = append(mock.calls.NotifyTriagePolicyResult, callInfo)
	mock.lockNotifyTriagePolicyResult.Unlock()
	if mock.NotifyTriagePolicyResultFunc == nil {
		return
	}
	mock.NotifyTriagePolicyResultFunc(ctx, ev)
}

// NotifyTriagePolicyResultCalls gets all the calls that were made to NotifyTriagePolicyResult.
// Check the length with:
//
//	len(mockedNotifier.NotifyTriagePolicyResultCalls())
func (mock *NotifierMock) NotifyTriagePolicyResultCalls() []struct {
	Ctx context.Context
	Ev  *event.TriagePolicyResultEvent
} {
	var calls []struct {
		Ctx context.Context
		Ev  *event.TriagePolicyResultEvent
	}
	mock.lockNotifyTriagePolicyResult.RLock()
	calls = mock.calls.NotifyTriagePolicyResult
	mock.lockNotifyTriagePolicyResult.RUnlock()
	return calls
}

// RepositoryMock is a mock implementation of interfaces.Repository.
//
//	func TestSomethingThatUsesRepository(t *testing.T) {
//
//		// make and configure a mocked interfaces.Repository
//		mockedRepository := &RepositoryMock{
//			ArchiveKnowledgeFunc: func(ctx context.Context, topic types.KnowledgeTopic, slug types.KnowledgeSlug) error {
//				panic("mock out the ArchiveKnowledge method")
//			},
//			BatchGetAlertsFunc: func(ctx context.Context, alertIDs []types.AlertID) (alert.Alerts, error) {
//				panic("mock out the BatchGetAlerts method")
//			},
//			BatchGetTicketsFunc: func(ctx context.Context, ticketIDs []types.TicketID) ([]*ticket.Ticket, error) {
//				panic("mock out the BatchGetTickets method")
//			},
//			BatchPutAlertsFunc: func(ctx context.Context, alerts alert.Alerts) error {
//				panic("mock out the BatchPutAlerts method")
//			},
//			BatchUpdateTicketsStatusFunc: func(ctx context.Context, ticketIDs []types.TicketID, status types.TicketStatus) error {
//				panic("mock out the BatchUpdateTicketsStatus method")
//			},
//			BindAlertsToTicketFunc: func(ctx context.Context, alertIDs []types.AlertID, ticketID types.TicketID) error {
//				panic("mock out the BindAlertsToTicket method")
//			},
//			CalculateKnowledgeSizeFunc: func(ctx context.Context, topic types.KnowledgeTopic) (int, error) {
//				panic("mock out the CalculateKnowledgeSize method")
//			},
//			CountActivitiesFunc: func(ctx context.Context) (int, error) {
//				panic("mock out the CountActivities method")
//			},
//			CountAlertsWithoutTicketFunc: func(ctx context.Context) (int, error) {
//				panic("mock out the CountAlertsWithoutTicket method")
//			},
//			CountTicketCommentsFunc: func(ctx context.Context, ticketID types.TicketID) (int, error) {
//				panic("mock out the CountTicketComments method")
//			},
//			CountTicketsByStatusFunc: func(ctx context.Context, statuses []types.TicketStatus) (int, error) {
//				panic("mock out the CountTicketsByStatus method")
//			},
//			CreateNoticeFunc: func(ctx context.Context, noticeMoqParam *notice.Notice) error {
//				panic("mock out the CreateNotice method")
//			},
//			CreateTagWithIDFunc: func(ctx context.Context, tagMoqParam *tag.Tag) error {
//				panic("mock out the CreateTagWithID method")
//			},
//			DeleteAgentMemoriesBatchFunc: func(ctx context.Context, agentID string, memoryIDs []types.AgentMemoryID) (int, error) {
//				panic("mock out the DeleteAgentMemoriesBatch method")
//			},
//			DeleteSessionFunc: func(ctx context.Context, sessionID types.SessionID) error {
//				panic("mock out the DeleteSession method")
//			},
//			DeleteTagByIDFunc: func(ctx context.Context, tagID string) error {
//				panic("mock out the DeleteTagByID method")
//			},
//			DeleteTokenFunc: func(ctx context.Context, tokenID auth.TokenID) error {
//				panic("mock out the DeleteToken method")
//			},
//			FindNearestAlertsFunc: func(ctx context.Context, embedding []float32, limit int) (alert.Alerts, error) {
//				panic("mock out the FindNearestAlerts method")
//			},
//			FindNearestTicketsFunc: func(ctx context.Context, embedding []float32, limit int) ([]*ticket.Ticket, error) {
//				panic("mock out the FindNearestTickets method")
//			},
//			FindNearestTicketsWithSpanFunc: func(ctx context.Context, embedding []float32, begin time.Time, end time.Time, limit int) ([]*ticket.Ticket, error) {
//				panic("mock out the FindNearestTicketsWithSpan method")
//			},
//			GetActivitiesFunc: func(ctx context.Context, offset int, limit int) ([]*activity.Activity, error) {
//				panic("mock out the GetActivities method")
//			},
//			GetAgentMemoryFunc: func(ctx context.Context, agentID string, id types.AgentMemoryID) (*memory.AgentMemory, error) {
//				panic("mock out the GetAgentMemory method")
//			},
//			GetAlertFunc: func(ctx context.Context, alertID types.AlertID) (*alert.Alert, error) {
//				panic("mock out the GetAlert method")
//			},
//			GetAlertListFunc: func(ctx context.Context, listID types.AlertListID) (*alert.List, error) {
//				panic("mock out the GetAlertList method")
//			},
//			GetAlertListByThreadFunc: func(ctx context.Context, thread slack.Thread) (*alert.List, error) {
//				panic("mock out the GetAlertListByThread method")
//			},
//			GetAlertListsInThreadFunc: func(ctx context.Context, thread slack.Thread) ([]*alert.List, error) {
//				panic("mock out the GetAlertListsInThread method")
//			},
//			GetAlertWithoutEmbeddingFunc: func(ctx context.Context) (alert.Alerts, error) {
//				panic("mock out the GetAlertWithoutEmbedding method")
//			},
//			GetAlertWithoutTicketFunc: func(ctx context.Context, offset int, limit int) (alert.Alerts, error) {
//				panic("mock out the GetAlertWithoutTicket method")
//			},
//			GetAlertsBySpanFunc: func(ctx context.Context, begin time.Time, end time.Time) (alert.Alerts, error) {
//				panic("mock out the GetAlertsBySpan method")
//			},
//			GetAlertsByThreadFunc: func(ctx context.Context, thread slack.Thread) (alert.Alerts, error) {
//				panic("mock out the GetAlertsByThread method")
//			},
//			GetAlertsWithInvalidEmbeddingFunc: func(ctx context.Context) (alert.Alerts, error) {
//				panic("mock out the GetAlertsWithInvalidEmbedding method")
//			},
//			GetKnowledgeFunc: func(ctx context.Context, topic types.KnowledgeTopic, slug types.KnowledgeSlug) (*knowledge.Knowledge, error) {
//				panic("mock out the GetKnowledge method")
//			},
//			GetKnowledgeByCommitFunc: func(ctx context.Context, topic types.KnowledgeTopic, slug types.KnowledgeSlug, commitID string) (*knowledge.Knowledge, error) {
//				panic("mock out the GetKnowledgeByCommit method")
//			},
//			GetKnowledgesFunc: func(ctx context.Context, topic types.KnowledgeTopic) ([]*knowledge.Knowledge, error) {
//				panic("mock out the GetKnowledges method")
//			},
//			GetLatestAlertByThreadFunc: func(ctx context.Context, thread slack.Thread) (*alert.Alert, error) {
//				panic("mock out the GetLatestAlertByThread method")
//			},
//			GetLatestAlertListInThreadFunc: func(ctx context.Context, thread slack.Thread) (*alert.List, error) {
//				panic("mock out the GetLatestAlertListInThread method")
//			},
//			GetLatestHistoryFunc: func(ctx context.Context, ticketID types.TicketID) (*ticket.History, error) {
//				panic("mock out the GetLatestHistory method")
//			},
//			GetNoticeFunc: func(ctx context.Context, id types.NoticeID) (*notice.Notice, error) {
//				panic("mock out the GetNotice method")
//			},
//			GetOrCreateTagByNameFunc: func(ctx context.Context, name string, description string, color string, createdBy string) (*tag.Tag, error) {
//				panic("mock out the GetOrCreateTagByName method")
//			},
//			GetSessionFunc: func(ctx context.Context, sessionID types.SessionID) (*session.Session, error) {
//				panic("mock out the GetSession method")
//			},
//			GetSessionsByTicketFunc: func(ctx context.Context, ticketID types.TicketID) ([]*session.Session, error) {
//				panic("mock out the GetSessionsByTicket method")
//			},
//			GetTagByIDFunc: func(ctx context.Context, tagID string) (*tag.Tag, error) {
//				panic("mock out the GetTagByID method")
//			},
//			GetTagByNameFunc: func(ctx context.Context, name string) (*tag.Tag, error) {
//				panic("mock out the GetTagByName method")
//			},
//			GetTagsByIDsFunc: func(ctx context.Context, tagIDs []string) ([]*tag.Tag, error) {
//				panic("mock out the GetTagsByIDs method")
//			},
//			GetTicketFunc: func(ctx context.Context, ticketID types.TicketID) (*ticket.Ticket, error) {
//				panic("mock out the GetTicket method")
//			},
//			GetTicketByThreadFunc: func(ctx context.Context, thread slack.Thread) (*ticket.Ticket, error) {
//				panic("mock out the GetTicketByThread method")
//			},
//			GetTicketCommentsFunc: func(ctx context.Context, ticketID types.TicketID) ([]ticket.Comment, error) {
//				panic("mock out the GetTicketComments method")
//			},
//			GetTicketCommentsPaginatedFunc: func(ctx context.Context, ticketID types.TicketID, offset int, limit int) ([]ticket.Comment, error) {
//				panic("mock out the GetTicketCommentsPaginated method")
//			},
//			GetTicketUnpromptedCommentsFunc: func(ctx context.Context, ticketID types.TicketID) ([]ticket.Comment, error) {
//				panic("mock out the GetTicketUnpromptedComments method")
//			},
//			GetTicketsBySpanFunc: func(ctx context.Context, begin time.Time, end time.Time) ([]*ticket.Ticket, error) {
//				panic("mock out the GetTicketsBySpan method")
//			},
//			GetTicketsByStatusFunc: func(ctx context.Context, statuses []types.TicketStatus, offset int, limit int) ([]*ticket.Ticket, error) {
//				panic("mock out the GetTicketsByStatus method")
//			},
//			GetTicketsByStatusAndSpanFunc: func(ctx context.Context, status types.TicketStatus, begin time.Time, end time.Time) ([]*ticket.Ticket, error) {
//				panic("mock out the GetTicketsByStatusAndSpan method")
//			},
//			GetTicketsWithInvalidEmbeddingFunc: func(ctx context.Context) ([]*ticket.Ticket, error) {
//				panic("mock out the GetTicketsWithInvalidEmbedding method")
//			},
//			GetTokenFunc: func(ctx context.Context, tokenID auth.TokenID) (*auth.Token, error) {
//				panic("mock out the GetToken method")
//			},
//			IsTagNameExistsFunc: func(ctx context.Context, name string) (bool, error) {
//				panic("mock out the IsTagNameExists method")
//			},
//			ListAgentMemoriesFunc: func(ctx context.Context, agentID string) ([]*memory.AgentMemory, error) {
//				panic("mock out the ListAgentMemories method")
//			},
//			ListAllTagsFunc: func(ctx context.Context) ([]*tag.Tag, error) {
//				panic("mock out the ListAllTags method")
//			},
//			ListKnowledgeSlugsFunc: func(ctx context.Context, topic types.KnowledgeTopic) ([]*knowledge.SlugInfo, error) {
//				panic("mock out the ListKnowledgeSlugs method")
//			},
//			ListKnowledgeTopicsFunc: func(ctx context.Context) ([]*knowledge.TopicSummary, error) {
//				panic("mock out the ListKnowledgeTopics method")
//			},
//			PutActivityFunc: func(ctx context.Context, activityMoqParam *activity.Activity) error {
//				panic("mock out the PutActivity method")
//			},
//			PutAlertFunc: func(ctx context.Context, alertMoqParam alert.Alert) error {
//				panic("mock out the PutAlert method")
//			},
//			PutAlertListFunc: func(ctx context.Context, list *alert.List) error {
//				panic("mock out the PutAlertList method")
//			},
//			PutHistoryFunc: func(ctx context.Context, ticketID types.TicketID, history *ticket.History) error {
//				panic("mock out the PutHistory method")
//			},
//			PutKnowledgeFunc: func(ctx context.Context, k *knowledge.Knowledge) error {
//				panic("mock out the PutKnowledge method")
//			},
//			PutSessionFunc: func(ctx context.Context, sessionMoqParam *session.Session) error {
//				panic("mock out the PutSession method")
//			},
//			PutTicketFunc: func(ctx context.Context, ticketMoqParam ticket.Ticket) error {
//				panic("mock out the PutTicket method")
//			},
//			PutTicketCommentFunc: func(ctx context.Context, comment ticket.Comment) error {
//				panic("mock out the PutTicketComment method")
//			},
//			PutTicketCommentsPromptedFunc: func(ctx context.Context, ticketID types.TicketID, commentIDs []types.CommentID) error {
//				panic("mock out the PutTicketCommentsPrompted method")
//			},
//			PutTokenFunc: func(ctx context.Context, token *auth.Token) error {
//				panic("mock out the PutToken method")
//			},
//			RemoveTagFromAllAlertsFunc: func(ctx context.Context, name string) error {
//				panic("mock out the RemoveTagFromAllAlerts method")
//			},
//			RemoveTagFromAllTicketsFunc: func(ctx context.Context, name string) error {
//				panic("mock out the RemoveTagFromAllTickets method")
//			},
//			RemoveTagIDFromAllAlertsFunc: func(ctx context.Context, tagID string) error {
//				panic("mock out the RemoveTagIDFromAllAlerts method")
//			},
//			RemoveTagIDFromAllTicketsFunc: func(ctx context.Context, tagID string) error {
//				panic("mock out the RemoveTagIDFromAllTickets method")
//			},
//			SaveAgentMemoryFunc: func(ctx context.Context, mem *memory.AgentMemory) error {
//				panic("mock out the SaveAgentMemory method")
//			},
//			SearchAlertsFunc: func(ctx context.Context, path string, op string, value any, limit int) (alert.Alerts, error) {
//				panic("mock out the SearchAlerts method")
//			},
//			SearchMemoriesByEmbeddingFunc: func(ctx context.Context, agentID string, embedding []float32, limit int) ([]*memory.AgentMemory, error) {
//				panic("mock out the SearchMemoriesByEmbedding method")
//			},
//			UnbindAlertFromTicketFunc: func(ctx context.Context, alertID types.AlertID) error {
//				panic("mock out the UnbindAlertFromTicket method")
//			},
//			UpdateMemoryScoreBatchFunc: func(ctx context.Context, agentID string, updates map[types.AgentMemoryID]struct{Score float64; LastUsedAt time.Time}) error {
//				panic("mock out the UpdateMemoryScoreBatch method")
//			},
//			UpdateNoticeFunc: func(ctx context.Context, noticeMoqParam *notice.Notice) error {
//				panic("mock out the UpdateNotice method")
//			},
//			UpdateTagFunc: func(ctx context.Context, tagMoqParam *tag.Tag) error {
//				panic("mock out the UpdateTag method")
//			},
//		}
//
//		// use mockedRepository in code that requires interfaces.Repository
//		// and then make assertions.
//
//	}
type RepositoryMock struct {
	// ArchiveKnowledgeFunc mocks the ArchiveKnowledge method.
	ArchiveKnowledgeFunc func(ctx context.Context, topic types.KnowledgeTopic, slug types.KnowledgeSlug) error

	// BatchGetAlertsFunc mocks the BatchGetAlerts method.
	BatchGetAlertsFunc func(ctx context.Context, alertIDs []types.AlertID) (alert.Alerts, error)

	// BatchGetTicketsFunc mocks the BatchGetTickets method.
	BatchGetTicketsFunc func(ctx context.Context, ticketIDs []types.TicketID) ([]*ticket.Ticket, error)

	// BatchPutAlertsFunc mocks the BatchPutAlerts method.
	BatchPutAlertsFunc func(ctx context.Context, alerts alert.Alerts) error

	// BatchUpdateTicketsStatusFunc mocks the BatchUpdateTicketsStatus method.
	BatchUpdateTicketsStatusFunc func(ctx context.Context, ticketIDs []types.TicketID, status types.TicketStatus) error

	// BindAlertsToTicketFunc mocks the BindAlertsToTicket method.
	BindAlertsToTicketFunc func(ctx context.Context, alertIDs []types.AlertID, ticketID types.TicketID) error

	// CalculateKnowledgeSizeFunc mocks the CalculateKnowledgeSize method.
	CalculateKnowledgeSizeFunc func(ctx context.Context, topic types.KnowledgeTopic) (int, error)

	// CountActivitiesFunc mocks the CountActivities method.
	CountActivitiesFunc func(ctx context.Context) (int, error)

	// CountAlertsWithoutTicketFunc mocks the CountAlertsWithoutTicket method.
	CountAlertsWithoutTicketFunc func(ctx context.Context) (int, error)

	// CountTicketCommentsFunc mocks the CountTicketComments method.
	CountTicketCommentsFunc func(ctx context.Context, ticketID types.TicketID) (int, error)

	// CountTicketsByStatusFunc mocks the CountTicketsByStatus method.
	CountTicketsByStatusFunc func(ctx context.Context, statuses []types.TicketStatus) (int, error)

	// CreateNoticeFunc mocks the CreateNotice method.
	CreateNoticeFunc func(ctx context.Context, noticeMoqParam *notice.Notice) error

	// CreateTagWithIDFunc mocks the CreateTagWithID method.
	CreateTagWithIDFunc func(ctx context.Context, tagMoqParam *tag.Tag) error

	// DeleteAgentMemoriesBatchFunc mocks the DeleteAgentMemoriesBatch method.
	DeleteAgentMemoriesBatchFunc func(ctx context.Context, agentID string, memoryIDs []types.AgentMemoryID) (int, error)

	// DeleteSessionFunc mocks the DeleteSession method.
	DeleteSessionFunc func(ctx context.Context, sessionID types.SessionID) error

	// DeleteTagByIDFunc mocks the DeleteTagByID method.
	DeleteTagByIDFunc func(ctx context.Context, tagID string) error

	// DeleteTokenFunc mocks the DeleteToken method.
	DeleteTokenFunc func(ctx context.Context, tokenID auth.TokenID) error

	// FindNearestAlertsFunc mocks the FindNearestAlerts method.
	FindNearestAlertsFunc func(ctx context.Context, embedding []float32, limit int) (alert.Alerts, error)

	// FindNearestTicketsFunc mocks the FindNearestTickets method.
	FindNearestTicketsFunc func(ctx context.Context, embedding []float32, limit int) ([]*ticket.Ticket, error)

	// FindNearestTicketsWithSpanFunc mocks the FindNearestTicketsWithSpan method.
	FindNearestTicketsWithSpanFunc func(ctx context.Context, embedding []float32, begin time.Time, end time.Time, limit int) ([]*ticket.Ticket, error)

	// GetActivitiesFunc mocks the GetActivities method.
	GetActivitiesFunc func(ctx context.Context, offset int, limit int) ([]*activity.Activity, error)

	// GetAgentMemoryFunc mocks the GetAgentMemory method.
	GetAgentMemoryFunc func(ctx context.Context, agentID string, id types.AgentMemoryID) (*memory.AgentMemory, error)

	// GetAlertFunc mocks the GetAlert method.
	GetAlertFunc func(ctx context.Context, alertID types.AlertID) (*alert.Alert, error)

	// GetAlertListFunc mocks the GetAlertList method.
	GetAlertListFunc func(ctx context.Context, listID types.AlertListID) (*alert.List, error)

	// GetAlertListByThreadFunc mocks the GetAlertListByThread method.
	GetAlertListByThreadFunc func(ctx context.Context, thread slack.Thread) (*alert.List, error)

	// GetAlertListsInThreadFunc mocks the GetAlertListsInThread method.
	GetAlertListsInThreadFunc func(ctx context.Context, thread slack.Thread) ([]*alert.List, error)

	// GetAlertWithoutEmbeddingFunc mocks the GetAlertWithoutEmbedding method.
	GetAlertWithoutEmbeddingFunc func(ctx context.Context) (alert.Alerts, error)

	// GetAlertWithoutTicketFunc mocks the GetAlertWithoutTicket method.
	GetAlertWithoutTicketFunc func(ctx context.Context, offset int, limit int) (alert.Alerts, error)

	// GetAlertsBySpanFunc mocks the GetAlertsBySpan method.
	GetAlertsBySpanFunc func(ctx context.Context, begin time.Time, end time.Time) (alert.Alerts, error)

	// GetAlertsByThreadFunc mocks the GetAlertsByThread method.
	GetAlertsByThreadFunc func(ctx context.Context, thread slack.Thread) (alert.Alerts, error)

	// GetAlertsWithInvalidEmbeddingFunc mocks the GetAlertsWithInvalidEmbedding method.
	GetAlertsWithInvalidEmbeddingFunc func(ctx context.Context) (alert.Alerts, error)

	// GetKnowledgeFunc mocks the GetKnowledge method.
	GetKnowledgeFunc func(ctx context.Context, topic types.KnowledgeTopic, slug types.KnowledgeSlug) (*knowledge.Knowledge, error)

	// GetKnowledgeByCommitFunc mocks the GetKnowledgeByCommit method.
	GetKnowledgeByCommitFunc func(ctx context.Context, topic types.KnowledgeTopic, slug types.KnowledgeSlug, commitID string) (*knowledge.Knowledge, error)

	// GetKnowledgesFunc mocks the GetKnowledges method.
	GetKnowledgesFunc func(ctx context.Context, topic types.KnowledgeTopic) ([]*knowledge.Knowledge, error)

	// GetLatestAlertByThreadFunc mocks the GetLatestAlertByThread method.
	GetLatestAlertByThreadFunc func(ctx context.Context, thread slack.Thread) (*alert.Alert, error)

	// GetLatestAlertListInThreadFunc mocks the GetLatestAlertListInThread method.
	GetLatestAlertListInThreadFunc func(ctx context.Context, thread slack.Thread) (*alert.List, error)

	// GetLatestHistoryFunc mocks the GetLatestHistory method.
	GetLatestHistoryFunc func(ctx context.Context, ticketID types.TicketID) (*ticket.History, error)

	// GetNoticeFunc mocks the GetNotice method.
	GetNoticeFunc func(ctx context.Context, id types.NoticeID) (*notice.Notice, error)

	// GetOrCreateTagByNameFunc mocks the GetOrCreateTagByName method.
	GetOrCreateTagByNameFunc func(ctx context.Context, name string, description string, color string, createdBy string) (*tag.Tag, error)

	// GetSessionFunc mocks the GetSession method.
	GetSessionFunc func(ctx context.Context, sessionID types.SessionID) (*session.Session, error)

	// GetSessionsByTicketFunc mocks the GetSessionsByTicket method.
	GetSessionsByTicketFunc func(ctx context.Context, ticketID types.TicketID) ([]*session.Session, error)

	// GetTagByIDFunc mocks the GetTagByID method.
	GetTagByIDFunc func(ctx context.Context, tagID string) (*tag.Tag, error)

	// GetTagByNameFunc mocks the GetTagByName method.
	GetTagByNameFunc func(ctx context.Context, name string) (*tag.Tag, error)

	// GetTagsByIDsFunc mocks the GetTagsByIDs method.
	GetTagsByIDsFunc func(ctx context.Context, tagIDs []string) ([]*tag.Tag, error)

	// GetTicketFunc mocks the GetTicket method.
	GetTicketFunc func(ctx context.Context, ticketID types.TicketID) (*ticket.Ticket, error)

	// GetTicketByThreadFunc mocks the GetTicketByThread method.
	GetTicketByThreadFunc func(ctx context.Context, thread slack.Thread) (*ticket.Ticket, error)

	// GetTicketCommentsFunc mocks the GetTicketComments method.
	GetTicketCommentsFunc func(ctx context.Context, ticketID types.TicketID) ([]ticket.Comment, error)

	// GetTicketCommentsPaginatedFunc mocks the GetTicketCommentsPaginated method.
	GetTicketCommentsPaginatedFunc func(ctx context.Context, ticketID types.TicketID, offset int, limit int) ([]ticket.Comment, error)

	// GetTicketUnpromptedCommentsFunc mocks the GetTicketUnpromptedComments method.
	GetTicketUnpromptedCommentsFunc func(ctx context.Context, ticketID types.TicketID) ([]ticket.Comment, error)

	// GetTicketsBySpanFunc mocks the GetTicketsBySpan method.
	GetTicketsBySpanFunc func(ctx context.Context, begin time.Time, end time.Time) ([]*ticket.Ticket, error)

	// GetTicketsByStatusFunc mocks the GetTicketsByStatus method.
	GetTicketsByStatusFunc func(ctx context.Context, statuses []types.TicketStatus, offset int, limit int) ([]*ticket.Ticket, error)

	// GetTicketsByStatusAndSpanFunc mocks the GetTicketsByStatusAndSpan method.
	GetTicketsByStatusAndSpanFunc func(ctx context.Context, status types.TicketStatus, begin time.Time, end time.Time) ([]*ticket.Ticket, error)

	// GetTicketsWithInvalidEmbeddingFunc mocks the GetTicketsWithInvalidEmbedding method.
	GetTicketsWithInvalidEmbeddingFunc func(ctx context.Context) ([]*ticket.Ticket, error)

	// GetTokenFunc mocks the GetToken method.
	GetTokenFunc func(ctx context.Context, tokenID auth.TokenID) (*auth.Token, error)

	// IsTagNameExistsFunc mocks the IsTagNameExists method.
	IsTagNameExistsFunc func(ctx context.Context, name string) (bool, error)

	// ListAgentMemoriesFunc mocks the ListAgentMemories method.
	ListAgentMemoriesFunc func(ctx context.Context, agentID string) ([]*memory.AgentMemory, error)

	// ListAllTagsFunc mocks the ListAllTags method.
	ListAllTagsFunc func(ctx context.Context) ([]*tag.Tag, error)

	// ListKnowledgeSlugsFunc mocks the ListKnowledgeSlugs method.
	ListKnowledgeSlugsFunc func(ctx context.Context, topic types.KnowledgeTopic) ([]*knowledge.SlugInfo, error)

	// ListKnowledgeTopicsFunc mocks the ListKnowledgeTopics method.
	ListKnowledgeTopicsFunc func(ctx context.Context) ([]*knowledge.TopicSummary, error)

	// PutActivityFunc mocks the PutActivity method.
	PutActivityFunc func(ctx context.Context, activityMoqParam *activity.Activity) error

	// PutAlertFunc mocks the PutAlert method.
	PutAlertFunc func(ctx context.Context, alertMoqParam alert.Alert) error

	// PutAlertListFunc mocks the PutAlertList method.
	PutAlertListFunc func(ctx context.Context, list *alert.List) error

	// PutHistoryFunc mocks the PutHistory method.
	PutHistoryFunc func(ctx context.Context, ticketID types.TicketID, history *ticket.History) error

	// PutKnowledgeFunc mocks the PutKnowledge method.
	PutKnowledgeFunc func(ctx context.Context, k *knowledge.Knowledge) error

	// PutSessionFunc mocks the PutSession method.
	PutSessionFunc func(ctx context.Context, sessionMoqParam *session.Session) error

	// PutTicketFunc mocks the PutTicket method.
	PutTicketFunc func(ctx context.Context, ticketMoqParam ticket.Ticket) error

	// PutTicketCommentFunc mocks the PutTicketComment method.
	PutTicketCommentFunc func(ctx context.Context, comment ticket.Comment) error

	// PutTicketCommentsPromptedFunc mocks the PutTicketCommentsPrompted method.
	PutTicketCommentsPromptedFunc func(ctx context.Context, ticketID types.TicketID, commentIDs []types.CommentID) error

	// PutTokenFunc mocks the PutToken method.
	PutTokenFunc func(ctx context.Context, token *auth.Token) error

	// RemoveTagFromAllAlertsFunc mocks the RemoveTagFromAllAlerts method.
	RemoveTagFromAllAlertsFunc func(ctx context.Context, name string) error

	// RemoveTagFromAllTicketsFunc mocks the RemoveTagFromAllTickets method.
	RemoveTagFromAllTicketsFunc func(ctx context.Context, name string) error

	// RemoveTagIDFromAllAlertsFunc mocks the RemoveTagIDFromAllAlerts method.
	RemoveTagIDFromAllAlertsFunc func(ctx context.Context, tagID string) error

	// RemoveTagIDFromAllTicketsFunc mocks the RemoveTagIDFromAllTickets method.
	RemoveTagIDFromAllTicketsFunc func(ctx context.Context, tagID string) error

	// SaveAgentMemoryFunc mocks the SaveAgentMemory method.
	SaveAgentMemoryFunc func(ctx context.Context, mem *memory.AgentMemory) error

	// SearchAlertsFunc mocks the SearchAlerts method.
	SearchAlertsFunc func(ctx context.Context, path string, op string, value any, limit int) (alert.Alerts, error)

	// SearchMemoriesByEmbeddingFunc mocks the SearchMemoriesByEmbedding method.
	SearchMemoriesByEmbeddingFunc func(ctx context.Context, agentID string, embedding []float32, limit int) ([]*memory.AgentMemory, error)

	// UnbindAlertFromTicketFunc mocks the UnbindAlertFromTicket method.
	UnbindAlertFromTicketFunc func(ctx context.Context, alertID types.AlertID) error

	// UpdateMemoryScoreBatchFunc mocks the UpdateMemoryScoreBatch method.
	UpdateMemoryScoreBatchFunc func(ctx context.Context, agentID string, updates map[types.AgentMemoryID]struct {
		Score      float64
		LastUsedAt time.Time
	}) error

	// UpdateNoticeFunc mocks the UpdateNotice method.
	UpdateNoticeFunc func(ctx context.Context, noticeMoqParam *notice.Notice) error

	// UpdateTagFunc mocks the UpdateTag method.
	UpdateTagFunc func(ctx context.Context, tagMoqParam *tag.Tag) error

	// calls tracks calls to the methods.
	calls struct {
		// ArchiveKnowledge holds details about calls to the ArchiveKnowledge method.
		ArchiveKnowledge []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Topic is the topic argument value.
			Topic types.KnowledgeTopic
			// Slug is the slug argument value.
			Slug types.KnowledgeSlug
		}
		// BatchGetAlerts holds details about calls to the BatchGetAlerts method.
		BatchGetAlerts []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AlertIDs is the alertIDs argument value.
			AlertIDs []types.AlertID
		}
		// BatchGetTickets holds details about calls to the BatchGetTickets method.
		BatchGetTickets []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketIDs is the ticketIDs argument value.
			TicketIDs []types.TicketID
		}
		// BatchPutAlerts holds details about calls to the BatchPutAlerts method.
		BatchPutAlerts []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Alerts is the alerts argument value.
			Alerts alert.Alerts
		}
		// BatchUpdateTicketsStatus holds details about calls to the BatchUpdateTicketsStatus method.
		BatchUpdateTicketsStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketIDs is the ticketIDs argument value.
			TicketIDs []types.TicketID
			// Status is the status argument value.
			Status types.TicketStatus
		}
		// BindAlertsToTicket holds details about calls to the BindAlertsToTicket method.
		BindAlertsToTicket []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AlertIDs is the alertIDs argument value.
			AlertIDs []types.AlertID
			// TicketID is the ticketID argument value.
			TicketID types.TicketID
		}
		// CalculateKnowledgeSize holds details about calls to the CalculateKnowledgeSize method.
		CalculateKnowledgeSize []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Topic is the topic argument value.
			Topic types.KnowledgeTopic
		}
		// CountActivities holds details about calls to the CountActivities method.
		CountActivities []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// CountAlertsWithoutTicket holds details about calls to the CountAlertsWithoutTicket method.
		CountAlertsWithoutTicket []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// CountTicketComments holds details about calls to the CountTicketComments method.
		CountTicketComments []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketID is the ticketID argument value.
			TicketID types.TicketID
		}
		// CountTicketsByStatus holds details about calls to the CountTicketsByStatus method.
		CountTicketsByStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Statuses is the statuses argument value.
			Statuses []types.TicketStatus
		}
		// CreateNotice holds details about calls to the CreateNotice method.
		CreateNotice []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NoticeMoqParam is the noticeMoqParam argument value.
			NoticeMoqParam *notice.Notice
		}
		// CreateTagWithID holds details about calls to the CreateTagWithID method.
		CreateTagWithID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TagMoqParam is the tagMoqParam argument value.
			TagMoqParam *tag.Tag
		}
		// DeleteAgentMemoriesBatch holds details about calls to the DeleteAgentMemoriesBatch method.
		DeleteAgentMemoriesBatch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AgentID is the agentID argument value.
			AgentID string
			// MemoryIDs is the memoryIDs argument value.
			MemoryIDs []types.AgentMemoryID
		}
		// DeleteSession holds details about calls to the DeleteSession method.
		DeleteSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SessionID is the sessionID argument value.
			SessionID types.SessionID
		}
		// DeleteTagByID holds details about calls to the DeleteTagByID method.
		DeleteTagByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TagID is the tagID argument value.
			TagID string
		}
		// DeleteToken holds details about calls to the DeleteToken method.
		DeleteToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TokenID is the tokenID argument value.
			TokenID auth.TokenID
		}
		// FindNearestAlerts holds details about calls to the FindNearestAlerts method.
		FindNearestAlerts []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Embedding is the embedding argument value.
			Embedding []float32
			// Limit is the limit argument value.
			Limit int
		}
		// FindNearestTickets holds details about calls to the FindNearestTickets method.
		FindNearestTickets []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Embedding is the embedding argument value.
			Embedding []float32
			// Limit is the limit argument value.
			Limit int
		}
		// FindNearestTicketsWithSpan holds details about calls to the FindNearestTicketsWithSpan method.
		FindNearestTicketsWithSpan []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Embedding is the embedding argument value.
			Embedding []float32
			// Begin is the begin argument value.
			Begin time.Time
			// End is the end argument value.
			End time.Time
			// Limit is the limit argument value.
			Limit int
		}
		// GetActivities holds details about calls to the GetActivities method.
		GetActivities []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
		}
		// GetAgentMemory holds details about calls to the GetAgentMemory method.
		GetAgentMemory []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AgentID is the agentID argument value.
			AgentID string
			// ID is the id argument value.
			ID types.AgentMemoryID
		}
		// GetAlert holds details about calls to the GetAlert method.
		GetAlert []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AlertID is the alertID argument value.
			AlertID types.AlertID
		}
		// GetAlertList holds details about calls to the GetAlertList method.
		GetAlertList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ListID is the listID argument value.
			ListID types.AlertListID
		}
		// GetAlertListByThread holds details about calls to the GetAlertListByThread method.
		GetAlertListByThread []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Thread is the thread argument value.
			Thread slack.Thread
		}
		// GetAlertListsInThread holds details about calls to the GetAlertListsInThread method.
		GetAlertListsInThread []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Thread is the thread argument value.
			Thread slack.Thread
		}
		// GetAlertWithoutEmbedding holds details about calls to the GetAlertWithoutEmbedding method.
		GetAlertWithoutEmbedding []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetAlertWithoutTicket holds details about calls to the GetAlertWithoutTicket method.
		GetAlertWithoutTicket []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
		}
		// GetAlertsBySpan holds details about calls to the GetAlertsBySpan method.
		GetAlertsBySpan []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Begin is the begin argument value.
			Begin time.Time
			// End is the end argument value.
			End time.Time
		}
		// GetAlertsByThread holds details about calls to the GetAlertsByThread method.
		GetAlertsByThread []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Thread is the thread argument value.
			Thread slack.Thread
		}
		// GetAlertsWithInvalidEmbedding holds details about calls to the GetAlertsWithInvalidEmbedding method.
		GetAlertsWithInvalidEmbedding []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetKnowledge holds details about calls to the GetKnowledge method.
		GetKnowledge []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Topic is the topic argument value.
			Topic types.KnowledgeTopic
			// Slug is the slug argument value.
			Slug types.KnowledgeSlug
		}
		// GetKnowledgeByCommit holds details about calls to the GetKnowledgeByCommit method.
		GetKnowledgeByCommit []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Topic is the topic argument value.
			Topic types.KnowledgeTopic
			// Slug is the slug argument value.
			Slug types.KnowledgeSlug
			// CommitID is the commitID argument value.
			CommitID string
		}
		// GetKnowledges holds details about calls to the GetKnowledges method.
		GetKnowledges []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Topic is the topic argument value.
			Topic types.KnowledgeTopic
		}
		// GetLatestAlertByThread holds details about calls to the GetLatestAlertByThread method.
		GetLatestAlertByThread []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Thread is the thread argument value.
			Thread slack.Thread
		}
		// GetLatestAlertListInThread holds details about calls to the GetLatestAlertListInThread method.
		GetLatestAlertListInThread []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Thread is the thread argument value.
			Thread slack.Thread
		}
		// GetLatestHistory holds details about calls to the GetLatestHistory method.
		GetLatestHistory []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketID is the ticketID argument value.
			TicketID types.TicketID
		}
		// GetNotice holds details about calls to the GetNotice method.
		GetNotice []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID types.NoticeID
		}
		// GetOrCreateTagByName holds details about calls to the GetOrCreateTagByName method.
		GetOrCreateTagByName []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// Description is the description argument value.
			Description string
			// Color is the color argument value.
			Color string
			// CreatedBy is the createdBy argument value.
			CreatedBy string
		}
		// GetSession holds details about calls to the GetSession method.
		GetSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SessionID is the sessionID argument value.
			SessionID types.SessionID
		}
		// GetSessionsByTicket holds details about calls to the GetSessionsByTicket method.
		GetSessionsByTicket []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketID is the ticketID argument value.
			TicketID types.TicketID
		}
		// GetTagByID holds details about calls to the GetTagByID method.
		GetTagByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TagID is the tagID argument value.
			TagID string
		}
		// GetTagByName holds details about calls to the GetTagByName method.
		GetTagByName []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
		// GetTagsByIDs holds details about calls to the GetTagsByIDs method.
		GetTagsByIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TagIDs is the tagIDs argument value.
			TagIDs []string
		}
		// GetTicket holds details about calls to the GetTicket method.
		GetTicket []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketID is the ticketID argument value.
			TicketID types.TicketID
		}
		// GetTicketByThread holds details about calls to the GetTicketByThread method.
		GetTicketByThread []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Thread is the thread argument value.
			Thread slack.Thread
		}
		// GetTicketComments holds details about calls to the GetTicketComments method.
		GetTicketComments []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketID is the ticketID argument value.
			TicketID types.TicketID
		}
		// GetTicketCommentsPaginated holds details about calls to the GetTicketCommentsPaginated method.
		GetTicketCommentsPaginated []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketID is the ticketID argument value.
			TicketID types.TicketID
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
		}
		// GetTicketUnpromptedComments holds details about calls to the GetTicketUnpromptedComments method.
		GetTicketUnpromptedComments []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketID is the ticketID argument value.
			TicketID types.TicketID
		}
		// GetTicketsBySpan holds details about calls to the GetTicketsBySpan method.
		GetTicketsBySpan []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Begin is the begin argument value.
			Begin time.Time
			// End is the end argument value.
			End time.Time
		}
		// GetTicketsByStatus holds details about calls to the GetTicketsByStatus method.
		GetTicketsByStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Statuses is the statuses argument value.
			Statuses []types.TicketStatus
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
		}
		// GetTicketsByStatusAndSpan holds details about calls to the GetTicketsByStatusAndSpan method.
		GetTicketsByStatusAndSpan []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Status is the status argument value.
			Status types.TicketStatus
			// Begin is the begin argument value.
			Begin time.Time
			// End is the end argument value.
			End time.Time
		}
		// GetTicketsWithInvalidEmbedding holds details about calls to the GetTicketsWithInvalidEmbedding method.
		GetTicketsWithInvalidEmbedding []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetToken holds details about calls to the GetToken method.
		GetToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TokenID is the tokenID argument value.
			TokenID auth.TokenID
		}
		// IsTagNameExists holds details about calls to the IsTagNameExists method.
		IsTagNameExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
		// ListAgentMemories holds details about calls to the ListAgentMemories method.
		ListAgentMemories []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AgentID is the agentID argument value.
			AgentID string
		}
		// ListAllTags holds details about calls to the ListAllTags method.
		ListAllTags []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListKnowledgeSlugs holds details about calls to the ListKnowledgeSlugs method.
		ListKnowledgeSlugs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Topic is the topic argument value.
			Topic types.KnowledgeTopic
		}
		// ListKnowledgeTopics holds details about calls to the ListKnowledgeTopics method.
		ListKnowledgeTopics []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// PutActivity holds details about calls to the PutActivity method.
		PutActivity []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ActivityMoqParam is the activityMoqParam argument value.
			ActivityMoqParam *activity.Activity
		}
		// PutAlert holds details about calls to the PutAlert method.
		PutAlert []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AlertMoqParam is the alertMoqParam argument value.
			AlertMoqParam alert.Alert
		}
		// PutAlertList holds details about calls to the PutAlertList method.
		PutAlertList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// List is the list argument value.
			List *alert.List
		}
		// PutHistory holds details about calls to the PutHistory method.
		PutHistory []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketID is the ticketID argument value.
			TicketID types.TicketID
			// History is the history argument value.
			History *ticket.History
		}
		// PutKnowledge holds details about calls to the PutKnowledge method.
		PutKnowledge []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// K is the k argument value.
			K *knowledge.Knowledge
		}
		// PutSession holds details about calls to the PutSession method.
		PutSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SessionMoqParam is the sessionMoqParam argument value.
			SessionMoqParam *session.Session
		}
		// PutTicket holds details about calls to the PutTicket method.
		PutTicket []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketMoqParam is the ticketMoqParam argument value.
			TicketMoqParam ticket.Ticket
		}
		// PutTicketComment holds details about calls to the PutTicketComment method.
		PutTicketComment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Comment is the comment argument value.
			Comment ticket.Comment
		}
		// PutTicketCommentsPrompted holds details about calls to the PutTicketCommentsPrompted method.
		PutTicketCommentsPrompted []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketID is the ticketID argument value.
			TicketID types.TicketID
			// CommentIDs is the commentIDs argument value.
			CommentIDs []types.CommentID
		}
		// PutToken holds details about calls to the PutToken method.
		PutToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Token is the token argument value.
			Token *auth.Token
		}
		// RemoveTagFromAllAlerts holds details about calls to the RemoveTagFromAllAlerts method.
		RemoveTagFromAllAlerts []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
		// RemoveTagFromAllTickets holds details about calls to the RemoveTagFromAllTickets method.
		RemoveTagFromAllTickets []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
		// RemoveTagIDFromAllAlerts holds details about calls to the RemoveTagIDFromAllAlerts method.
		RemoveTagIDFromAllAlerts []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TagID is the tagID argument value.
			TagID string
		}
		// RemoveTagIDFromAllTickets holds details about calls to the RemoveTagIDFromAllTickets method.
		RemoveTagIDFromAllTickets []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TagID is the tagID argument value.
			TagID string
		}
		// SaveAgentMemory holds details about calls to the SaveAgentMemory method.
		SaveAgentMemory []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Mem is the mem argument value.
			Mem *memory.AgentMemory
		}
		// SearchAlerts holds details about calls to the SearchAlerts method.
		SearchAlerts []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Path is the path argument value.
			Path string
			// Op is the op argument value.
			Op string
			// Value is the value argument value.
			Value any
			// Limit is the limit argument value.
			Limit int
		}
		// SearchMemoriesByEmbedding holds details about calls to the SearchMemoriesByEmbedding method.
		SearchMemoriesByEmbedding []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AgentID is the agentID argument value.
			AgentID string
			// Embedding is the embedding argument value.
			Embedding []float32
			// Limit is the limit argument value.
			Limit int
		}
		// UnbindAlertFromTicket holds details about calls to the UnbindAlertFromTicket method.
		UnbindAlertFromTicket []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AlertID is the alertID argument value.
			AlertID types.AlertID
		}
		// UpdateMemoryScoreBatch holds details about calls to the UpdateMemoryScoreBatch method.
		UpdateMemoryScoreBatch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AgentID is the agentID argument value.
			AgentID string
			// Updates is the updates argument value.
			Updates map[types.AgentMemoryID]struct {
				Score      float64
				LastUsedAt time.Time
			}
		}
		// UpdateNotice holds details about calls to the UpdateNotice method.
		UpdateNotice []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NoticeMoqParam is the noticeMoqParam argument value.
			NoticeMoqParam *notice.Notice
		}
		// UpdateTag holds details about calls to the UpdateTag method.
		UpdateTag []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TagMoqParam is the tagMoqParam argument value.
			TagMoqParam *tag.Tag
		}
	}
	lockArchiveKnowledge               sync.RWMutex
	lockBatchGetAlerts                 sync.RWMutex
	lockBatchGetTickets                sync.RWMutex
	lockBatchPutAlerts                 sync.RWMutex
	lockBatchUpdateTicketsStatus       sync.RWMutex
	lockBindAlertsToTicket             sync.RWMutex
	lockCalculateKnowledgeSize         sync.RWMutex
	lockCountActivities                sync.RWMutex
	lockCountAlertsWithoutTicket       sync.RWMutex
	lockCountTicketComments            sync.RWMutex
	lockCountTicketsByStatus           sync.RWMutex
	lockCreateNotice                   sync.RWMutex
	lockCreateTagWithID                sync.RWMutex
	lockDeleteAgentMemoriesBatch       sync.RWMutex
	lockDeleteSession                  sync.RWMutex
	lockDeleteTagByID                  sync.RWMutex
	lockDeleteToken                    sync.RWMutex
	lockFindNearestAlerts              sync.RWMutex
	lockFindNearestTickets             sync.RWMutex
	lockFindNearestTicketsWithSpan     sync.RWMutex
	lockGetActivities                  sync.RWMutex
	lockGetAgentMemory                 sync.RWMutex
	lockGetAlert                       sync.RWMutex
	lockGetAlertList                   sync.RWMutex
	lockGetAlertListByThread           sync.RWMutex
	lockGetAlertListsInThread          sync.RWMutex
	lockGetAlertWithoutEmbedding       sync.RWMutex
	lockGetAlertWithoutTicket          sync.RWMutex
	lockGetAlertsBySpan                sync.RWMutex
	lockGetAlertsByThread              sync.RWMutex
	lockGetAlertsWithInvalidEmbedding  sync.RWMutex
	lockGetKnowledge                   sync.RWMutex
	lockGetKnowledgeByCommit           sync.RWMutex
	lockGetKnowledges                  sync.RWMutex
	lockGetLatestAlertByThread         sync.RWMutex
	lockGetLatestAlertListInThread     sync.RWMutex
	lockGetLatestHistory               sync.RWMutex
	lockGetNotice                      sync.RWMutex
	lockGetOrCreateTagByName           sync.RWMutex
	lockGetSession                     sync.RWMutex
	lockGetSessionsByTicket            sync.RWMutex
	lockGetTagByID                     sync.RWMutex
	lockGetTagByName                   sync.RWMutex
	lockGetTagsByIDs                   sync.RWMutex
	lockGetTicket                      sync.RWMutex
	lockGetTicketByThread              sync.RWMutex
	lockGetTicketComments              sync.RWMutex
	lockGetTicketCommentsPaginated     sync.RWMutex
	lockGetTicketUnpromptedComments    sync.RWMutex
	lockGetTicketsBySpan               sync.RWMutex
	lockGetTicketsByStatus             sync.RWMutex
	lockGetTicketsByStatusAndSpan      sync.RWMutex
	lockGetTicketsWithInvalidEmbedding sync.RWMutex
	lockGetToken                       sync.RWMutex
	lockIsTagNameExists                sync.RWMutex
	lockListAgentMemories              sync.RWMutex
	lockListAllTags                    sync.RWMutex
	lockListKnowledgeSlugs             sync.RWMutex
	lockListKnowledgeTopics            sync.RWMutex
	lockPutActivity                    sync.RWMutex
	lockPutAlert                       sync.RWMutex
	lockPutAlertList                   sync.RWMutex
	lockPutHistory                     sync.RWMutex
	lockPutKnowledge                   sync.RWMutex
	lockPutSession                     sync.RWMutex
	lockPutTicket                      sync.RWMutex
	lockPutTicketComment               sync.RWMutex
	lockPutTicketCommentsPrompted      sync.RWMutex
	lockPutToken                       sync.RWMutex
	lockRemoveTagFromAllAlerts         sync.RWMutex
	lockRemoveTagFromAllTickets        sync.RWMutex
	lockRemoveTagIDFromAllAlerts       sync.RWMutex
	lockRemoveTagIDFromAllTickets      sync.RWMutex
	lockSaveAgentMemory                sync.RWMutex
	lockSearchAlerts                   sync.RWMutex
	lockSearchMemoriesByEmbedding      sync.RWMutex
	lockUnbindAlertFromTicket          sync.RWMutex
	lockUpdateMemoryScoreBatch         sync.RWMutex
	lockUpdateNotice                   sync.RWMutex
	lockUpdateTag                      sync.RWMutex
}

// ArchiveKnowledge calls ArchiveKnowledgeFunc.
func (mock *RepositoryMock) ArchiveKnowledge(ctx context.Context, topic types.KnowledgeTopic, slug types.KnowledgeSlug) error {
	callInfo := struct {
		Ctx   context.Context
		Topic types.KnowledgeTopic
		Slug  types.KnowledgeSlug
	}{
		Ctx:   ctx,
		Topic: topic,
		Slug:  slug,
	}
	mock.lockArchiveKnowledge.Lock()
	mock.calls.ArchiveKnowledge = append(mock.calls.ArchiveKnowledge, callInfo)
	mock.lockArchiveKnowledge.Unlock()
	if mock.ArchiveKnowledgeFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.ArchiveKnowledgeFunc(ctx, topic, slug)
}

// ArchiveKnowledgeCalls gets all the calls that were made to ArchiveKnowledge.
// Check the length with:
//
//	len(mockedRepository.ArchiveKnowledgeCalls())
func (mock *RepositoryMock) ArchiveKnowledgeCalls() []struct {
	Ctx   context.Context
	Topic types.KnowledgeTopic
	Slug  types.KnowledgeSlug
} {
	var calls []struct {
		Ctx   context.Context
		Topic types.KnowledgeTopic
		Slug  types.KnowledgeSlug
	}
	mock.lockArchiveKnowledge.RLock()
	calls = mock.calls.ArchiveKnowledge
	mock.lockArchiveKnowledge.RUnlock()
	return calls
}

// BatchGetAlerts calls BatchGetAlertsFunc.
func (mock *RepositoryMock) BatchGetAlerts(ctx context.Context, alertIDs []types.AlertID) (alert.Alerts, error) {
	callInfo := struct {
		Ctx      context.Context
		AlertIDs []types.AlertID
	}{
		Ctx:      ctx,
		AlertIDs: alertIDs,
	}
	mock.lockBatchGetAlerts.Lock()
	mock.calls.BatchGetAlerts = append(mock.calls.BatchGetAlerts, callInfo)
	mock.lockBatchGetAlerts.Unlock()
	if mock.BatchGetAlertsFunc == nil {
		var (
			alertsOut alert.Alerts
			errOut    error
		)
		return alertsOut, errOut
	}
	return mock.BatchGetAlertsFunc(ctx, alertIDs)
}

// BatchGetAlertsCalls gets all the calls that were made to BatchGetAlerts.
// Check the length with:
//
//	len(mockedRepository.BatchGetAlertsCalls())
func (mock *RepositoryMock) BatchGetAlertsCalls() []struct {
	Ctx      context.Context
	AlertIDs []types.AlertID
} {
	var calls []struct {
		Ctx      context.Context
		AlertIDs []types.AlertID
	}
	mock.lockBatchGetAlerts.RLock()
	calls = mock.calls.BatchGetAlerts
	mock.lockBatchGetAlerts.RUnlock()
	return calls
}

// BatchGetTickets calls BatchGetTicketsFunc.
func (mock *RepositoryMock) BatchGetTickets(ctx context.Context, ticketIDs []types.TicketID) ([]*ticket.Ticket, error) {
	callInfo := struct {
		Ctx       context.Context
		TicketIDs []types.TicketID
	}{
		Ctx:       ctx,
		TicketIDs: ticketIDs,
	}
	mock.lockBatchGetTickets.Lock()
	mock.calls.BatchGetTickets = append(mock.calls.BatchGetTickets, callInfo)
	mock.lockBatchGetTickets.Unlock()
	if mock.BatchGetTicketsFunc == nil {
		var (
			ticketsOut []*ticket.Ticket
			errOut     error
		)
		return ticketsOut, errOut
	}
	return mock.BatchGetTicketsFunc(ctx, ticketIDs)
}

// BatchGetTicketsCalls gets all the calls that were made to BatchGetTickets.
// Check the length with:
//
//	len(mockedRepository.BatchGetTicketsCalls())
func (mock *RepositoryMock) BatchGetTicketsCalls() []struct {
	Ctx       context.Context
	TicketIDs []types.TicketID
} {
	var calls []struct {
		Ctx       context.Context
		TicketIDs []types.TicketID
	}
	mock.lockBatchGetTickets.RLock()
	calls = mock.calls.BatchGetTickets
	mock.lockBatchGetTickets.RUnlock()
	return calls
}

// BatchPutAlerts calls BatchPutAlertsFunc.
func (mock *RepositoryMock) BatchPutAlerts(ctx context.Context, alerts alert.Alerts) error {
	callInfo := struct {
		Ctx    context.Context
		Alerts alert.Alerts
	}{
		Ctx:    ctx,
		Alerts: alerts,
	}
	mock.lockBatchPutAlerts.Lock()
	mock.calls.BatchPutAlerts = append(mock.calls.BatchPutAlerts, callInfo)
	mock.lockBatchPutAlerts.Unlock()
	if mock.BatchPutAlertsFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.BatchPutAlertsFunc(ctx, alerts)
}

// BatchPutAlertsCalls gets all the calls that were made to BatchPutAlerts.
// Check the length with:
//
//	len(mockedRepository.BatchPutAlertsCalls())
func (mock *RepositoryMock) BatchPutAlertsCalls() []struct {
	Ctx    context.Context
	Alerts alert.Alerts
} {
	var calls []struct {
		Ctx    context.Context
		Alerts alert.Alerts
	}
	mock.lockBatchPutAlerts.RLock()
	calls = mock.calls.BatchPutAlerts
	mock.lockBatchPutAlerts.RUnlock()
	return calls
}

// BatchUpdateTicketsStatus calls BatchUpdateTicketsStatusFunc.
func (mock *RepositoryMock) BatchUpdateTicketsStatus(ctx context.Context, ticketIDs []types.TicketID, status types.TicketStatus) error {
	callInfo := struct {
		Ctx       context.Context
		TicketIDs []types.TicketID
		Status    types.TicketStatus
	}{
		Ctx:       ctx,
		TicketIDs: ticketIDs,
		Status:    status,
	}
	mock.lockBatchUpdateTicketsStatus.Lock()
	mock.calls.BatchUpdateTicketsStatus = append(mock.calls.BatchUpdateTicketsStatus, callInfo)
	mock.lockBatchUpdateTicketsStatus.Unlock()
	if mock.BatchUpdateTicketsStatusFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.BatchUpdateTicketsStatusFunc(ctx, ticketIDs, status)
}

// BatchUpdateTicketsStatusCalls gets all the calls that were made to BatchUpdateTicketsStatus.
// Check the length with:
//
//	len(mockedRepository.BatchUpdateTicketsStatusCalls())
func (mock *RepositoryMock) BatchUpdateTicketsStatusCalls() []struct {
	Ctx       context.Context
	TicketIDs []types.TicketID
	Status    types.TicketStatus
} {
	var calls []struct {
		Ctx       context.Context
		TicketIDs []types.TicketID
		Status    types.TicketStatus
	}
	mock.lockBatchUpdateTicketsStatus.RLock()
	calls = mock.calls.BatchUpdateTicketsStatus
	mock.lockBatchUpdateTicketsStatus.RUnlock()
	return calls
}

// BindAlertsToTicket calls BindAlertsToTicketFunc.
func (mock *RepositoryMock) BindAlertsToTicket(ctx context.Context, alertIDs []types.AlertID, ticketID types.TicketID) error {
	callInfo := struct {
		Ctx      context.Context
		AlertIDs []types.AlertID
		TicketID types.TicketID
	}{
		Ctx:      ctx,
		AlertIDs: alertIDs,
		TicketID: ticketID,
	}
	mock.lockBindAlertsToTicket.Lock()
	mock.calls.BindAlertsToTicket = append(mock.calls.BindAlertsToTicket, callInfo)
	mock.lockBindAlertsToTicket.Unlock()
	if mock.BindAlertsToTicketFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.BindAlertsToTicketFunc(ctx, alertIDs, ticketID)
}

// BindAlertsToTicketCalls gets all the calls that were made to BindAlertsToTicket.
// Check the length with:
//
//	len(mockedRepository.BindAlertsToTicketCalls())
func (mock *RepositoryMock) BindAlertsToTicketCalls() []struct {
	Ctx      context.Context
	AlertIDs []types.AlertID
	TicketID types.TicketID
} {
	var calls []struct {
		Ctx      context.Context
		AlertIDs []types.AlertID
		TicketID types.TicketID
	}
	mock.lockBindAlertsToTicket.RLock()
	calls = mock.calls.BindAlertsToTicket
	mock.lockBindAlertsToTicket.RUnlock()
	return calls
}

// CalculateKnowledgeSize calls CalculateKnowledgeSizeFunc.
func (mock *RepositoryMock) CalculateKnowledgeSize(ctx context.Context, topic types.KnowledgeTopic) (int, error) {
	callInfo := struct {
		Ctx   context.Context
		Topic types.KnowledgeTopic
	}{
		Ctx:   ctx,
		Topic: topic,
	}
	mock.lockCalculateKnowledgeSize.Lock()
	mock.calls.CalculateKnowledgeSize = append(mock.calls.CalculateKnowledgeSize, callInfo)
	mock.lockCalculateKnowledgeSize.Unlock()
	if mock.CalculateKnowledgeSizeFunc == nil {
		var (
			nOut   int
			errOut error
		)
		return nOut, errOut
	}
	return mock.CalculateKnowledgeSizeFunc(ctx, topic)
}

// CalculateKnowledgeSizeCalls gets all the calls that were made to CalculateKnowledgeSize.
// Check the length with:
//
//	len(mockedRepository.CalculateKnowledgeSizeCalls())
func (mock *RepositoryMock) CalculateKnowledgeSizeCalls() []struct {
	Ctx   context.Context
	Topic types.KnowledgeTopic
} {
	var calls []struct {
		Ctx   context.Context
		Topic types.KnowledgeTopic
	}
	mock.lockCalculateKnowledgeSize.RLock()
	calls = mock.calls.CalculateKnowledgeSize
	mock.lockCalculateKnowledgeSize.RUnlock()
	return calls
}

// CountActivities calls CountActivitiesFunc.
func (mock *RepositoryMock) CountActivities(ctx context.Context) (int, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockCountActivities.Lock()
	mock.calls.CountActivities = append(mock.calls.CountActivities, callInfo)
	mock.lockCountActivities.Unlock()
	if mock.CountActivitiesFunc == nil {
		var (
			nOut   int
			errOut error
		)
		return nOut, errOut
	}
	return mock.CountActivitiesFunc(ctx)
}

// CountActivitiesCalls gets all the calls that were made to CountActivities.
// Check the length with:
//
//	len(mockedRepository.CountActivitiesCalls())
func (mock *RepositoryMock) CountActivitiesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockCountActivities.RLock()
	calls = mock.calls.CountActivities
	mock.lockCountActivities.RUnlock()
	return calls
}

// CountAlertsWithoutTicket calls CountAlertsWithoutTicketFunc.
func (mock *RepositoryMock) CountAlertsWithoutTicket(ctx context.Context) (int, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockCountAlertsWithoutTicket.Lock()
	mock.calls.CountAlertsWithoutTicket = append(mock.calls.CountAlertsWithoutTicket, callInfo)
	mock.lockCountAlertsWithoutTicket.Unlock()
	if mock.CountAlertsWithoutTicketFunc == nil {
		var (
			nOut   int
			errOut error
		)
		return nOut, errOut
	}
	return mock.CountAlertsWithoutTicketFunc(ctx)
}

// CountAlertsWithoutTicketCalls gets all the calls that were made to CountAlertsWithoutTicket.
// Check the length with:
//
//	len(mockedRepository.CountAlertsWithoutTicketCalls())
func (mock *RepositoryMock) CountAlertsWithoutTicketCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockCountAlertsWithoutTicket.RLock()
	calls = mock.calls.CountAlertsWithoutTicket
	mock.lockCountAlertsWithoutTicket.RUnlock()
	return calls
}

// CountTicketComments calls CountTicketCommentsFunc.
func (mock *RepositoryMock) CountTicketComments(ctx context.Context, ticketID types.TicketID) (int, error) {
	callInfo := struct {
		Ctx      context.Context
		TicketID types.TicketID
	}{
		Ctx:      ctx,
		TicketID: ticketID,
	}
	mock.lockCountTicketComments.Lock()
	mock.calls.CountTicketComments = append(mock.calls.CountTicketComments, callInfo)
	mock.lockCountTicketComments.Unlock()
	if mock.CountTicketCommentsFunc == nil {
		var (
			nOut   int
			errOut error
		)
		return nOut, errOut
	}
	return mock.CountTicketCommentsFunc(ctx, ticketID)
}

// CountTicketCommentsCalls gets all the calls that were made to CountTicketComments.
// Check the length with:
//
//	len(mockedRepository.CountTicketCommentsCalls())
func (mock *RepositoryMock) CountTicketCommentsCalls() []struct {
	Ctx      context.Context
	TicketID types.TicketID
} {
	var calls []struct {
		Ctx      context.Context
		TicketID types.TicketID
	}
	mock.lockCountTicketComments.RLock()
	calls = mock.calls.CountTicketComments
	mock.lockCountTicketComments.RUnlock()
	return calls
}

// CountTicketsByStatus calls CountTicketsByStatusFunc.
func (mock *RepositoryMock) CountTicketsByStatus(ctx context.Context, statuses []types.TicketStatus) (int, error) {
	callInfo := struct {
		Ctx      context.Context
		Statuses []types.TicketStatus
	}{
		Ctx:      ctx,
		Statuses: statuses,
	}
	mock.lockCountTicketsByStatus.Lock()
	mock.calls.CountTicketsByStatus = append(mock.calls.CountTicketsByStatus, callInfo)
	mock.lockCountTicketsByStatus.Unlock()
	if mock.CountTicketsByStatusFunc == nil {
		var (
			nOut   int
			errOut error
		)
		return nOut, errOut
	}
	return mock.CountTicketsByStatusFunc(ctx, statuses)
}

// CountTicketsByStatusCalls gets all the calls that were made to CountTicketsByStatus.
// Check the length with:
//
//	len(mockedRepository.CountTicketsByStatusCalls())
func (mock *RepositoryMock) CountTicketsByStatusCalls() []struct {
	Ctx      context.Context
	Statuses []types.TicketStatus
} {
	var calls []struct {
		Ctx      context.Context
		Statuses []types.TicketStatus
	}
	mock.lockCountTicketsByStatus.RLock()
	calls = mock.calls.CountTicketsByStatus
	mock.lockCountTicketsByStatus.RUnlock()
	return calls
}

// CreateNotice calls CreateNoticeFunc.
func (mock *RepositoryMock) CreateNotice(ctx context.Context, noticeMoqParam *notice.Notice) error {
	callInfo := struct {
		Ctx            context.Context
		NoticeMoqParam *notice.Notice
	}{
		Ctx:            ctx,
		NoticeMoqParam: noticeMoqParam,
	}
	mock.lockCreateNotice.Lock()
	mock.calls.CreateNotice = append(mock.calls.CreateNotice, callInfo)
	mock.lockCreateNotice.Unlock()
	if mock.CreateNoticeFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.CreateNoticeFunc(ctx, noticeMoqParam)
}

// CreateNoticeCalls gets all the calls that were made to CreateNotice.
// Check the length with:
//
//	len(mockedRepository.CreateNoticeCalls())
func (mock *RepositoryMock) CreateNoticeCalls() []struct {
	Ctx            context.Context
	NoticeMoqParam *notice.Notice
} {
	var calls []struct {
		Ctx            context.Context
		NoticeMoqParam *notice.Notice
	}
	mock.lockCreateNotice.RLock()
	calls = mock.calls.CreateNotice
	mock.lockCreateNotice.RUnlock()
	return calls
}

// CreateTagWithID calls CreateTagWithIDFunc.
func (mock *RepositoryMock) CreateTagWithID(ctx context.Context, tagMoqParam *tag.Tag) error {
	callInfo := struct {
		Ctx         context.Context
		TagMoqParam *tag.Tag
	}{
		Ctx:         ctx,
		TagMoqParam: tagMoqParam,
	}
	mock.lockCreateTagWithID.Lock()
	mock.calls.CreateTagWithID = append(mock.calls.CreateTagWithID, callInfo)
	mock.lockCreateTagWithID.Unlock()
	if mock.CreateTagWithIDFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.CreateTagWithIDFunc(ctx, tagMoqParam)
}

// CreateTagWithIDCalls gets all the calls that were made to CreateTagWithID.
// Check the length with:
//
//	len(mockedRepository.CreateTagWithIDCalls())
func (mock *RepositoryMock) CreateTagWithIDCalls() []struct {
	Ctx         context.Context
	TagMoqParam *tag.Tag
} {
	var calls []struct {
		Ctx         context.Context
		TagMoqParam *tag.Tag
	}
	mock.lockCreateTagWithID.RLock()
	calls = mock.calls.CreateTagWithID
	mock.lockCreateTagWithID.RUnlock()
	return calls
}

// DeleteAgentMemoriesBatch calls DeleteAgentMemoriesBatchFunc.
func (mock *RepositoryMock) DeleteAgentMemoriesBatch(ctx context.Context, agentID string, memoryIDs []types.AgentMemoryID) (int, error) {
	callInfo := struct {
		Ctx       context.Context
		AgentID   string
		MemoryIDs []types.AgentMemoryID
	}{
		Ctx:       ctx,
		AgentID:   agentID,
		MemoryIDs: memoryIDs,
	}
	mock.lockDeleteAgentMemoriesBatch.Lock()
	mock.calls.DeleteAgentMemoriesBatch = append(mock.calls.DeleteAgentMemoriesBatch, callInfo)
	mock.lockDeleteAgentMemoriesBatch.Unlock()
	if mock.DeleteAgentMemoriesBatchFunc == nil {
		var (
			nOut   int
			errOut error
		)
		return nOut, errOut
	}
	return mock.DeleteAgentMemoriesBatchFunc(ctx, agentID, memoryIDs)
}

// DeleteAgentMemoriesBatchCalls gets all the calls that were made to DeleteAgentMemoriesBatch.
// Check the length with:
//
//	len(mockedRepository.DeleteAgentMemoriesBatchCalls())
func (mock *RepositoryMock) DeleteAgentMemoriesBatchCalls() []struct {
	Ctx       context.Context
	AgentID   string
	MemoryIDs []types.AgentMemoryID
} {
	var calls []struct {
		Ctx       context.Context
		AgentID   string
		MemoryIDs []types.AgentMemoryID
	}
	mock.lockDeleteAgentMemoriesBatch.RLock()
	calls = mock.calls.DeleteAgentMemoriesBatch
	mock.lockDeleteAgentMemoriesBatch.RUnlock()
	return calls
}

// DeleteSession calls DeleteSessionFunc.
func (mock *RepositoryMock) DeleteSession(ctx context.Context, sessionID types.SessionID) error {
	callInfo := struct {
		Ctx       context.Context
		SessionID types.SessionID
	}{
		Ctx:       ctx,
		SessionID: sessionID,
	}
	mock.lockDeleteSession.Lock()
	mock.calls.DeleteSession = append(mock.calls.DeleteSession, callInfo)
	mock.lockDeleteSession.Unlock()
	if mock.DeleteSessionFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.DeleteSessionFunc(ctx, sessionID)
}

// DeleteSessionCalls gets all the calls that were made to DeleteSession.
// Check the length with:
//
//	len(mockedRepository.DeleteSessionCalls())
func (mock *RepositoryMock) DeleteSessionCalls() []struct {
	Ctx       context.Context
	SessionID types.SessionID
} {
	var calls []struct {
		Ctx       context.Context
		SessionID types.SessionID
	}
	mock.lockDeleteSession.RLock()
	calls = mock.calls.DeleteSession
	mock.lockDeleteSession.RUnlock()
	return calls
}

// DeleteTagByID calls DeleteTagByIDFunc.
func (mock *RepositoryMock) DeleteTagByID(ctx context.Context, tagID string) error {
	callInfo := struct {
		Ctx   context.Context
		TagID string
	}{
		Ctx:   ctx,
		TagID: tagID,
	}
	mock.lockDeleteTagByID.Lock()
	mock.calls.DeleteTagByID = append(mock.calls.DeleteTagByID, callInfo)
	mock.lockDeleteTagByID.Unlock()
	if mock.DeleteTagByIDFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.DeleteTagByIDFunc(ctx, tagID)
}

// DeleteTagByIDCalls gets all the calls that were made to DeleteTagByID.
// Check the length with:
//
//	len(mockedRepository.DeleteTagByIDCalls())
func (mock *RepositoryMock) DeleteTagByIDCalls() []struct {
	Ctx   context.Context
	TagID string
} {
	var calls []struct {
		Ctx   context.Context
		TagID string
	}
	mock.lockDeleteTagByID.RLock()
	calls = mock.calls.DeleteTagByID
	mock.lockDeleteTagByID.RUnlock()
	return calls
}

// DeleteToken calls DeleteTokenFunc.
func (mock *RepositoryMock) DeleteToken(ctx context.Context, tokenID auth.TokenID) error {
	callInfo := struct {
		Ctx     context.Context
		TokenID auth.TokenID
	}{
		Ctx:     ctx,
		TokenID: tokenID,
	}
	mock.lockDeleteToken.Lock()
	mock.calls.DeleteToken = append(mock.calls.DeleteToken, callInfo)
	mock.lockDeleteToken.Unlock()
	if mock.DeleteTokenFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.DeleteTokenFunc(ctx, tokenID)
}

// DeleteTokenCalls gets all the calls that were made to DeleteToken.
// Check the length with:
//
//	len(mockedRepository.DeleteTokenCalls())
func (mock *RepositoryMock) DeleteTokenCalls() []struct {
	Ctx     context.Context
	TokenID auth.TokenID
} {
	var calls []struct {
		Ctx     context.Context
		TokenID auth.TokenID
	}
	mock.lockDeleteToken.RLock()
	calls = mock.calls.DeleteToken
	mock.lockDeleteToken.RUnlock()
	return calls
}

// FindNearestAlerts calls FindNearestAlertsFunc.
func (mock *RepositoryMock) FindNearestAlerts(ctx context.Context, embedding []float32, limit int) (alert.Alerts, error) {
	callInfo := struct {
		Ctx       context.Context
		Embedding []float32
		Limit     int
	}{
		Ctx:       ctx,
		Embedding: embedding,
		Limit:     limit,
	}
	mock.lockFindNearestAlerts.Lock()
	mock.calls.FindNearestAlerts = append(mock.calls.FindNearestAlerts, callInfo)
	mock.lockFindNearestAlerts.Unlock()
	if mock.FindNearestAlertsFunc == nil {
		var (
			alertsOut alert.Alerts
			errOut    error
		)
		return alertsOut, errOut
	}
	return mock.FindNearestAlertsFunc(ctx, embedding, limit)
}

// FindNearestAlertsCalls gets all the calls that were made to FindNearestAlerts.
// Check the length with:
//
//	len(mockedRepository.FindNearestAlertsCalls())
func (mock *RepositoryMock) FindNearestAlertsCalls() []struct {
	Ctx       context.Context
	Embedding []float32
	Limit     int
} {
	var calls []struct {
		Ctx       context.Context
		Embedding []float32
		Limit     int
	}
	mock.lockFindNearestAlerts.RLock()
	calls = mock.calls.FindNearestAlerts
	mock.lockFindNearestAlerts.RUnlock()
	return calls
}

// FindNearestTickets calls FindNearestTicketsFunc.
func (mock *RepositoryMock) FindNearestTickets(ctx context.Context, embedding []float32, limit int) ([]*ticket.Ticket, error) {
	callInfo := struct {
		Ctx       context.Context
		Embedding []float32
		Limit     int
	}{
		Ctx:       ctx,
		Embedding: embedding,
		Limit:     limit,
	}
	mock.lockFindNearestTickets.Lock()
	mock.calls.FindNearestTickets = append(mock.calls.FindNearestTickets, callInfo)
	mock.lockFindNearestTickets.Unlock()
	if mock.FindNearestTicketsFunc == nil {
		var (
			ticketsOut []*ticket.Ticket
			errOut     error
		)
		return ticketsOut, errOut
	}
	return mock.FindNearestTicketsFunc(ctx, embedding, limit)
}

// FindNearestTicketsCalls gets all the calls that were made to FindNearestTickets.
// Check the length with:
//
//	len(mockedRepository.FindNearestTicketsCalls())
func (mock *RepositoryMock) FindNearestTicketsCalls() []struct {
	Ctx       context.Context
	Embedding []float32
	Limit     int
} {
	var calls []struct {
		Ctx       context.Context
		Embedding []float32
		Limit     int
	}
	mock.lockFindNearestTickets.RLock()
	calls = mock.calls.FindNearestTickets
	mock.lockFindNearestTickets.RUnlock()
	return calls
}

// FindNearestTicketsWithSpan calls FindNearestTicketsWithSpanFunc.
func (mock *RepositoryMock) FindNearestTicketsWithSpan(ctx context.Context, embedding []float32, begin time.Time, end time.Time, limit int) ([]*ticket.Ticket, error) {
	callInfo := struct {
		Ctx       context.Context
		Embedding []float32
		Begin     time.Time
		End       time.Time
		Limit     int
	}{
		Ctx:       ctx,
		Embedding: embedding,
		Begin:     begin,
		End:       end,
		Limit:     limit,
	}
	mock.lockFindNearestTicketsWithSpan.Lock()
	mock.calls.FindNearestTicketsWithSpan = append(mock.calls.FindNearestTicketsWithSpan, callInfo)
	mock.lockFindNearestTicketsWithSpan.Unlock()
	if mock.FindNearestTicketsWithSpanFunc == nil {
		var (
			ticketsOut []*ticket.Ticket
			errOut     error
		)
		return ticketsOut, errOut
	}
	return mock.FindNearestTicketsWithSpanFunc(ctx, embedding, begin, end, limit)
}

// FindNearestTicketsWithSpanCalls gets all the calls that were made to FindNearestTicketsWithSpan.
// Check the length with:
//
//	len(mockedRepository.FindNearestTicketsWithSpanCalls())
func (mock *RepositoryMock) FindNearestTicketsWithSpanCalls() []struct {
	Ctx       context.Context
	Embedding []float32
	Begin     time.Time
	End       time.Time
	Limit     int
} {
	var calls []struct {
		Ctx       context.Context
		Embedding []float32
		Begin     time.Time
		End       time.Time
		Limit     int
	}
	mock.lockFindNearestTicketsWithSpan.RLock()
	calls = mock.calls.FindNearestTicketsWithSpan
	mock.lockFindNearestTicketsWithSpan.RUnlock()
	return calls
}

// GetActivities calls GetActivitiesFunc.
func (mock *RepositoryMock) GetActivities(ctx context.Context, offset int, limit int) ([]*activity.Activity, error) {
	callInfo := struct {
		Ctx    context.Context
		Offset int
		Limit  int
	}{
		Ctx:    ctx,
		Offset: offset,
		Limit:  limit,
	}
	mock.lockGetActivities.Lock()
	mock.calls.GetActivities = append(mock.calls.GetActivities, callInfo)
	mock.lockGetActivities.Unlock()
	if mock.GetActivitiesFunc == nil {
		var (
			activitysOut []*activity.Activity
			errOut       error
		)
		return activitysOut, errOut
	}
	return mock.GetActivitiesFunc(ctx, offset, limit)
}

// GetActivitiesCalls gets all the calls that were made to GetActivities.
// Check the length with:
//
//	len(mockedRepository.GetActivitiesCalls())
func (mock *RepositoryMock) GetActivitiesCalls() []struct {
	Ctx    context.Context
	Offset int
	Limit  int
} {
	var calls []struct {
		Ctx    context.Context
		Offset int
		Limit  int
	}
	mock.lockGetActivities.RLock()
	calls = mock.calls.GetActivities
	mock.lockGetActivities.RUnlock()
	return calls
}

// GetAgentMemory calls GetAgentMemoryFunc.
func (mock *RepositoryMock) GetAgentMemory(ctx context.Context, agentID string, id types.AgentMemoryID) (*memory.AgentMemory, error) {
	callInfo := struct {
		Ctx     context.Context
		AgentID string
		ID      types.AgentMemoryID
	}{
		Ctx:     ctx,
		AgentID: agentID,
		ID:      id,
	}
	mock.lockGetAgentMemory.Lock()
	mock.calls.GetAgentMemory = append(mock.calls.GetAgentMemory, callInfo)
	mock.lockGetAgentMemory.Unlock()
	if mock.GetAgentMemoryFunc == nil {
		var (
			agentMemoryOut *memory.AgentMemory
			errOut         error
		)
		return agentMemoryOut, errOut
	}
	return mock.GetAgentMemoryFunc(ctx, agentID, id)
}

// GetAgentMemoryCalls gets all the calls that were made to GetAgentMemory.
// Check the length with:
//
//	len(mockedRepository.GetAgentMemoryCalls())
func (mock *RepositoryMock) GetAgentMemoryCalls() []struct {
	Ctx     context.Context
	AgentID string
	ID      types.AgentMemoryID
} {
	var calls []struct {
		Ctx     context.Context
		AgentID string
		ID      types.AgentMemoryID
	}
	mock.lockGetAgentMemory.RLock()
	calls = mock.calls.GetAgentMemory
	mock.lockGetAgentMemory.RUnlock()
	return calls
}

// GetAlert calls GetAlertFunc.
func (mock *RepositoryMock) GetAlert(ctx context.Context, alertID types.AlertID) (*alert.Alert, error) {
	callInfo := struct {
		Ctx     context.Context
		AlertID types.AlertID
	}{
		Ctx:     ctx,
		AlertID: alertID,
	}
	mock.lockGetAlert.Lock()
	mock.calls.GetAlert = append(mock.calls.GetAlert, callInfo)
	mock.lockGetAlert.Unlock()
	if mock.GetAlertFunc == nil {
		var (
			alertOut *alert.Alert
			errOut   error
		)
		return alertOut, errOut
	}
	return mock.GetAlertFunc(ctx, alertID)
}

// GetAlertCalls gets all the calls that were made to GetAlert.
// Check the length with:
//
//	len(mockedRepository.GetAlertCalls())
func (mock *RepositoryMock) GetAlertCalls() []struct {
	Ctx     context.Context
	AlertID types.AlertID
} {
	var calls []struct {
		Ctx     context.Context
		AlertID types.AlertID
	}
	mock.lockGetAlert.RLock()
	calls = mock.calls.GetAlert
	mock.lockGetAlert.RUnlock()
	return calls
}

// GetAlertList calls GetAlertListFunc.
func (mock *RepositoryMock) GetAlertList(ctx context.Context, listID types.AlertListID) (*alert.List, error) {
	callInfo := struct {
		Ctx    context.Context
		ListID types.AlertListID
	}{
		Ctx:    ctx,
		ListID: listID,
	}
	mock.lockGetAlertList.Lock()
	mock.calls.GetAlertList = append(mock.calls.GetAlertList, callInfo)
	mock.lockGetAlertList.Unlock()
	if mock.GetAlertListFunc == nil {
		var (
			listOut *alert.List
			errOut  error
		)
		return listOut, errOut
	}
	return mock.GetAlertListFunc(ctx, listID)
}

// GetAlertListCalls gets all the calls that were made to GetAlertList.
// Check the length with:
//
//	len(mockedRepository.GetAlertListCalls())
func (mock *RepositoryMock) GetAlertListCalls() []struct {
	Ctx    context.Context
	ListID types.AlertListID
} {
	var calls []struct {
		Ctx    context.Context
		ListID types.AlertListID
	}
	mock.lockGetAlertList.RLock()
	calls = mock.calls.GetAlertList
	mock.lockGetAlertList.RUnlock()
	return calls
}

// GetAlertListByThread calls GetAlertListByThreadFunc.
func (mock *RepositoryMock) GetAlertListByThread(ctx context.Context, thread slack.Thread) (*alert.List, error) {
	callInfo := struct {
		Ctx    context.Context
		Thread slack.Thread
	}{
		Ctx:    ctx,
		Thread: thread,
	}
	mock.lockGetAlertListByThread.Lock()
	mock.calls.GetAlertListByThread = append(mock.calls.GetAlertListByThread, callInfo)
	mock.lockGetAlertListByThread.Unlock()
	if mock.GetAlertListByThreadFunc == nil {
		var (
			listOut *alert.List
			errOut  error
		)
		return listOut, errOut
	}
	return mock.GetAlertListByThreadFunc(ctx, thread)
}

// GetAlertListByThreadCalls gets all the calls that were made to GetAlertListByThread.
// Check the length with:
//
//	len(mockedRepository.GetAlertListByThreadCalls())
func (mock *RepositoryMock) GetAlertListByThreadCalls() []struct {
	Ctx    context.Context
	Thread slack.Thread
} {
	var calls []struct {
		Ctx    context.Context
		Thread slack.Thread
	}
	mock.lockGetAlertListByThread.RLock()
	calls = mock.calls.GetAlertListByThread
	mock.lockGetAlertListByThread.RUnlock()
	return calls
}

// GetAlertListsInThread calls GetAlertListsInThreadFunc.
func (mock *RepositoryMock) GetAlertListsInThread(ctx context.Context, thread slack.Thread) ([]*alert.List, error) {
	callInfo := struct {
		Ctx    context.Context
		Thread slack.Thread
	}{
		Ctx:    ctx,
		Thread: thread,
	}
	mock.lockGetAlertListsInThread.Lock()
	mock.calls.GetAlertListsInThread = append(mock.calls.GetAlertListsInThread, callInfo)
	mock.lockGetAlertListsInThread.Unlock()
	if mock.GetAlertListsInThreadFunc == nil {
		var (
			listsOut []*alert.List
			errOut   error
		)
		return listsOut, errOut
	}
	return mock.GetAlertListsInThreadFunc(ctx, thread)
}

// GetAlertListsInThreadCalls gets all the calls that were made to GetAlertListsInThread.
// Check the length with:
//
//	len(mockedRepository.GetAlertListsInThreadCalls())
func (mock *RepositoryMock) GetAlertListsInThreadCalls() []struct {
	Ctx    context.Context
	Thread slack.Thread
} {
	var calls []struct {
		Ctx    context.Context
		Thread slack.Thread
	}
	mock.lockGetAlertListsInThread.RLock()
	calls = mock.calls.GetAlertListsInThread
	mock.lockGetAlertListsInThread.RUnlock()
	return calls
}

// GetAlertWithoutEmbedding calls GetAlertWithoutEmbeddingFunc.
func (mock *RepositoryMock) GetAlertWithoutEmbedding(ctx context.Context) (alert.Alerts, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAlertWithoutEmbedding.Lock()
	mock.calls.GetAlertWithoutEmbedding = append(mock.calls.GetAlertWithoutEmbedding, callInfo)
	mock.lockGetAlertWithoutEmbedding.Unlock()
	if mock.GetAlertWithoutEmbeddingFunc == nil {
		var (
			alertsOut alert.Alerts
			errOut    error
		)
		return alertsOut, errOut
	}
	return mock.GetAlertWithoutEmbeddingFunc(ctx)
}

// GetAlertWithoutEmbeddingCalls gets all the calls that were made to GetAlertWithoutEmbedding.
// Check the length with:
//
//	len(mockedRepository.GetAlertWithoutEmbeddingCalls())
func (mock *RepositoryMock) GetAlertWithoutEmbeddingCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAlertWithoutEmbedding.RLock()
	calls = mock.calls.GetAlertWithoutEmbedding
	mock.lockGetAlertWithoutEmbedding.RUnlock()
	return calls
}

// GetAlertWithoutTicket calls GetAlertWithoutTicketFunc.
func (mock *RepositoryMock) GetAlertWithoutTicket(ctx context.Context, offset int, limit int) (alert.Alerts, error) {
	callInfo := struct {
		Ctx    context.Context
		Offset int
		Limit  int
	}{
		Ctx:    ctx,
		Offset: offset,
		Limit:  limit,
	}
	mock.lockGetAlertWithoutTicket.Lock()
	mock.calls.GetAlertWithoutTicket = append(mock.calls.GetAlertWithoutTicket, callInfo)
	mock.lockGetAlertWithoutTicket.Unlock()
	if mock.GetAlertWithoutTicketFunc == nil {
		var (
			alertsOut alert.Alerts
			errOut    error
		)
		return alertsOut, errOut
	}
	return mock.GetAlertWithoutTicketFunc(ctx, offset, limit)
}

// GetAlertWithoutTicketCalls gets all the calls that were made to GetAlertWithoutTicket.
// Check the length with:
//
//	len(mockedRepository.GetAlertWithoutTicketCalls())
func (mock *RepositoryMock) GetAlertWithoutTicketCalls() []struct {
	Ctx    context.Context
	Offset int
	Limit  int
} {
	var calls []struct {
		Ctx    context.Context
		Offset int
		Limit  int
	}
	mock.lockGetAlertWithoutTicket.RLock()
	calls = mock.calls.GetAlertWithoutTicket
	mock.lockGetAlertWithoutTicket.RUnlock()
	return calls
}

// GetAlertsBySpan calls GetAlertsBySpanFunc.
func (mock *RepositoryMock) GetAlertsBySpan(ctx context.Context, begin time.Time, end time.Time) (alert.Alerts, error) {
	callInfo := struct {
		Ctx   context.Context
		Begin time.Time
		End   time.Time
	}{
		Ctx:   ctx,
		Begin: begin,
		End:   end,
	}
	mock.lockGetAlertsBySpan.Lock()
	mock.calls.GetAlertsBySpan = append(mock.calls.GetAlertsBySpan, callInfo)
	mock.lockGetAlertsBySpan.Unlock()
	if mock.GetAlertsBySpanFunc == nil {
		var (
			alertsOut alert.Alerts
			errOut    error
		)
		return alertsOut, errOut
	}
	return mock.GetAlertsBySpanFunc(ctx, begin, end)
}

// GetAlertsBySpanCalls gets all the calls that were made to GetAlertsBySpan.
// Check the length with:
//
//	len(mockedRepository.GetAlertsBySpanCalls())
func (mock *RepositoryMock) GetAlertsBySpanCalls() []struct {
	Ctx   context.Context
	Begin time.Time
	End   time.Time
} {
	var calls []struct {
		Ctx   context.Context
		Begin time.Time
		End   time.Time
	}
	mock.lockGetAlertsBySpan.RLock()
	calls = mock.calls.GetAlertsBySpan
	mock.lockGetAlertsBySpan.RUnlock()
	return calls
}

// GetAlertsByThread calls GetAlertsByThreadFunc.
func (mock *RepositoryMock) GetAlertsByThread(ctx context.Context, thread slack.Thread) (alert.Alerts, error) {
	callInfo := struct {
		Ctx    context.Context
		Thread slack.Thread
	}{
		Ctx:    ctx,
		Thread: thread,
	}
	mock.lockGetAlertsByThread.Lock()
	mock.calls.GetAlertsByThread = append(mock.calls.GetAlertsByThread, callInfo)
	mock.lockGetAlertsByThread.Unlock()
	if mock.GetAlertsByThreadFunc == nil {
		var (
			alertsOut alert.Alerts
			errOut    error
		)
		return alertsOut, errOut
	}
	return mock.GetAlertsByThreadFunc(ctx, thread)
}

// GetAlertsByThreadCalls gets all the calls that were made to GetAlertsByThread.
// Check the length with:
//
//	len(mockedRepository.GetAlertsByThreadCalls())
func (mock *RepositoryMock) GetAlertsByThreadCalls() []struct {
	Ctx    context.Context
	Thread slack.Thread
} {
	var calls []struct {
		Ctx    context.Context
		Thread slack.Thread
	}
	mock.lockGetAlertsByThread.RLock()
	calls = mock.calls.GetAlertsByThread
	mock.lockGetAlertsByThread.RUnlock()
	return calls
}

// GetAlertsWithInvalidEmbedding calls GetAlertsWithInvalidEmbeddingFunc.
func (mock *RepositoryMock) GetAlertsWithInvalidEmbedding(ctx context.Context) (alert.Alerts, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAlertsWithInvalidEmbedding.Lock()
	mock.calls.GetAlertsWithInvalidEmbedding = append(mock.calls.GetAlertsWithInvalidEmbedding, callInfo)
	mock.lockGetAlertsWithInvalidEmbedding.Unlock()
	if mock.GetAlertsWithInvalidEmbeddingFunc == nil {
		var (
			alertsOut alert.Alerts
			errOut    error
		)
		return alertsOut, errOut
	}
	return mock.GetAlertsWithInvalidEmbeddingFunc(ctx)
}

// GetAlertsWithInvalidEmbeddingCalls gets all the calls that were made to GetAlertsWithInvalidEmbedding.
// Check the length with:
//
//	len(mockedRepository.GetAlertsWithInvalidEmbeddingCalls())
func (mock *RepositoryMock) GetAlertsWithInvalidEmbeddingCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAlertsWithInvalidEmbedding.RLock()
	calls = mock.calls.GetAlertsWithInvalidEmbedding
	mock.lockGetAlertsWithInvalidEmbedding.RUnlock()
	return calls
}

// GetKnowledge calls GetKnowledgeFunc.
func (mock *RepositoryMock) GetKnowledge(ctx context.Context, topic types.KnowledgeTopic, slug types.KnowledgeSlug) (*knowledge.Knowledge, error) {
	callInfo := struct {
		Ctx   context.Context
		Topic types.KnowledgeTopic
		Slug  types.KnowledgeSlug
	}{
		Ctx:   ctx,
		Topic: topic,
		Slug:  slug,
	}
	mock.lockGetKnowledge.Lock()
	mock.calls.GetKnowledge = append(mock.calls.GetKnowledge, callInfo)
	mock.lockGetKnowledge.Unlock()
	if mock.GetKnowledgeFunc == nil {
		var (
			knowledgeOut *knowledge.Knowledge
			errOut       error
		)
		return knowledgeOut, errOut
	}
	return mock.GetKnowledgeFunc(ctx, topic, slug)
}

// GetKnowledgeCalls gets all the calls that were made to GetKnowledge.
// Check the length with:
//
//	len(mockedRepository.GetKnowledgeCalls())
func (mock *RepositoryMock) GetKnowledgeCalls() []struct {
	Ctx   context.Context
	Topic types.KnowledgeTopic
	Slug  types.KnowledgeSlug
} {
	var calls []struct {
		Ctx   context.Context
		Topic types.KnowledgeTopic
		Slug  types.KnowledgeSlug
	}
	mock.lockGetKnowledge.RLock()
	calls = mock.calls.GetKnowledge
	mock.lockGetKnowledge.RUnlock()
	return calls
}

// GetKnowledgeByCommit calls GetKnowledgeByCommitFunc.
func (mock *RepositoryMock) GetKnowledgeByCommit(ctx context.Context, topic types.KnowledgeTopic, slug types.KnowledgeSlug, commitID string) (*knowledge.Knowledge, error) {
	callInfo := struct {
		Ctx      context.Context
		Topic    types.KnowledgeTopic
		Slug     types.KnowledgeSlug
		CommitID string
	}{
		Ctx:      ctx,
		Topic:    topic,
		Slug:     slug,
		CommitID: commitID,
	}
	mock.lockGetKnowledgeByCommit.Lock()
	mock.calls.GetKnowledgeByCommit = append(mock.calls.GetKnowledgeByCommit, callInfo)
	mock.lockGetKnowledgeByCommit.Unlock()
	if mock.GetKnowledgeByCommitFunc == nil {
		var (
			knowledgeOut *knowledge.Knowledge
			errOut       error
		)
		return knowledgeOut, errOut
	}
	return mock.GetKnowledgeByCommitFunc(ctx, topic, slug, commitID)
}

// GetKnowledgeByCommitCalls gets all the calls that were made to GetKnowledgeByCommit.
// Check the length with:
//
//	len(mockedRepository.GetKnowledgeByCommitCalls())
func (mock *RepositoryMock) GetKnowledgeByCommitCalls() []struct {
	Ctx      context.Context
	Topic    types.KnowledgeTopic
	Slug     types.KnowledgeSlug
	CommitID string
} {
	var calls []struct {
		Ctx      context.Context
		Topic    types.KnowledgeTopic
		Slug     types.KnowledgeSlug
		CommitID string
	}
	mock.lockGetKnowledgeByCommit.RLock()
	calls = mock.calls.GetKnowledgeByCommit
	mock.lockGetKnowledgeByCommit.RUnlock()
	return calls
}

// GetKnowledges calls GetKnowledgesFunc.
func (mock *RepositoryMock) GetKnowledges(ctx context.Context, topic types.KnowledgeTopic) ([]*knowledge.Knowledge, error) {
	callInfo := struct {
		Ctx   context.Context
		Topic types.KnowledgeTopic
	}{
		Ctx:   ctx,
		Topic: topic,
	}
	mock.lockGetKnowledges.Lock()
	mock.calls.GetKnowledges = append(mock.calls.GetKnowledges, callInfo)
	mock.lockGetKnowledges.Unlock()
	if mock.GetKnowledgesFunc == nil {
		var (
			knowledgesOut []*knowledge.Knowledge
			errOut        error
		)
		return knowledgesOut, errOut
	}
	return mock.GetKnowledgesFunc(ctx, topic)
}

// GetKnowledgesCalls gets all the calls that were made to GetKnowledges.
// Check the length with:
//
//	len(mockedRepository.GetKnowledgesCalls())
func (mock *RepositoryMock) GetKnowledgesCalls() []struct {
	Ctx   context.Context
	Topic types.KnowledgeTopic
} {
	var calls []struct {
		Ctx   context.Context
		Topic types.KnowledgeTopic
	}
	mock.lockGetKnowledges.RLock()
	calls = mock.calls.GetKnowledges
	mock.lockGetKnowledges.RUnlock()
	return calls
}

// GetLatestAlertByThread calls GetLatestAlertByThreadFunc.
func (mock *RepositoryMock) GetLatestAlertByThread(ctx context.Context, thread slack.Thread) (*alert.Alert, error) {
	callInfo := struct {
		Ctx    context.Context
		Thread slack.Thread
	}{
		Ctx:    ctx,
		Thread: thread,
	}
	mock.lockGetLatestAlertByThread.Lock()
	mock.calls.GetLatestAlertByThread = append(mock.calls.GetLatestAlertByThread, callInfo)
	mock.lockGetLatestAlertByThread.Unlock()
	if mock.GetLatestAlertByThreadFunc == nil {
		var (
			alertOut *alert.Alert
			errOut   error
		)
		return alertOut, errOut
	}
	return mock.GetLatestAlertByThreadFunc(ctx, thread)
}

// GetLatestAlertByThreadCalls gets all the calls that were made to GetLatestAlertByThread.
// Check the length with:
//
//	len(mockedRepository.GetLatestAlertByThreadCalls())
func (mock *RepositoryMock) GetLatestAlertByThreadCalls() []struct {
	Ctx    context.Context
	Thread slack.Thread
} {
	var calls []struct {
		Ctx    context.Context
		Thread slack.Thread
	}
	mock.lockGetLatestAlertByThread.RLock()
	calls = mock.calls.GetLatestAlertByThread
	mock.lockGetLatestAlertByThread.RUnlock()
	return calls
}

// GetLatestAlertListInThread calls GetLatestAlertListInThreadFunc.
func (mock *RepositoryMock) GetLatestAlertListInThread(ctx context.Context, thread slack.Thread) (*alert.List, error) {
	callInfo := struct {
		Ctx    context.Context
		Thread slack.Thread
	}{
		Ctx:    ctx,
		Thread: thread,
	}
	mock.lockGetLatestAlertListInThread.Lock()
	mock.calls.GetLatestAlertListInThread = append(mock.calls.GetLatestAlertListInThread, callInfo)
	mock.lockGetLatestAlertListInThread.Unlock()
	if mock.GetLatestAlertListInThreadFunc == nil {
		var (
			listOut *alert.List
			errOut  error
		)
		return listOut, errOut
	}
	return mock.GetLatestAlertListInThreadFunc(ctx, thread)
}

// GetLatestAlertListInThreadCalls gets all the calls that were made to GetLatestAlertListInThread.
// Check the length with:
//
//	len(mockedRepository.GetLatestAlertListInThreadCalls())
func (mock *RepositoryMock) GetLatestAlertListInThreadCalls() []struct {
	Ctx    context.Context
	Thread slack.Thread
} {
	var calls []struct {
		Ctx    context.Context
		Thread slack.Thread
	}
	mock.lockGetLatestAlertListInThread.RLock()
	calls = mock.calls.GetLatestAlertListInThread
	mock.lockGetLatestAlertListInThread.RUnlock()
	return calls
}

// GetLatestHistory calls GetLatestHistoryFunc.
func (mock *RepositoryMock) GetLatestHistory(ctx context.Context, ticketID types.TicketID) (*ticket.History, error) {
	callInfo := struct {
		Ctx      context.Context
		TicketID types.TicketID
	}{
		Ctx:      ctx,
		TicketID: ticketID,
	}
	mock.lockGetLatestHistory.Lock()
	mock.calls.GetLatestHistory = append(mock.calls.GetLatestHistory, callInfo)
	mock.lockGetLatestHistory.Unlock()
	if mock.GetLatestHistoryFunc == nil {
		var (
			historyOut *ticket.History
			errOut     error
		)
		return historyOut, errOut
	}
	return mock.GetLatestHistoryFunc(ctx, ticketID)
}

// GetLatestHistoryCalls gets all the calls that were made to GetLatestHistory.
// Check the length with:
//
//	len(mockedRepository.GetLatestHistoryCalls())
func (mock *RepositoryMock) GetLatestHistoryCalls() []struct {
	Ctx      context.Context
	TicketID types.TicketID
} {
	var calls []struct {
		Ctx      context.Context
		TicketID types.TicketID
	}
	mock.lockGetLatestHistory.RLock()
	calls = mock.calls.GetLatestHistory
	mock.lockGetLatestHistory.RUnlock()
	return calls
}

// GetNotice calls GetNoticeFunc.
func (mock *RepositoryMock) GetNotice(ctx context.Context, id types.NoticeID) (*notice.Notice, error) {
	callInfo := struct {
		Ctx context.Context
		ID  types.NoticeID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetNotice.Lock()
	mock.calls.GetNotice = append(mock.calls.GetNotice, callInfo)
	mock.lockGetNotice.Unlock()
	if mock.GetNoticeFunc == nil {
		var (
			noticeOut *notice.Notice
			errOut    error
		)
		return noticeOut, errOut
	}
	return mock.GetNoticeFunc(ctx, id)
}

// GetNoticeCalls gets all the calls that were made to GetNotice.
// Check the length with:
//
//	len(mockedRepository.GetNoticeCalls())
func (mock *RepositoryMock) GetNoticeCalls() []struct {
	Ctx context.Context
	ID  types.NoticeID
} {
	var calls []struct {
		Ctx context.Context
		ID  types.NoticeID
	}
	mock.lockGetNotice.RLock()
	calls = mock.calls.GetNotice
	mock.lockGetNotice.RUnlock()
	return calls
}

// GetOrCreateTagByName calls GetOrCreateTagByNameFunc.
func (mock *RepositoryMock) GetOrCreateTagByName(ctx context.Context, name string, description string, color string, createdBy string) (*tag.Tag, error) {
	callInfo := struct {
		Ctx         context.Context
		Name        string
		Description string
		Color       string
		CreatedBy   string
	}{
		Ctx:         ctx,
		Name:        name,
		Description: description,
		Color:       color,
		CreatedBy:   createdBy,
	}
	mock.lockGetOrCreateTagByName.Lock()
	mock.calls.GetOrCreateTagByName = append(mock.calls.GetOrCreateTagByName, callInfo)
	mock.lockGetOrCreateTagByName.Unlock()
	if mock.GetOrCreateTagByNameFunc == nil {
		var (
			tagOut *tag.Tag
			errOut error
		)
		return tagOut, errOut
	}
	return mock.GetOrCreateTagByNameFunc(ctx, name, description, color, createdBy)
}

// GetOrCreateTagByNameCalls gets all the calls that were made to GetOrCreateTagByName.
// Check the length with:
//
//	len(mockedRepository.GetOrCreateTagByNameCalls())
func (mock *RepositoryMock) GetOrCreateTagByNameCalls() []struct {
	Ctx         context.Context
	Name        string
	Description string
	Color       string
	CreatedBy   string
} {
	var calls []struct {
		Ctx         context.Context
		Name        string
		Description string
		Color       string
		CreatedBy   string
	}
	mock.lockGetOrCreateTagByName.RLock()
	calls = mock.calls.GetOrCreateTagByName
	mock.lockGetOrCreateTagByName.RUnlock()
	return calls
}

// GetSession calls GetSessionFunc.
func (mock *RepositoryMock) GetSession(ctx context.Context, sessionID types.SessionID) (*session.Session, error) {
	callInfo := struct {
		Ctx       context.Context
		SessionID types.SessionID
	}{
		Ctx:       ctx,
		SessionID: sessionID,
	}
	mock.lockGetSession.Lock()
	mock.calls.GetSession = append(mock.calls.GetSession, callInfo)
	mock.lockGetSession.Unlock()
	if mock.GetSessionFunc == nil {
		var (
			sessionOut *session.Session
			errOut     error
		)
		return sessionOut, errOut
	}
	return mock.GetSessionFunc(ctx, sessionID)
}

// GetSessionCalls gets all the calls that were made to GetSession.
// Check the length with:
//
//	len(mockedRepository.GetSessionCalls())
func (mock *RepositoryMock) GetSessionCalls() []struct {
	Ctx       context.Context
	SessionID types.SessionID
} {
	var calls []struct {
		Ctx       context.Context
		SessionID types.SessionID
	}
	mock.lockGetSession.RLock()
	calls = mock.calls.GetSession
	mock.lockGetSession.RUnlock()
	return calls
}

// GetSessionsByTicket calls GetSessionsByTicketFunc.
func (mock *RepositoryMock) GetSessionsByTicket(ctx context.Context, ticketID types.TicketID) ([]*session.Session, error) {
	callInfo := struct {
		Ctx      context.Context
		TicketID types.TicketID
	}{
		Ctx:      ctx,
		TicketID: ticketID,
	}
	mock.lockGetSessionsByTicket.Lock()
	mock.calls.GetSessionsByTicket = append(mock.calls.GetSessionsByTicket, callInfo)
	mock.lockGetSessionsByTicket.Unlock()
	if mock.GetSessionsByTicketFunc == nil {
		var (
			sessionsOut []*session.Session
			errOut      error
		)
		return sessionsOut, errOut
	}
	return mock.GetSessionsByTicketFunc(ctx, ticketID)
}

// GetSessionsByTicketCalls gets all the calls that were made to GetSessionsByTicket.
// Check the length with:
//
//	len(mockedRepository.GetSessionsByTicketCalls())
func (mock *RepositoryMock) GetSessionsByTicketCalls() []struct {
	Ctx      context.Context
	TicketID types.TicketID
} {
	var calls []struct {
		Ctx      context.Context
		TicketID types.TicketID
	}
	mock.lockGetSessionsByTicket.RLock()
	calls = mock.calls.GetSessionsByTicket
	mock.lockGetSessionsByTicket.RUnlock()
	return calls
}

// GetTagByID calls GetTagByIDFunc.
func (mock *RepositoryMock) GetTagByID(ctx context.Context, tagID string) (*tag.Tag, error) {
	callInfo := struct {
		Ctx   context.Context
		TagID string
	}{
		Ctx:   ctx,
		TagID: tagID,
	}
	mock.lockGetTagByID.Lock()
	mock.calls.GetTagByID = append(mock.calls.GetTagByID, callInfo)
	mock.lockGetTagByID.Unlock()
	if mock.GetTagByIDFunc == nil {
		var (
			tagOut *tag.Tag
			errOut error
		)
		return tagOut, errOut
	}
	return mock.GetTagByIDFunc(ctx, tagID)
}

// GetTagByIDCalls gets all the calls that were made to GetTagByID.
// Check the length with:
//
//	len(mockedRepository.GetTagByIDCalls())
func (mock *RepositoryMock) GetTagByIDCalls() []struct {
	Ctx   context.Context
	TagID string
} {
	var calls []struct {
		Ctx   context.Context
		TagID string
	}
	mock.lockGetTagByID.RLock()
	calls = mock.calls.GetTagByID
	mock.lockGetTagByID.RUnlock()
	return calls
}

// GetTagByName calls GetTagByNameFunc.
func (mock *RepositoryMock) GetTagByName(ctx context.Context, name string) (*tag.Tag, error) {
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockGetTagByName.Lock()
	mock.calls.GetTagByName = append(mock.calls.GetTagByName, callInfo)
	mock.lockGetTagByName.Unlock()
	if mock.GetTagByNameFunc == nil {
		var (
			tagOut *tag.Tag
			errOut error
		)
		return tagOut, errOut
	}
	return mock.GetTagByNameFunc(ctx, name)
}

// GetTagByNameCalls gets all the calls that were made to GetTagByName.
// Check the length with:
//
//	len(mockedRepository.GetTagByNameCalls())
func (mock *RepositoryMock) GetTagByNameCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	mock.lockGetTagByName.RLock()
	calls = mock.calls.GetTagByName
	mock.lockGetTagByName.RUnlock()
	return calls
}

// GetTagsByIDs calls GetTagsByIDsFunc.
func (mock *RepositoryMock) GetTagsByIDs(ctx context.Context, tagIDs []string) ([]*tag.Tag, error) {
	callInfo := struct {
		Ctx    context.Context
		TagIDs []string
	}{
		Ctx:    ctx,
		TagIDs: tagIDs,
	}
	mock.lockGetTagsByIDs.Lock()
	mock.calls.GetTagsByIDs = append(mock.calls.GetTagsByIDs, callInfo)
	mock.lockGetTagsByIDs.Unlock()
	if mock.GetTagsByIDsFunc == nil {
		var (
			tagsOut []*tag.Tag
			errOut  error
		)
		return tagsOut, errOut
	}
	return mock.GetTagsByIDsFunc(ctx, tagIDs)
}

// GetTagsByIDsCalls gets all the calls that were made to GetTagsByIDs.
// Check the length with:
//
//	len(mockedRepository.GetTagsByIDsCalls())
func (mock *RepositoryMock) GetTagsByIDsCalls() []struct {
	Ctx    context.Context
	TagIDs []string
} {
	var calls []struct {
		Ctx    context.Context
		TagIDs []string
	}
	mock.lockGetTagsByIDs.RLock()
	calls = mock.calls.GetTagsByIDs
	mock.lockGetTagsByIDs.RUnlock()
	return calls
}

// GetTicket calls GetTicketFunc.
func (mock *RepositoryMock) GetTicket(ctx context.Context, ticketID types.TicketID) (*ticket.Ticket, error) {
	callInfo := struct {
		Ctx      context.Context
		TicketID types.TicketID
	}{
		Ctx:      ctx,
		TicketID: ticketID,
	}
	mock.lockGetTicket.Lock()
	mock.calls.GetTicket = append(mock.calls.GetTicket, callInfo)
	mock.lockGetTicket.Unlock()
	if mock.GetTicketFunc == nil {
		var (
			ticketOut *ticket.Ticket
			errOut    error
		)
		return ticketOut, errOut
	}
	return mock.GetTicketFunc(ctx, ticketID)
}

// GetTicketCalls gets all the calls that were made to GetTicket.
// Check the length with:
//
//	len(mockedRepository.GetTicketCalls())
func (mock *RepositoryMock) GetTicketCalls() []struct {
	Ctx      context.Context
	TicketID types.TicketID
} {
	var calls []struct {
		Ctx      context.Context
		TicketID types.TicketID
	}
	mock.lockGetTicket.RLock()
	calls = mock.calls.GetTicket
	mock.lockGetTicket.RUnlock()
	return calls
}

// GetTicketByThread calls GetTicketByThreadFunc.
func (mock *RepositoryMock) GetTicketByThread(ctx context.Context, thread slack.Thread) (*ticket.Ticket, error) {
	callInfo := struct {
		Ctx    context.Context
		Thread slack.Thread
	}{
		Ctx:    ctx,
		Thread: thread,
	}
	mock.lockGetTicketByThread.Lock()
	mock.calls.GetTicketByThread = append(mock.calls.GetTicketByThread, callInfo)
	mock.lockGetTicketByThread.Unlock()
	if mock.GetTicketByThreadFunc == nil {
		var (
			ticketOut *ticket.Ticket
			errOut    error
		)
		return ticketOut, errOut
	}
	return mock.GetTicketByThreadFunc(ctx, thread)
}

// GetTicketByThreadCalls gets all the calls that were made to GetTicketByThread.
// Check the length with:
//
//	len(mockedRepository.GetTicketByThreadCalls())
func (mock *RepositoryMock) GetTicketByThreadCalls() []struct {
	Ctx    context.Context
	Thread slack.Thread
} {
	var calls []struct {
		Ctx    context.Context
		Thread slack.Thread
	}
	mock.lockGetTicketByThread.RLock()
	calls = mock.calls.GetTicketByThread
	mock.lockGetTicketByThread.RUnlock()
	return calls
}

// GetTicketComments calls GetTicketCommentsFunc.
func (mock *RepositoryMock) GetTicketComments(ctx context.Context, ticketID types.TicketID) ([]ticket.Comment, error) {
	callInfo := struct {
		Ctx      context.Context
		TicketID types.TicketID
	}{
		Ctx:      ctx,
		TicketID: ticketID,
	}
	mock.lockGetTicketComments.Lock()
	mock.calls.GetTicketComments = append(mock.calls.GetTicketComments, callInfo)
	mock.lockGetTicketComments.Unlock()
	if mock.GetTicketCommentsFunc == nil {
		var (
			commentsOut []ticket.Comment
			errOut      error
		)
		return commentsOut, errOut
	}
	return mock.GetTicketCommentsFunc(ctx, ticketID)
}

// GetTicketCommentsCalls gets all the calls that were made to GetTicketComments.
// Check the length with:
//
//	len(mockedRepository.GetTicketCommentsCalls())
func (mock *RepositoryMock) GetTicketCommentsCalls() []struct {
	Ctx      context.Context
	TicketID types.TicketID
} {
	var calls []struct {
		Ctx      context.Context
		TicketID types.TicketID
	}
	mock.lockGetTicketComments.RLock()
	calls = mock.calls.GetTicketComments
	mock.lockGetTicketComments.RUnlock()
	return calls
}

// GetTicketCommentsPaginated calls GetTicketCommentsPaginatedFunc.
func (mock *RepositoryMock) GetTicketCommentsPaginated(ctx context.Context, ticketID types.TicketID, offset int, limit int) ([]ticket.Comment, error) {
	callInfo := struct {
		Ctx      context.Context
		TicketID types.TicketID
		Offset   int
		Limit    int
	}{
		Ctx:      ctx,
		TicketID: ticketID,
		Offset:   offset,
		Limit:    limit,
	}
	mock.lockGetTicketCommentsPaginated.Lock()
	mock.calls.GetTicketCommentsPaginated = append(mock.calls.GetTicketCommentsPaginated, callInfo)
	mock.lockGetTicketCommentsPaginated.Unlock()
	if mock.GetTicketCommentsPaginatedFunc == nil {
		var (
			commentsOut []ticket.Comment
			errOut      error
		)
		return commentsOut, errOut
	}
	return mock.GetTicketCommentsPaginatedFunc(ctx, ticketID, offset, limit)
}

// GetTicketCommentsPaginatedCalls gets all the calls that were made to GetTicketCommentsPaginated.
// Check the length with:
//
//	len(mockedRepository.GetTicketCommentsPaginatedCalls())
func (mock *RepositoryMock) GetTicketCommentsPaginatedCalls() []struct {
	Ctx      context.Context
	TicketID types.TicketID
	Offset   int
	Limit    int
} {
	var calls []struct {
		Ctx      context.Context
		TicketID types.TicketID
		Offset   int
		Limit    int
	}
	mock.lockGetTicketCommentsPaginated.RLock()
	calls = mock.calls.GetTicketCommentsPaginated
	mock.lockGetTicketCommentsPaginated.RUnlock()
	return calls
}

// GetTicketUnpromptedComments calls GetTicketUnpromptedCommentsFunc.
func (mock *RepositoryMock) GetTicketUnpromptedComments(ctx context.Context, ticketID types.TicketID) ([]ticket.Comment, error) {
	callInfo := struct {
		Ctx      context.Context
		TicketID types.TicketID
	}{
		Ctx:      ctx,
		TicketID: ticketID,
	}
	mock.lockGetTicketUnpromptedComments.Lock()
	mock.calls.GetTicketUnpromptedComments = append(mock.calls.GetTicketUnpromptedComments, callInfo)
	mock.lockGetTicketUnpromptedComments.Unlock()
	if mock.GetTicketUnpromptedCommentsFunc == nil {
		var (
			commentsOut []ticket.Comment
			errOut      error
		)
		return commentsOut, errOut
	}
	return mock.GetTicketUnpromptedCommentsFunc(ctx, ticketID)
}

// GetTicketUnpromptedCommentsCalls gets all the calls that were made to GetTicketUnpromptedComments.
// Check the length with:
//
//	len(mockedRepository.GetTicketUnpromptedCommentsCalls())
func (mock *RepositoryMock) GetTicketUnpromptedCommentsCalls() []struct {
	Ctx      context.Context
	TicketID types.TicketID
} {
	var calls []struct {
		Ctx      context.Context
		TicketID types.TicketID
	}
	mock.lockGetTicketUnpromptedComments.RLock()
	calls = mock.calls.GetTicketUnpromptedComments
	mock.lockGetTicketUnpromptedComments.RUnlock()
	return calls
}

// GetTicketsBySpan calls GetTicketsBySpanFunc.
func (mock *RepositoryMock) GetTicketsBySpan(ctx context.Context, begin time.Time, end time.Time) ([]*ticket.Ticket, error) {
	callInfo := struct {
		Ctx   context.Context
		Begin time.Time
		End   time.Time
	}{
		Ctx:   ctx,
		Begin: begin,
		End:   end,
	}
	mock.lockGetTicketsBySpan.Lock()
	mock.calls.GetTicketsBySpan = append(mock.calls.GetTicketsBySpan, callInfo)
	mock.lockGetTicketsBySpan.Unlock()
	if mock.GetTicketsBySpanFunc == nil {
		var (
			ticketsOut []*ticket.Ticket
			errOut     error
		)
		return ticketsOut, errOut
	}
	return mock.GetTicketsBySpanFunc(ctx, begin, end)
}

// GetTicketsBySpanCalls gets all the calls that were made to GetTicketsBySpan.
// Check the length with:
//
//	len(mockedRepository.GetTicketsBySpanCalls())
func (mock *RepositoryMock) GetTicketsBySpanCalls() []struct {
	Ctx   context.Context
	Begin time.Time
	End   time.Time
} {
	var calls []struct {
		Ctx   context.Context
		Begin time.Time
		End   time.Time
	}
	mock.lockGetTicketsBySpan.RLock()
	calls = mock.calls.GetTicketsBySpan
	mock.lockGetTicketsBySpan.RUnlock()
	return calls
}

// GetTicketsByStatus calls GetTicketsByStatusFunc.
func (mock *RepositoryMock) GetTicketsByStatus(ctx context.Context, statuses []types.TicketStatus, offset int, limit int) ([]*ticket.Ticket, error) {
	callInfo := struct {
		Ctx      context.Context
		Statuses []types.TicketStatus
		Offset   int
		Limit    int
	}{
		Ctx:      ctx,
		Statuses: statuses,
		Offset:   offset,
		Limit:    limit,
	}
	mock.lockGetTicketsByStatus.Lock()
	mock.calls.GetTicketsByStatus = append(mock.calls.GetTicketsByStatus, callInfo)
	mock.lockGetTicketsByStatus.Unlock()
	if mock.GetTicketsByStatusFunc == nil {
		var (
			ticketsOut []*ticket.Ticket
			errOut     error
		)
		return ticketsOut, errOut
	}
	return mock.GetTicketsByStatusFunc(ctx, statuses, offset, limit)
}

// GetTicketsByStatusCalls gets all the calls that were made to GetTicketsByStatus.
// Check the length with:
//
//	len(mockedRepository.GetTicketsByStatusCalls())
func (mock *RepositoryMock) GetTicketsByStatusCalls() []struct {
	Ctx      context.Context
	Statuses []types.TicketStatus
	Offset   int
	Limit    int
} {
	var calls []struct {
		Ctx      context.Context
		Statuses []types.TicketStatus
		Offset   int
		Limit    int
	}
	mock.lockGetTicketsByStatus.RLock()
	calls = mock.calls.GetTicketsByStatus
	mock.lockGetTicketsByStatus.RUnlock()
	return calls
}

// GetTicketsByStatusAndSpan calls GetTicketsByStatusAndSpanFunc.
func (mock *RepositoryMock) GetTicketsByStatusAndSpan(ctx context.Context, status types.TicketStatus, begin time.Time, end time.Time) ([]*ticket.Ticket, error) {
	callInfo := struct {
		Ctx    context.Context
		Status types.TicketStatus
		Begin  time.Time
		End    time.Time
	}{
		Ctx:    ctx,
		Status: status,
		Begin:  begin,
		End:    end,
	}
	mock.lockGetTicketsByStatusAndSpan.Lock()
	mock.calls.GetTicketsByStatusAndSpan = append(mock.calls.GetTicketsByStatusAndSpan, callInfo)
	mock.lockGetTicketsByStatusAndSpan.Unlock()
	if mock.GetTicketsByStatusAndSpanFunc == nil {
		var (
			ticketsOut []*ticket.Ticket
			errOut     error
		)
		return ticketsOut, errOut
	}
	return mock.GetTicketsByStatusAndSpanFunc(ctx, status, begin, end)
}

// GetTicketsByStatusAndSpanCalls gets all the calls that were made to GetTicketsByStatusAndSpan.
// Check the length with:
//
//	len(mockedRepository.GetTicketsByStatusAndSpanCalls())
func (mock *RepositoryMock) GetTicketsByStatusAndSpanCalls() []struct {
	Ctx    context.Context
	Status types.TicketStatus
	Begin  time.Time
	End    time.Time
} {
	var calls []struct {
		Ctx    context.Context
		Status types.TicketStatus
		Begin  time.Time
		End    time.Time
	}
	mock.lockGetTicketsByStatusAndSpan.RLock()
	calls = mock.calls.GetTicketsByStatusAndSpan
	mock.lockGetTicketsByStatusAndSpan.RUnlock()
	return calls
}

// GetTicketsWithInvalidEmbedding calls GetTicketsWithInvalidEmbeddingFunc.
func (mock *RepositoryMock) GetTicketsWithInvalidEmbedding(ctx context.Context) ([]*ticket.Ticket, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetTicketsWithInvalidEmbedding.Lock()
	mock.calls.GetTicketsWithInvalidEmbedding = append(mock.calls.GetTicketsWithInvalidEmbedding, callInfo)
	mock.lockGetTicketsWithInvalidEmbedding.Unlock()
	if mock.GetTicketsWithInvalidEmbeddingFunc == nil {
		var (
			ticketsOut []*ticket.Ticket
			errOut     error
		)
		return ticketsOut, errOut
	}
	return mock.GetTicketsWithInvalidEmbeddingFunc(ctx)
}

// GetTicketsWithInvalidEmbeddingCalls gets all the calls that were made to GetTicketsWithInvalidEmbedding.
// Check the length with:
//
//	len(mockedRepository.GetTicketsWithInvalidEmbeddingCalls())
func (mock *RepositoryMock) GetTicketsWithInvalidEmbeddingCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetTicketsWithInvalidEmbedding.RLock()
	calls = mock.calls.GetTicketsWithInvalidEmbedding
	mock.lockGetTicketsWithInvalidEmbedding.RUnlock()
	return calls
}

// GetToken calls GetTokenFunc.
func (mock *RepositoryMock) GetToken(ctx context.Context, tokenID auth.TokenID) (*auth.Token, error) {
	callInfo := struct {
		Ctx     context.Context
		TokenID auth.TokenID
	}{
		Ctx:     ctx,
		TokenID: tokenID,
	}
	mock.lockGetToken.Lock()
	mock.calls.GetToken = append(mock.calls.GetToken, callInfo)
	mock.lockGetToken.Unlock()
	if mock.GetTokenFunc == nil {
		var (
			tokenOut *auth.Token
			errOut   error
		)
		return tokenOut, errOut
	}
	return mock.GetTokenFunc(ctx, tokenID)
}

// GetTokenCalls gets all the calls that were made to GetToken.
// Check the length with:
//
//	len(mockedRepository.GetTokenCalls())
func (mock *RepositoryMock) GetTokenCalls() []struct {
	Ctx     context.Context
	TokenID auth.TokenID
} {
	var calls []struct {
		Ctx     context.Context
		TokenID auth.TokenID
	}
	mock.lockGetToken.RLock()
	calls = mock.calls.GetToken
	mock.lockGetToken.RUnlock()
	return calls
}

// IsTagNameExists calls IsTagNameExistsFunc.
func (mock *RepositoryMock) IsTagNameExists(ctx context.Context, name string) (bool, error) {
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockIsTagNameExists.Lock()
	mock.calls.IsTagNameExists = append(mock.calls.IsTagNameExists, callInfo)
	mock.lockIsTagNameExists.Unlock()
	if mock.IsTagNameExistsFunc == nil {
		var (
			bOut   bool
			errOut error
		)
		return bOut, errOut
	}
	return mock.IsTagNameExistsFunc(ctx, name)
}

// IsTagNameExistsCalls gets all the calls that were made to IsTagNameExists.
// Check the length with:
//
//	len(mockedRepository.IsTagNameExistsCalls())
func (mock *RepositoryMock) IsTagNameExistsCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	mock.lockIsTagNameExists.RLock()
	calls = mock.calls.IsTagNameExists
	mock.lockIsTagNameExists.RUnlock()
	return calls
}

// ListAgentMemories calls ListAgentMemoriesFunc.
func (mock *RepositoryMock) ListAgentMemories(ctx context.Context, agentID string) ([]*memory.AgentMemory, error) {
	callInfo := struct {
		Ctx     context.Context
		AgentID string
	}{
		Ctx:     ctx,
		AgentID: agentID,
	}
	mock.lockListAgentMemories.Lock()
	mock.calls.ListAgentMemories = append(mock.calls.ListAgentMemories, callInfo)
	mock.lockListAgentMemories.Unlock()
	if mock.ListAgentMemoriesFunc == nil {
		var (
			agentMemorysOut []*memory.AgentMemory
			errOut          error
		)
		return agentMemorysOut, errOut
	}
	return mock.ListAgentMemoriesFunc(ctx, agentID)
}

// ListAgentMemoriesCalls gets all the calls that were made to ListAgentMemories.
// Check the length with:
//
//	len(mockedRepository.ListAgentMemoriesCalls())
func (mock *RepositoryMock) ListAgentMemoriesCalls() []struct {
	Ctx     context.Context
	AgentID string
} {
	var calls []struct {
		Ctx     context.Context
		AgentID string
	}
	mock.lockListAgentMemories.RLock()
	calls = mock.calls.ListAgentMemories
	mock.lockListAgentMemories.RUnlock()
	return calls
}

// ListAllTags calls ListAllTagsFunc.
func (mock *RepositoryMock) ListAllTags(ctx context.Context) ([]*tag.Tag, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListAllTags.Lock()
	mock.calls.ListAllTags = append(mock.calls.ListAllTags, callInfo)
	mock.lockListAllTags.Unlock()
	if mock.ListAllTagsFunc == nil {
		var (
			tagsOut []*tag.Tag
			errOut  error
		)
		return tagsOut, errOut
	}
	return mock.ListAllTagsFunc(ctx)
}

// ListAllTagsCalls gets all the calls that were made to ListAllTags.
// Check the length with:
//
//	len(mockedRepository.ListAllTagsCalls())
func (mock *RepositoryMock) ListAllTagsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListAllTags.RLock()
	calls = mock.calls.ListAllTags
	mock.lockListAllTags.RUnlock()
	return calls
}

// ListKnowledgeSlugs calls ListKnowledgeSlugsFunc.
func (mock *RepositoryMock) ListKnowledgeSlugs(ctx context.Context, topic types.KnowledgeTopic) ([]*knowledge.SlugInfo, error) {
	callInfo := struct {
		Ctx   context.Context
		Topic types.KnowledgeTopic
	}{
		Ctx:   ctx,
		Topic: topic,
	}
	mock.lockListKnowledgeSlugs.Lock()
	mock.calls.ListKnowledgeSlugs = append(mock.calls.ListKnowledgeSlugs, callInfo)
	mock.lockListKnowledgeSlugs.Unlock()
	if mock.ListKnowledgeSlugsFunc == nil {
		var (
			slugInfosOut []*knowledge.SlugInfo
			errOut       error
		)
		return slugInfosOut, errOut
	}
	return mock.ListKnowledgeSlugsFunc(ctx, topic)
}

// ListKnowledgeSlugsCalls gets all the calls that were made to ListKnowledgeSlugs.
// Check the length with:
//
//	len(mockedRepository.ListKnowledgeSlugsCalls())
func (mock *RepositoryMock) ListKnowledgeSlugsCalls() []struct {
	Ctx   context.Context
	Topic types.KnowledgeTopic
} {
	var calls []struct {
		Ctx   context.Context
		Topic types.KnowledgeTopic
	}
	mock.lockListKnowledgeSlugs.RLock()
	calls = mock.calls.ListKnowledgeSlugs
	mock.lockListKnowledgeSlugs.RUnlock()
	return calls
}

// ListKnowledgeTopics calls ListKnowledgeTopicsFunc.
func (mock *RepositoryMock) ListKnowledgeTopics(ctx context.Context) ([]*knowledge.TopicSummary, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListKnowledgeTopics.Lock()
	mock.calls.ListKnowledgeTopics = append(mock.calls.ListKnowledgeTopics, callInfo)
	mock.lockListKnowledgeTopics.Unlock()
	if mock.ListKnowledgeTopicsFunc == nil {
		var (
			topicSummarysOut []*knowledge.TopicSummary
			errOut           error
		)
		return topicSummarysOut, errOut
	}
	return mock.ListKnowledgeTopicsFunc(ctx)
}

// ListKnowledgeTopicsCalls gets all the calls that were made to ListKnowledgeTopics.
// Check the length with:
//
//	len(mockedRepository.ListKnowledgeTopicsCalls())
func (mock *RepositoryMock) ListKnowledgeTopicsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListKnowledgeTopics.RLock()
	calls = mock.calls.ListKnowledgeTopics
	mock.lockListKnowledgeTopics.RUnlock()
	return calls
}

// PutActivity calls PutActivityFunc.
func (mock *RepositoryMock) PutActivity(ctx context.Context, activityMoqParam *activity.Activity) error {
	callInfo := struct {
		Ctx              context.Context
		ActivityMoqParam *activity.Activity
	}{
		Ctx:              ctx,
		ActivityMoqParam: activityMoqParam,
	}
	mock.lockPutActivity.Lock()
	mock.calls.PutActivity = append(mock.calls.PutActivity, callInfo)
	mock.lockPutActivity.Unlock()
	if mock.PutActivityFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PutActivityFunc(ctx, activityMoqParam)
}

// PutActivityCalls gets all the calls that were made to PutActivity.
// Check the length with:
//
//	len(mockedRepository.PutActivityCalls())
func (mock *RepositoryMock) PutActivityCalls() []struct {
	Ctx              context.Context
	ActivityMoqParam *activity.Activity
} {
	var calls []struct {
		Ctx              context.Context
		ActivityMoqParam *activity.Activity
	}
	mock.lockPutActivity.RLock()
	calls = mock.calls.PutActivity
	mock.lockPutActivity.RUnlock()
	return calls
}

// PutAlert calls PutAlertFunc.
func (mock *RepositoryMock) PutAlert(ctx context.Context, alertMoqParam alert.Alert) error {
	callInfo := struct {
		Ctx           context.Context
		AlertMoqParam alert.Alert
	}{
		Ctx:           ctx,
		AlertMoqParam: alertMoqParam,
	}
	mock.lockPutAlert.Lock()
	mock.calls.PutAlert = append(mock.calls.PutAlert, callInfo)
	mock.lockPutAlert.Unlock()
	if mock.PutAlertFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PutAlertFunc(ctx, alertMoqParam)
}

// PutAlertCalls gets all the calls that were made to PutAlert.
// Check the length with:
//
//	len(mockedRepository.PutAlertCalls())
func (mock *RepositoryMock) PutAlertCalls() []struct {
	Ctx           context.Context
	AlertMoqParam alert.Alert
} {
	var calls []struct {
		Ctx           context.Context
		AlertMoqParam alert.Alert
	}
	mock.lockPutAlert.RLock()
	calls = mock.calls.PutAlert
	mock.lockPutAlert.RUnlock()
	return calls
}

// PutAlertList calls PutAlertListFunc.
func (mock *RepositoryMock) PutAlertList(ctx context.Context, list *alert.List) error {
	callInfo := struct {
		Ctx  context.Context
		List *alert.List
	}{
		Ctx:  ctx,
		List: list,
	}
	mock.lockPutAlertList.Lock()
	mock.calls.PutAlertList = append(mock.calls.PutAlertList, callInfo)
	mock.lockPutAlertList.Unlock()
	if mock.PutAlertListFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PutAlertListFunc(ctx, list)
}

// PutAlertListCalls gets all the calls that were made to PutAlertList.
// Check the length with:
//
//	len(mockedRepository.PutAlertListCalls())
func (mock *RepositoryMock) PutAlertListCalls() []struct {
	Ctx  context.Context
	List *alert.List
} {
	var calls []struct {
		Ctx  context.Context
		List *alert.List
	}
	mock.lockPutAlertList.RLock()
	calls = mock.calls.PutAlertList
	mock.lockPutAlertList.RUnlock()
	return calls
}

// PutHistory calls PutHistoryFunc.
func (mock *RepositoryMock) PutHistory(ctx context.Context, ticketID types.TicketID, history *ticket.History) error {
	callInfo := struct {
		Ctx      context.Context
		TicketID types.TicketID
		History  *ticket.History
	}{
		Ctx:      ctx,
		TicketID: ticketID,
		History:  history,
	}
	mock.lockPutHistory.Lock()
	mock.calls.PutHistory = append(mock.calls.PutHistory, callInfo)
	mock.lockPutHistory.Unlock()
	if mock.PutHistoryFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PutHistoryFunc(ctx, ticketID, history)
}

// PutHistoryCalls gets all the calls that were made to PutHistory.
// Check the length with:
//
//	len(mockedRepository.PutHistoryCalls())
func (mock *RepositoryMock) PutHistoryCalls() []struct {
	Ctx      context.Context
	TicketID types.TicketID
	History  *ticket.History
} {
	var calls []struct {
		Ctx      context.Context
		TicketID types.TicketID
		History  *ticket.History
	}
	mock.lockPutHistory.RLock()
	calls = mock.calls.PutHistory
	mock.lockPutHistory.RUnlock()
	return calls
}

// PutKnowledge calls PutKnowledgeFunc.
func (mock *RepositoryMock) PutKnowledge(ctx context.Context, k *knowledge.Knowledge) error {
	callInfo := struct {
		Ctx context.Context
		K   *knowledge.Knowledge
	}{
		Ctx: ctx,
		K:   k,
	}
	mock.lockPutKnowledge.Lock()
	mock.calls.PutKnowledge = append(mock.calls.PutKnowledge, callInfo)
	mock.lockPutKnowledge.Unlock()
	if mock.PutKnowledgeFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PutKnowledgeFunc(ctx, k)
}

// PutKnowledgeCalls gets all the calls that were made to PutKnowledge.
// Check the length with:
//
//	len(mockedRepository.PutKnowledgeCalls())
func (mock *RepositoryMock) PutKnowledgeCalls() []struct {
	Ctx context.Context
	K   *knowledge.Knowledge
} {
	var calls []struct {
		Ctx context.Context
		K   *knowledge.Knowledge
	}
	mock.lockPutKnowledge.RLock()
	calls = mock.calls.PutKnowledge
	mock.lockPutKnowledge.RUnlock()
	return calls
}

// PutSession calls PutSessionFunc.
func (mock *RepositoryMock) PutSession(ctx context.Context, sessionMoqParam *session.Session) error {
	callInfo := struct {
		Ctx             context.Context
		SessionMoqParam *session.Session
	}{
		Ctx:             ctx,
		SessionMoqParam: sessionMoqParam,
	}
	mock.lockPutSession.Lock()
	mock.calls.PutSession = append(mock.calls.PutSession, callInfo)
	mock.lockPutSession.Unlock()
	if mock.PutSessionFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PutSessionFunc(ctx, sessionMoqParam)
}

// PutSessionCalls gets all the calls that were made to PutSession.
// Check the length with:
//
//	len(mockedRepository.PutSessionCalls())
func (mock *RepositoryMock) PutSessionCalls() []struct {
	Ctx             context.Context
	SessionMoqParam *session.Session
} {
	var calls []struct {
		Ctx             context.Context
		SessionMoqParam *session.Session
	}
	mock.lockPutSession.RLock()
	calls = mock.calls.PutSession
	mock.lockPutSession.RUnlock()
	return calls
}

// PutTicket calls PutTicketFunc.
func (mock *RepositoryMock) PutTicket(ctx context.Context, ticketMoqParam ticket.Ticket) error {
	callInfo := struct {
		Ctx            context.Context
		TicketMoqParam ticket.Ticket
	}{
		Ctx:            ctx,
		TicketMoqParam: ticketMoqParam,
	}
	mock.lockPutTicket.Lock()
	mock.calls.PutTicket = append(mock.calls.PutTicket, callInfo)
	mock.lockPutTicket.Unlock()
	if mock.PutTicketFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PutTicketFunc(ctx, ticketMoqParam)
}

// PutTicketCalls gets all the calls that were made to PutTicket.
// Check the length with:
//
//	len(mockedRepository.PutTicketCalls())
func (mock *RepositoryMock) PutTicketCalls() []struct {
	Ctx            context.Context
	TicketMoqParam ticket.Ticket
} {
	var calls []struct {
		Ctx            context.Context
		TicketMoqParam ticket.Ticket
	}
	mock.lockPutTicket.RLock()
	calls = mock.calls.PutTicket
	mock.lockPutTicket.RUnlock()
	return calls
}

// PutTicketComment calls PutTicketCommentFunc.
func (mock *RepositoryMock) PutTicketComment(ctx context.Context, comment ticket.Comment) error {
	callInfo := struct {
		Ctx     context.Context
		Comment ticket.Comment
	}{
		Ctx:     ctx,
		Comment: comment,
	}
	mock.lockPutTicketComment.Lock()
	mock.calls.PutTicketComment = append(mock.calls.PutTicketComment, callInfo)
	mock.lockPutTicketComment.Unlock()
	if mock.PutTicketCommentFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PutTicketCommentFunc(ctx, comment)
}

// PutTicketCommentCalls gets all the calls that were made to PutTicketComment.
// Check the length with:
//
//	len(mockedRepository.PutTicketCommentCalls())
func (mock *RepositoryMock) PutTicketCommentCalls() []struct {
	Ctx     context.Context
	Comment ticket.Comment
} {
	var calls []struct {
		Ctx     context.Context
		Comment ticket.Comment
	}
	mock.lockPutTicketComment.RLock()
	calls = mock.calls.PutTicketComment
	mock.lockPutTicketComment.RUnlock()
	return calls
}

// PutTicketCommentsPrompted calls PutTicketCommentsPromptedFunc.
func (mock *RepositoryMock) PutTicketCommentsPrompted(ctx context.Context, ticketID types.TicketID, commentIDs []types.CommentID) error {
	callInfo := struct {
		Ctx        context.Context
		TicketID   types.TicketID
		CommentIDs []types.CommentID
	}{
		Ctx:        ctx,
		TicketID:   ticketID,
		CommentIDs: commentIDs,
	}
	mock.lockPutTicketCommentsPrompted.Lock()
	mock.calls.PutTicketCommentsPrompted = append(mock.calls.PutTicketCommentsPrompted, callInfo)
	mock.lockPutTicketCommentsPrompted.Unlock()
	if mock.PutTicketCommentsPromptedFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PutTicketCommentsPromptedFunc(ctx, ticketID, commentIDs)
}

// PutTicketCommentsPromptedCalls gets all the calls that were made to PutTicketCommentsPrompted.
// Check the length with:
//
//	len(mockedRepository.PutTicketCommentsPromptedCalls())
func (mock *RepositoryMock) PutTicketCommentsPromptedCalls() []struct {
	Ctx        context.Context
	TicketID   types.TicketID
	CommentIDs []types.CommentID
} {
	var calls []struct {
		Ctx        context.Context
		TicketID   types.TicketID
		CommentIDs []types.CommentID
	}
	mock.lockPutTicketCommentsPrompted.RLock()
	calls = mock.calls.PutTicketCommentsPrompted
	mock.lockPutTicketCommentsPrompted.RUnlock()
	return calls
}

// PutToken calls PutTokenFunc.
func (mock *RepositoryMock) PutToken(ctx context.Context, token *auth.Token) error {
	callInfo := struct {
		Ctx   context.Context
		Token *auth.Token
	}{
		Ctx:   ctx,
		Token: token,
	}
	mock.lockPutToken.Lock()
	mock.calls.PutToken = append(mock.calls.PutToken, callInfo)
	mock.lockPutToken.Unlock()
	if mock.PutTokenFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PutTokenFunc(ctx, token)
}

// PutTokenCalls gets all the calls that were made to PutToken.
// Check the length with:
//
//	len(mockedRepository.PutTokenCalls())
func (mock *RepositoryMock) PutTokenCalls() []struct {
	Ctx   context.Context
	Token *auth.Token
} {
	var calls []struct {
		Ctx   context.Context
		Token *auth.Token
	}
	mock.lockPutToken.RLock()
	calls = mock.calls.PutToken
	mock.lockPutToken.RUnlock()
	return calls
}

// RemoveTagFromAllAlerts calls RemoveTagFromAllAlertsFunc.
func (mock *RepositoryMock) RemoveTagFromAllAlerts(ctx context.Context, name string) error {
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockRemoveTagFromAllAlerts.Lock()
	mock.calls.RemoveTagFromAllAlerts = append(mock.calls.RemoveTagFromAllAlerts, callInfo)
	mock.lockRemoveTagFromAllAlerts.Unlock()
	if mock.RemoveTagFromAllAlertsFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.RemoveTagFromAllAlertsFunc(ctx, name)
}

// RemoveTagFromAllAlertsCalls gets all the calls that were made to RemoveTagFromAllAlerts.
// Check the length with:
//
//	len(mockedRepository.RemoveTagFromAllAlertsCalls())
func (mock *RepositoryMock) RemoveTagFromAllAlertsCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	mock.lockRemoveTagFromAllAlerts.RLock()
	calls = mock.calls.RemoveTagFromAllAlerts
	mock.lockRemoveTagFromAllAlerts.RUnlock()
	return calls
}

// RemoveTagFromAllTickets calls RemoveTagFromAllTicketsFunc.
func (mock *RepositoryMock) RemoveTagFromAllTickets(ctx context.Context, name string) error {
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockRemoveTagFromAllTickets.Lock()
	mock.calls.RemoveTagFromAllTickets = append(mock.calls.RemoveTagFromAllTickets, callInfo)
	mock.lockRemoveTagFromAllTickets.Unlock()
	if mock.RemoveTagFromAllTicketsFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.RemoveTagFromAllTicketsFunc(ctx, name)
}

// RemoveTagFromAllTicketsCalls gets all the calls that were made to RemoveTagFromAllTickets.
// Check the length with:
//
//	len(mockedRepository.RemoveTagFromAllTicketsCalls())
func (mock *RepositoryMock) RemoveTagFromAllTicketsCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	mock.lockRemoveTagFromAllTickets.RLock()
	calls = mock.calls.RemoveTagFromAllTickets
	mock.lockRemoveTagFromAllTickets.RUnlock()
	return calls
}

// RemoveTagIDFromAllAlerts calls RemoveTagIDFromAllAlertsFunc.
func (mock *RepositoryMock) RemoveTagIDFromAllAlerts(ctx context.Context, tagID string) error {
	callInfo := struct {
		Ctx   context.Context
		TagID string
	}{
		Ctx:   ctx,
		TagID: tagID,
	}
	mock.lockRemoveTagIDFromAllAlerts.Lock()
	mock.calls.RemoveTagIDFromAllAlerts = append(mock.calls.RemoveTagIDFromAllAlerts, callInfo)
	mock.lockRemoveTagIDFromAllAlerts.Unlock()
	if mock.RemoveTagIDFromAllAlertsFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.RemoveTagIDFromAllAlertsFunc(ctx, tagID)
}

// RemoveTagIDFromAllAlertsCalls gets all the calls that were made to RemoveTagIDFromAllAlerts.
// Check the length with:
//
//	len(mockedRepository.RemoveTagIDFromAllAlertsCalls())
func (mock *RepositoryMock) RemoveTagIDFromAllAlertsCalls() []struct {
	Ctx   context.Context
	TagID string
} {
	var calls []struct {
		Ctx   context.Context
		TagID string
	}
	mock.lockRemoveTagIDFromAllAlerts.RLock()
	calls = mock.calls.RemoveTagIDFromAllAlerts
	mock.lockRemoveTagIDFromAllAlerts.RUnlock()
	return calls
}

// RemoveTagIDFromAllTickets calls RemoveTagIDFromAllTicketsFunc.
func (mock *RepositoryMock) RemoveTagIDFromAllTickets(ctx context.Context, tagID string) error {
	callInfo := struct {
		Ctx   context.Context
		TagID string
	}{
		Ctx:   ctx,
		TagID: tagID,
	}
	mock.lockRemoveTagIDFromAllTickets.Lock()
	mock.calls.RemoveTagIDFromAllTickets = append(mock.calls.RemoveTagIDFromAllTickets, callInfo)
	mock.lockRemoveTagIDFromAllTickets.Unlock()
	if mock.RemoveTagIDFromAllTicketsFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.RemoveTagIDFromAllTicketsFunc(ctx, tagID)
}

// RemoveTagIDFromAllTicketsCalls gets all the calls that were made to RemoveTagIDFromAllTickets.
// Check the length with:
//
//	len(mockedRepository.RemoveTagIDFromAllTicketsCalls())
func (mock *RepositoryMock) RemoveTagIDFromAllTicketsCalls() []struct {
	Ctx   context.Context
	TagID string
} {
	var calls []struct {
		Ctx   context.Context
		TagID string
	}
	mock.lockRemoveTagIDFromAllTickets.RLock()
	calls = mock.calls.RemoveTagIDFromAllTickets
	mock.lockRemoveTagIDFromAllTickets.RUnlock()
	return calls
}

// SaveAgentMemory calls SaveAgentMemoryFunc.
func (mock *RepositoryMock) SaveAgentMemory(ctx context.Context, mem *memory.AgentMemory) error {
	callInfo := struct {
		Ctx context.Context
		Mem *memory.AgentMemory
	}{
		Ctx: ctx,
		Mem: mem,
	}
	mock.lockSaveAgentMemory.Lock()
	mock.calls.SaveAgentMemory = append(mock.calls.SaveAgentMemory, callInfo)
	mock.lockSaveAgentMemory.Unlock()
	if mock.SaveAgentMemoryFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.SaveAgentMemoryFunc(ctx, mem)
}

// SaveAgentMemoryCalls gets all the calls that were made to SaveAgentMemory.
// Check the length with:
//
//	len(mockedRepository.SaveAgentMemoryCalls())
func (mock *RepositoryMock) SaveAgentMemoryCalls() []struct {
	Ctx context.Context
	Mem *memory.AgentMemory
} {
	var calls []struct {
		Ctx context.Context
		Mem *memory.AgentMemory
	}
	mock.lockSaveAgentMemory.RLock()
	calls = mock.calls.SaveAgentMemory
	mock.lockSaveAgentMemory.RUnlock()
	return calls
}

// SearchAlerts calls SearchAlertsFunc.
func (mock *RepositoryMock) SearchAlerts(ctx context.Context, path string, op string, value any, limit int) (alert.Alerts, error) {
	callInfo := struct {
		Ctx   context.Context
		Path  string
		Op    string
		Value any
		Limit int
	}{
		Ctx:   ctx,
		Path:  path,
		Op:    op,
		Value: value,
		Limit: limit,
	}
	mock.lockSearchAlerts.Lock()
	mock.calls.SearchAlerts = append(mock.calls.SearchAlerts, callInfo)
	mock.lockSearchAlerts.Unlock()
	if mock.SearchAlertsFunc == nil {
		var (
			alertsOut alert.Alerts
			errOut    error
		)
		return alertsOut, errOut
	}
	return mock.SearchAlertsFunc(ctx, path, op, value, limit)
}

// SearchAlertsCalls gets all the calls that were made to SearchAlerts.
// Check the length with:
//
//	len(mockedRepository.SearchAlertsCalls())
func (mock *RepositoryMock) SearchAlertsCalls() []struct {
	Ctx   context.Context
	Path  string
	Op    string
	Value any
	Limit int
} {
	var calls []struct {
		Ctx   context.Context
		Path  string
		Op    string
		Value any
		Limit int
	}
	mock.lockSearchAlerts.RLock()
	calls = mock.calls.SearchAlerts
	mock.lockSearchAlerts.RUnlock()
	return calls
}

// SearchMemoriesByEmbedding calls SearchMemoriesByEmbeddingFunc.
func (mock *RepositoryMock) SearchMemoriesByEmbedding(ctx context.Context, agentID string, embedding []float32, limit int) ([]*memory.AgentMemory, error) {
	callInfo := struct {
		Ctx       context.Context
		AgentID   string
		Embedding []float32
		Limit     int
	}{
		Ctx:       ctx,
		AgentID:   agentID,
		Embedding: embedding,
		Limit:     limit,
	}
	mock.lockSearchMemoriesByEmbedding.Lock()
	mock.calls.SearchMemoriesByEmbedding = append(mock.calls.SearchMemoriesByEmbedding, callInfo)
	mock.lockSearchMemoriesByEmbedding.Unlock()
	if mock.SearchMemoriesByEmbeddingFunc == nil {
		var (
			agentMemorysOut []*memory.AgentMemory
			errOut          error
		)
		return agentMemorysOut, errOut
	}
	return mock.SearchMemoriesByEmbeddingFunc(ctx, agentID, embedding, limit)
}

// SearchMemoriesByEmbeddingCalls gets all the calls that were made to SearchMemoriesByEmbedding.
// Check the length with:
//
//	len(mockedRepository.SearchMemoriesByEmbeddingCalls())
func (mock *RepositoryMock) SearchMemoriesByEmbeddingCalls() []struct {
	Ctx       context.Context
	AgentID   string
	Embedding []float32
	Limit     int
} {
	var calls []struct {
		Ctx       context.Context
		AgentID   string
		Embedding []float32
		Limit     int
	}
	mock.lockSearchMemoriesByEmbedding.RLock()
	calls = mock.calls.SearchMemoriesByEmbedding
	mock.lockSearchMemoriesByEmbedding.RUnlock()
	return calls
}

// UnbindAlertFromTicket calls UnbindAlertFromTicketFunc.
func (mock *RepositoryMock) UnbindAlertFromTicket(ctx context.Context, alertID types.AlertID) error {
	callInfo := struct {
		Ctx     context.Context
		AlertID types.AlertID
	}{
		Ctx:     ctx,
		AlertID: alertID,
	}
	mock.lockUnbindAlertFromTicket.Lock()
	mock.calls.UnbindAlertFromTicket = append(mock.calls.UnbindAlertFromTicket, callInfo)
	mock.lockUnbindAlertFromTicket.Unlock()
	if mock.UnbindAlertFromTicketFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.UnbindAlertFromTicketFunc(ctx, alertID)
}

// UnbindAlertFromTicketCalls gets all the calls that were made to UnbindAlertFromTicket.
// Check the length with:
//
//	len(mockedRepository.UnbindAlertFromTicketCalls())
func (mock *RepositoryMock) UnbindAlertFromTicketCalls() []struct {
	Ctx     context.Context
	AlertID types.AlertID
} {
	var calls []struct {
		Ctx     context.Context
		AlertID types.AlertID
	}
	mock.lockUnbindAlertFromTicket.RLock()
	calls = mock.calls.UnbindAlertFromTicket
	mock.lockUnbindAlertFromTicket.RUnlock()
	return calls
}

// UpdateMemoryScoreBatch calls UpdateMemoryScoreBatchFunc.
func (mock *RepositoryMock) UpdateMemoryScoreBatch(ctx context.Context, agentID string, updates map[types.AgentMemoryID]struct {
	Score      float64
	LastUsedAt time.Time
}) error {
	callInfo := struct {
		Ctx     context.Context
		AgentID string
		Updates map[types.AgentMemoryID]struct {
			Score      float64
			LastUsedAt time.Time
		}
	}{
		Ctx:     ctx,
		AgentID: agentID,
		Updates: updates,
	}
	mock.lockUpdateMemoryScoreBatch.Lock()
	mock.calls.UpdateMemoryScoreBatch = append(mock.calls.UpdateMemoryScoreBatch, callInfo)
	mock.lockUpdateMemoryScoreBatch.Unlock()
	if mock.UpdateMemoryScoreBatchFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.UpdateMemoryScoreBatchFunc(ctx, agentID, updates)
}

// UpdateMemoryScoreBatchCalls gets all the calls that were made to UpdateMemoryScoreBatch.
// Check the length with:
//
//	len(mockedRepository.UpdateMemoryScoreBatchCalls())
func (mock *RepositoryMock) UpdateMemoryScoreBatchCalls() []struct {
	Ctx     context.Context
	AgentID string
	Updates map[types.AgentMemoryID]struct {
		Score      float64
		LastUsedAt time.Time
	}
} {
	var calls []struct {
		Ctx     context.Context
		AgentID string
		Updates map[types.AgentMemoryID]struct {
			Score      float64
			LastUsedAt time.Time
		}
	}
	mock.lockUpdateMemoryScoreBatch.RLock()
	calls = mock.calls.UpdateMemoryScoreBatch
	mock.lockUpdateMemoryScoreBatch.RUnlock()
	return calls
}

// UpdateNotice calls UpdateNoticeFunc.
func (mock *RepositoryMock) UpdateNotice(ctx context.Context, noticeMoqParam *notice.Notice) error {
	callInfo := struct {
		Ctx            context.Context
		NoticeMoqParam *notice.Notice
	}{
		Ctx:            ctx,
		NoticeMoqParam: noticeMoqParam,
	}
	mock.lockUpdateNotice.Lock()
	mock.calls.UpdateNotice = append(mock.calls.UpdateNotice, callInfo)
	mock.lockUpdateNotice.Unlock()
	if mock.UpdateNoticeFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.UpdateNoticeFunc(ctx, noticeMoqParam)
}

// UpdateNoticeCalls gets all the calls that were made to UpdateNotice.
// Check the length with:
//
//	len(mockedRepository.UpdateNoticeCalls())
func (mock *RepositoryMock) UpdateNoticeCalls() []struct {
	Ctx            context.Context
	NoticeMoqParam *notice.Notice
} {
	var calls []struct {
		Ctx            context.Context
		NoticeMoqParam *notice.Notice
	}
	mock.lockUpdateNotice.RLock()
	calls = mock.calls.UpdateNotice
	mock.lockUpdateNotice.RUnlock()
	return calls
}

// UpdateTag calls UpdateTagFunc.
func (mock *RepositoryMock) UpdateTag(ctx context.Context, tagMoqParam *tag.Tag) error {
	callInfo := struct {
		Ctx         context.Context
		TagMoqParam *tag.Tag
	}{
		Ctx:         ctx,
		TagMoqParam: tagMoqParam,
	}
	mock.lockUpdateTag.Lock()
	mock.calls.UpdateTag = append(mock.calls.UpdateTag, callInfo)
	mock.lockUpdateTag.Unlock()
	if mock.UpdateTagFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.UpdateTagFunc(ctx, tagMoqParam)
}

// UpdateTagCalls gets all the calls that were made to UpdateTag.
// Check the length with:
//
//	len(mockedRepository.UpdateTagCalls())
func (mock *RepositoryMock) UpdateTagCalls() []struct {
	Ctx         context.Context
	TagMoqParam *tag.Tag
} {
	var calls []struct {
		Ctx         context.Context
		TagMoqParam *tag.Tag
	}
	mock.lockUpdateTag.RLock()
	calls = mock.calls.UpdateTag
	mock.lockUpdateTag.RUnlock()
	return calls
}

// PolicyClientMock is a mock implementation of interfaces.PolicyClient.
//
//	func TestSomethingThatUsesPolicyClient(t *testing.T) {
//
//		// make and configure a mocked interfaces.PolicyClient
//		mockedPolicyClient := &PolicyClientMock{
//			QueryFunc: func(contextMoqParam context.Context, s string, v1 any, v2 any, queryOptions ...opaq.QueryOption) error {
//				panic("mock out the Query method")
//			},
//			SourcesFunc: func() map[string]string {
//				panic("mock out the Sources method")
//			},
//		}
//
//		// use mockedPolicyClient in code that requires interfaces.PolicyClient
//		// and then make assertions.
//
//	}
type PolicyClientMock struct {
	// QueryFunc mocks the Query method.
	QueryFunc func(contextMoqParam context.Context, s string, v1 any, v2 any, queryOptions ...opaq.QueryOption) error

	// SourcesFunc mocks the Sources method.
	SourcesFunc func() map[string]string

	// calls tracks calls to the methods.
	calls struct {
		// Query holds details about calls to the Query method.
		Query []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// S is the s argument value.
			S string
			// V1 is the v1 argument value.
			V1 any
			// V2 is the v2 argument value.
			V2 any
			// QueryOptions is the queryOptions argument value.
			QueryOptions []opaq.QueryOption
		}
		// Sources holds details about calls to the Sources method.
		Sources []struct {
		}
	}
	lockQuery   sync.RWMutex
	lockSources sync.RWMutex
}

// Query calls QueryFunc.
func (mock *PolicyClientMock) Query(contextMoqParam context.Context, s string, v1 any, v2 any, queryOptions ...opaq.QueryOption) error {
	callInfo := struct {
		ContextMoqParam context.Context
		S               string
		V1              any
		V2              any
		QueryOptions    []opaq.QueryOption
	}{
		ContextMoqParam: contextMoqParam,
		S:               s,
		V1:              v1,
		V2:              v2,
		QueryOptions:    queryOptions,
	}
	mock.lockQuery.Lock()
	mock.calls.Query = append(mock.calls.Query, callInfo)
	mock.lockQuery.Unlock()
	if mock.QueryFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.QueryFunc(contextMoqParam, s, v1, v2, queryOptions...)
}

// QueryCalls gets all the calls that were made to Query.
// Check the length with:
//
//	len(mockedPolicyClient.QueryCalls())
func (mock *PolicyClientMock) QueryCalls() []struct {
	ContextMoqParam context.Context
	S               string
	V1              any
	V2              any
	QueryOptions    []opaq.QueryOption
} {
	var calls []struct {
		ContextMoqParam context.Context
		S               string
		V1              any
		V2              any
		QueryOptions    []opaq.QueryOption
	}
	mock.lockQuery.RLock()
	calls = mock.calls.Query
	mock.lockQuery.RUnlock()
	return calls
}

// Sources calls SourcesFunc.
func (mock *PolicyClientMock) Sources() map[string]string {
	callInfo := struct {
	}{}
	mock.lockSources.Lock()
	mock.calls.Sources = append(mock.calls.Sources, callInfo)
	mock.lockSources.Unlock()
	if mock.SourcesFunc == nil {
		var (
			stringToStringOut map[string]string
		)
		return stringToStringOut
	}
	return mock.SourcesFunc()
}

// SourcesCalls gets all the calls that were made to Sources.
// Check the length with:
//
//	len(mockedPolicyClient.SourcesCalls())
func (mock *PolicyClientMock) SourcesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSources.RLock()
	calls = mock.calls.Sources
	mock.lockSources.RUnlock()
	return calls
}

// EmbeddingClientMock is a mock implementation of interfaces.EmbeddingClient.
//
//	func TestSomethingThatUsesEmbeddingClient(t *testing.T) {
//
//		// make and configure a mocked interfaces.EmbeddingClient
//		mockedEmbeddingClient := &EmbeddingClientMock{
//			EmbeddingsFunc: func(ctx context.Context, texts []string, dimensionality int) ([][]float32, error) {
//				panic("mock out the Embeddings method")
//			},
//		}
//
//		// use mockedEmbeddingClient in code that requires interfaces.EmbeddingClient
//		// and then make assertions.
//
//	}
type EmbeddingClientMock struct {
	// EmbeddingsFunc mocks the Embeddings method.
	EmbeddingsFunc func(ctx context.Context, texts []string, dimensionality int) ([][]float32, error)

	// calls tracks calls to the methods.
	calls struct {
		// Embeddings holds details about calls to the Embeddings method.
		Embeddings []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Texts is the texts argument value.
			Texts []string
			// Dimensionality is the dimensionality argument value.
			Dimensionality int
		}
	}
	lockEmbeddings sync.RWMutex
}

// Embeddings calls EmbeddingsFunc.
func (mock *EmbeddingClientMock) Embeddings(ctx context.Context, texts []string, dimensionality int) ([][]float32, error) {
	callInfo := struct {
		Ctx            context.Context
		Texts          []string
		Dimensionality int
	}{
		Ctx:            ctx,
		Texts:          texts,
		Dimensionality: dimensionality,
	}
	mock.lockEmbeddings.Lock()
	mock.calls.Embeddings = append(mock.calls.Embeddings, callInfo)
	mock.lockEmbeddings.Unlock()
	if mock.EmbeddingsFunc == nil {
		var (
			float32ssOut [][]float32
			errOut       error
		)
		return float32ssOut, errOut
	}
	return mock.EmbeddingsFunc(ctx, texts, dimensionality)
}

// EmbeddingsCalls gets all the calls that were made to Embeddings.
// Check the length with:
//
//	len(mockedEmbeddingClient.EmbeddingsCalls())
func (mock *EmbeddingClientMock) EmbeddingsCalls() []struct {
	Ctx            context.Context
	Texts          []string
	Dimensionality int
} {
	var calls []struct {
		Ctx            context.Context
		Texts          []string
		Dimensionality int
	}
	mock.lockEmbeddings.RLock()
	calls = mock.calls.Embeddings
	mock.lockEmbeddings.RUnlock()
	return calls
}

// StorageClientMock is a mock implementation of interfaces.StorageClient.
//
//	func TestSomethingThatUsesStorageClient(t *testing.T) {
//
//		// make and configure a mocked interfaces.StorageClient
//		mockedStorageClient := &StorageClientMock{
//			CloseFunc: func(ctx context.Context)  {
//				panic("mock out the Close method")
//			},
//			GetObjectFunc: func(ctx context.Context, object string) (io.ReadCloser, error) {
//				panic("mock out the GetObject method")
//			},
//			PutObjectFunc: func(ctx context.Context, object string) io.WriteCloser {
//				panic("mock out the PutObject method")
//			},
//		}
//
//		// use mockedStorageClient in code that requires interfaces.StorageClient
//		// and then make assertions.
//
//	}
type StorageClientMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func(ctx context.Context)

	// GetObjectFunc mocks the GetObject method.
	GetObjectFunc func(ctx context.Context, object string) (io.ReadCloser, error)

	// PutObjectFunc mocks the PutObject method.
	PutObjectFunc func(ctx context.Context, object string) io.WriteCloser

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetObject holds details about calls to the GetObject method.
		GetObject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Object is the object argument value.
			Object string
		}
		// PutObject holds details about calls to the PutObject method.
		PutObject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Object is the object argument value.
			Object string
		}
	}
	lockClose     sync.RWMutex
	lockGetObject sync.RWMutex
	lockPutObject sync.RWMutex
}

// Close calls CloseFunc.
func (mock *StorageClientMock) Close(ctx context.Context) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	if mock.CloseFunc == nil {
		return
	}
	mock.CloseFunc(ctx)
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedStorageClient.CloseCalls())
func (mock *StorageClientMock) CloseCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// GetObject calls GetObjectFunc.
func (mock *StorageClientMock) GetObject(ctx context.Context, object string) (io.ReadCloser, error) {
	callInfo := struct {
		Ctx    context.Context
		Object string
	}{
		Ctx:    ctx,
		Object: object,
	}
	mock.lockGetObject.Lock()
	mock.calls.GetObject = append(mock.calls.GetObject, callInfo)
	mock.lockGetObject.Unlock()
	if mock.GetObjectFunc == nil {
		var (
			readCloserOut io.ReadCloser
			errOut        error
		)
		return readCloserOut, errOut
	}
	return mock.GetObjectFunc(ctx, object)
}

// GetObjectCalls gets all the calls that were made to GetObject.
// Check the length with:
//
//	len(mockedStorageClient.GetObjectCalls())
func (mock *StorageClientMock) GetObjectCalls() []struct {
	Ctx    context.Context
	Object string
} {
	var calls []struct {
		Ctx    context.Context
		Object string
	}
	mock.lockGetObject.RLock()
	calls = mock.calls.GetObject
	mock.lockGetObject.RUnlock()
	return calls
}

// PutObject calls PutObjectFunc.
func (mock *StorageClientMock) PutObject(ctx context.Context, object string) io.WriteCloser {
	callInfo := struct {
		Ctx    context.Context
		Object string
	}{
		Ctx:    ctx,
		Object: object,
	}
	mock.lockPutObject.Lock()
	mock.calls.PutObject = append(mock.calls.PutObject, callInfo)
	mock.lockPutObject.Unlock()
	if mock.PutObjectFunc == nil {
		var (
			writeCloserOut io.WriteCloser
		)
		return writeCloserOut
	}
	return mock.PutObjectFunc(ctx, object)
}

// PutObjectCalls gets all the calls that were made to PutObject.
// Check the length with:
//
//	len(mockedStorageClient.PutObjectCalls())
func (mock *StorageClientMock) PutObjectCalls() []struct {
	Ctx    context.Context
	Object string
} {
	var calls []struct {
		Ctx    context.Context
		Object string
	}
	mock.lockPutObject.RLock()
	calls = mock.calls.PutObject
	mock.lockPutObject.RUnlock()
	return calls
}

// LLMClientMock is a mock implementation of interfaces.LLMClient.
//
//	func TestSomethingThatUsesLLMClient(t *testing.T) {
//
//		// make and configure a mocked interfaces.LLMClient
//		mockedLLMClient := &LLMClientMock{
//			GenerateEmbeddingFunc: func(ctx context.Context, dimension int, input []string) ([][]float64, error) {
//				panic("mock out the GenerateEmbedding method")
//			},
//			NewSessionFunc: func(ctx context.Context, options ...gollem.SessionOption) (gollem.Session, error) {
//				panic("mock out the NewSession method")
//			},
//		}
//
//		// use mockedLLMClient in code that requires interfaces.LLMClient
//		// and then make assertions.
//
//	}
type LLMClientMock struct {
	// GenerateEmbeddingFunc mocks the GenerateEmbedding method.
	GenerateEmbeddingFunc func(ctx context.Context, dimension int, input []string) ([][]float64, error)

	// NewSessionFunc mocks the NewSession method.
	NewSessionFunc func(ctx context.Context, options ...gollem.SessionOption) (gollem.Session, error)

	// calls tracks calls to the methods.
	calls struct {
		// GenerateEmbedding holds details about calls to the GenerateEmbedding method.
		GenerateEmbedding []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dimension is the dimension argument value.
			Dimension int
			// Input is the input argument value.
			Input []string
		}
		// NewSession holds details about calls to the NewSession method.
		NewSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Options is the options argument value.
			Options []gollem.SessionOption
		}
	}
	lockGenerateEmbedding sync.RWMutex
	lockNewSession        sync.RWMutex
}

// GenerateEmbedding calls GenerateEmbeddingFunc.
func (mock *LLMClientMock) GenerateEmbedding(ctx context.Context, dimension int, input []string) ([][]float64, error) {
	callInfo := struct {
		Ctx       context.Context
		Dimension int
		Input     []string
	}{
		Ctx:       ctx,
		Dimension: dimension,
		Input:     input,
	}
	mock.lockGenerateEmbedding.Lock()
	mock.calls.GenerateEmbedding = append(mock.calls.GenerateEmbedding, callInfo)
	mock.lockGenerateEmbedding.Unlock()
	if mock.GenerateEmbeddingFunc == nil {
		var (
			float64ssOut [][]float64
			errOut       error
		)
		return float64ssOut, errOut
	}
	return mock.GenerateEmbeddingFunc(ctx, dimension, input)
}

// GenerateEmbeddingCalls gets all the calls that were made to GenerateEmbedding.
// Check the length with:
//
//	len(mockedLLMClient.GenerateEmbeddingCalls())
func (mock *LLMClientMock) GenerateEmbeddingCalls() []struct {
	Ctx       context.Context
	Dimension int
	Input     []string
} {
	var calls []struct {
		Ctx       context.Context
		Dimension int
		Input     []string
	}
	mock.lockGenerateEmbedding.RLock()
	calls = mock.calls.GenerateEmbedding
	mock.lockGenerateEmbedding.RUnlock()
	return calls
}

// NewSession calls NewSessionFunc.
func (mock *LLMClientMock) NewSession(ctx context.Context, options ...gollem.SessionOption) (gollem.Session, error) {
	callInfo := struct {
		Ctx     context.Context
		Options []gollem.SessionOption
	}{
		Ctx:     ctx,
		Options: options,
	}
	mock.lockNewSession.Lock()
	mock.calls.NewSession = append(mock.calls.NewSession, callInfo)
	mock.lockNewSession.Unlock()
	if mock.NewSessionFunc == nil {
		var (
			sessionOut gollem.Session
			errOut     error
		)
		return sessionOut, errOut
	}
	return mock.NewSessionFunc(ctx, options...)
}

// NewSessionCalls gets all the calls that were made to NewSession.
// Check the length with:
//
//	len(mockedLLMClient.NewSessionCalls())
func (mock *LLMClientMock) NewSessionCalls() []struct {
	Ctx     context.Context
	Options []gollem.SessionOption
} {
	var calls []struct {
		Ctx     context.Context
		Options []gollem.SessionOption
	}
	mock.lockNewSession.RLock()
	calls = mock.calls.NewSession
	mock.lockNewSession.RUnlock()
	return calls
}

// LLMSessionMock is a mock implementation of interfaces.LLMSession.
//
//	func TestSomethingThatUsesLLMSession(t *testing.T) {
//
//		// make and configure a mocked interfaces.LLMSession
//		mockedLLMSession := &LLMSessionMock{
//			AppendHistoryFunc: func(history *gollem.History) error {
//				panic("mock out the AppendHistory method")
//			},
//			CountTokenFunc: func(ctx context.Context, input ...gollem.Input) (int, error) {
//				panic("mock out the CountToken method")
//			},
//			GenerateContentFunc: func(ctx context.Context, input ...gollem.Input) (*gollem.Response, error) {
//				panic("mock out the GenerateContent method")
//			},
//			GenerateStreamFunc: func(ctx context.Context, input ...gollem.Input) (<-chan *gollem.Response, error) {
//				panic("mock out the GenerateStream method")
//			},
//			HistoryFunc: func() (*gollem.History, error) {
//				panic("mock out the History method")
//			},
//		}
//
//		// use mockedLLMSession in code that requires interfaces.LLMSession
//		// and then make assertions.
//
//	}
type LLMSessionMock struct {
	// AppendHistoryFunc mocks the AppendHistory method.
	AppendHistoryFunc func(history *gollem.History) error

	// CountTokenFunc mocks the CountToken method.
	CountTokenFunc func(ctx context.Context, input ...gollem.Input) (int, error)

	// GenerateContentFunc mocks the GenerateContent method.
	GenerateContentFunc func(ctx context.Context, input ...gollem.Input) (*gollem.Response, error)

	// GenerateStreamFunc mocks the GenerateStream method.
	GenerateStreamFunc func(ctx context.Context, input ...gollem.Input) (<-chan *gollem.Response, error)

	// HistoryFunc mocks the History method.
	HistoryFunc func() (*gollem.History, error)

	// calls tracks calls to the methods.
	calls struct {
		// AppendHistory holds details about calls to the AppendHistory method.
		AppendHistory []struct {
			// History is the history argument value.
			History *gollem.History
		}
		// CountToken holds details about calls to the CountToken method.
		CountToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input []gollem.Input
		}
		// GenerateContent holds details about calls to the GenerateContent method.
		GenerateContent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input []gollem.Input
		}
		// GenerateStream holds details about calls to the GenerateStream method.
		GenerateStream []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input []gollem.Input
		}
		// History holds details about calls to the History method.
		History []struct {
		}
	}
	lockAppendHistory   sync.RWMutex
	lockCountToken      sync.RWMutex
	lockGenerateContent sync.RWMutex
	lockGenerateStream  sync.RWMutex
	lockHistory         sync.RWMutex
}

// AppendHistory calls AppendHistoryFunc.
func (mock *LLMSessionMock) AppendHistory(history *gollem.History) error {
	callInfo := struct {
		History *gollem.History
	}{
		History: history,
	}
	mock.lockAppendHistory.Lock()
	mock.calls.AppendHistory = append(mock.calls.AppendHistory, callInfo)
	mock.lockAppendHistory.Unlock()
	if mock.AppendHistoryFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.AppendHistoryFunc(history)
}

// AppendHistoryCalls gets all the calls that were made to AppendHistory.
// Check the length with:
//
//	len(mockedLLMSession.AppendHistoryCalls())
func (mock *LLMSessionMock) AppendHistoryCalls() []struct {
	History *gollem.History
} {
	var calls []struct {
		History *gollem.History
	}
	mock.lockAppendHistory.RLock()
	calls = mock.calls.AppendHistory
	mock.lockAppendHistory.RUnlock()
	return calls
}

// CountToken calls CountTokenFunc.
func (mock *LLMSessionMock) CountToken(ctx context.Context, input ...gollem.Input) (int, error) {
	callInfo := struct {
		Ctx   context.Context
		Input []gollem.Input
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockCountToken.Lock()
	mock.calls.CountToken = append(mock.calls.CountToken, callInfo)
	mock.lockCountToken.Unlock()
	if mock.CountTokenFunc == nil {
		var (
			nOut   int
			errOut error
		)
		return nOut, errOut
	}
	return mock.CountTokenFunc(ctx, input...)
}

// CountTokenCalls gets all the calls that were made to CountToken.
// Check the length with:
//
//	len(mockedLLMSession.CountTokenCalls())
func (mock *LLMSessionMock) CountTokenCalls() []struct {
	Ctx   context.Context
	Input []gollem.Input
} {
	var calls []struct {
		Ctx   context.Context
		Input []gollem.Input
	}
	mock.lockCountToken.RLock()
	calls = mock.calls.CountToken
	mock.lockCountToken.RUnlock()
	return calls
}

// GenerateContent calls GenerateContentFunc.
func (mock *LLMSessionMock) GenerateContent(ctx context.Context, input ...gollem.Input) (*gollem.Response, error) {
	callInfo := struct {
		Ctx   context.Context
		Input []gollem.Input
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockGenerateContent.Lock()
	mock.calls.GenerateContent = append(mock.calls.GenerateContent, callInfo)
	mock.lockGenerateContent.Unlock()
	if mock.GenerateContentFunc == nil {
		var (
			responseOut *gollem.Response
			errOut      error
		)
		return responseOut, errOut
	}
	return mock.GenerateContentFunc(ctx, input...)
}

// GenerateContentCalls gets all the calls that were made to GenerateContent.
// Check the length with:
//
//	len(mockedLLMSession.GenerateContentCalls())
func (mock *LLMSessionMock) GenerateContentCalls() []struct {
	Ctx   context.Context
	Input []gollem.Input
} {
	var calls []struct {
		Ctx   context.Context
		Input []gollem.Input
	}
	mock.lockGenerateContent.RLock()
	calls = mock.calls.GenerateContent
	mock.lockGenerateContent.RUnlock()
	return calls
}

// GenerateStream calls GenerateStreamFunc.
func (mock *LLMSessionMock) GenerateStream(ctx context.Context, input ...gollem.Input) (<-chan *gollem.Response, error) {
	callInfo := struct {
		Ctx   context.Context
		Input []gollem.Input
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockGenerateStream.Lock()
	mock.calls.GenerateStream = append(mock.calls.GenerateStream, callInfo)
	mock.lockGenerateStream.Unlock()
	if mock.GenerateStreamFunc == nil {
		var (
			responseChOut <-chan *gollem.Response
			errOut        error
		)
		return responseChOut, errOut
	}
	return mock.GenerateStreamFunc(ctx, input...)
}

// GenerateStreamCalls gets all the calls that were made to GenerateStream.
// Check the length with:
//
//	len(mockedLLMSession.GenerateStreamCalls())
func (mock *LLMSessionMock) GenerateStreamCalls() []struct {
	Ctx   context.Context
	Input []gollem.Input
} {
	var calls []struct {
		Ctx   context.Context
		Input []gollem.Input
	}
	mock.lockGenerateStream.RLock()
	calls = mock.calls.GenerateStream
	mock.lockGenerateStream.RUnlock()
	return calls
}

// History calls HistoryFunc.
func (mock *LLMSessionMock) History() (*gollem.History, error) {
	callInfo := struct {
	}{}
	mock.lockHistory.Lock()
	mock.calls.History = append(mock.calls.History, callInfo)
	mock.lockHistory.Unlock()
	if mock.HistoryFunc == nil {
		var (
			historyOut *gollem.History
			errOut     error
		)
		return historyOut, errOut
	}
	return mock.HistoryFunc()
}

// HistoryCalls gets all the calls that were made to History.
// Check the length with:
//
//	len(mockedLLMSession.HistoryCalls())
func (mock *LLMSessionMock) HistoryCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockHistory.RLock()
	calls = mock.calls.History
	mock.lockHistory.RUnlock()
	return calls
}

// SlackEventUsecasesMock is a mock implementation of interfaces.SlackEventUsecases.
//
//	func TestSomethingThatUsesSlackEventUsecases(t *testing.T) {
//
//		// make and configure a mocked interfaces.SlackEventUsecases
//		mockedSlackEventUsecases := &SlackEventUsecasesMock{
//			HandleSlackAppMentionFunc: func(ctx context.Context, slackMsg slack.Message) error {
//				panic("mock out the HandleSlackAppMention method")
//			},
//			HandleSlackMessageFunc: func(ctx context.Context, slackMsg slack.Message) error {
//				panic("mock out the HandleSlackMessage method")
//			},
//		}
//
//		// use mockedSlackEventUsecases in code that requires interfaces.SlackEventUsecases
//		// and then make assertions.
//
//	}
type SlackEventUsecasesMock struct {
	// HandleSlackAppMentionFunc mocks the HandleSlackAppMention method.
	HandleSlackAppMentionFunc func(ctx context.Context, slackMsg slack.Message) error

	// HandleSlackMessageFunc mocks the HandleSlackMessage method.
	HandleSlackMessageFunc func(ctx context.Context, slackMsg slack.Message) error

	// calls tracks calls to the methods.
	calls struct {
		// HandleSlackAppMention holds details about calls to the HandleSlackAppMention method.
		HandleSlackAppMention []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SlackMsg is the slackMsg argument value.
			SlackMsg slack.Message
		}
		// HandleSlackMessage holds details about calls to the HandleSlackMessage method.
		HandleSlackMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SlackMsg is the slackMsg argument value.
			SlackMsg slack.Message
		}
	}
	lockHandleSlackAppMention sync.RWMutex
	lockHandleSlackMessage    sync.RWMutex
}

// HandleSlackAppMention calls HandleSlackAppMentionFunc.
func (mock *SlackEventUsecasesMock) HandleSlackAppMention(ctx context.Context, slackMsg slack.Message) error {
	callInfo := struct {
		Ctx      context.Context
		SlackMsg slack.Message
	}{
		Ctx:      ctx,
		SlackMsg: slackMsg,
	}
	mock.lockHandleSlackAppMention.Lock()
	mock.calls.HandleSlackAppMention = append(mock.calls.HandleSlackAppMention, callInfo)
	mock.lockHandleSlackAppMention.Unlock()
	if mock.HandleSlackAppMentionFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.HandleSlackAppMentionFunc(ctx, slackMsg)
}

// HandleSlackAppMentionCalls gets all the calls that were made to HandleSlackAppMention.
// Check the length with:
//
//	len(mockedSlackEventUsecases.HandleSlackAppMentionCalls())
func (mock *SlackEventUsecasesMock) HandleSlackAppMentionCalls() []struct {
	Ctx      context.Context
	SlackMsg slack.Message
} {
	var calls []struct {
		Ctx      context.Context
		SlackMsg slack.Message
	}
	mock.lockHandleSlackAppMention.RLock()
	calls = mock.calls.HandleSlackAppMention
	mock.lockHandleSlackAppMention.RUnlock()
	return calls
}

// HandleSlackMessage calls HandleSlackMessageFunc.
func (mock *SlackEventUsecasesMock) HandleSlackMessage(ctx context.Context, slackMsg slack.Message) error {
	callInfo := struct {
		Ctx      context.Context
		SlackMsg slack.Message
	}{
		Ctx:      ctx,
		SlackMsg: slackMsg,
	}
	mock.lockHandleSlackMessage.Lock()
	mock.calls.HandleSlackMessage = append(mock.calls.HandleSlackMessage, callInfo)
	mock.lockHandleSlackMessage.Unlock()
	if mock.HandleSlackMessageFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.HandleSlackMessageFunc(ctx, slackMsg)
}

// HandleSlackMessageCalls gets all the calls that were made to HandleSlackMessage.
// Check the length with:
//
//	len(mockedSlackEventUsecases.HandleSlackMessageCalls())
func (mock *SlackEventUsecasesMock) HandleSlackMessageCalls() []struct {
	Ctx      context.Context
	SlackMsg slack.Message
} {
	var calls []struct {
		Ctx      context.Context
		SlackMsg slack.Message
	}
	mock.lockHandleSlackMessage.RLock()
	calls = mock.calls.HandleSlackMessage
	mock.lockHandleSlackMessage.RUnlock()
	return calls
}

// SlackInteractionUsecasesMock is a mock implementation of interfaces.SlackInteractionUsecases.
//
//	func TestSomethingThatUsesSlackInteractionUsecases(t *testing.T) {
//
//		// make and configure a mocked interfaces.SlackInteractionUsecases
//		mockedSlackInteractionUsecases := &SlackInteractionUsecasesMock{
//			HandleSalvageRefreshFunc: func(ctx context.Context, user slack.User, metadata string, values slack.StateValue, viewID string) error {
//				panic("mock out the HandleSalvageRefresh method")
//			},
//			HandleSlackInteractionBlockActionsFunc: func(ctx context.Context, user slack.User, slackThread slack.Thread, actionID slack.ActionID, value string, triggerID string) error {
//				panic("mock out the HandleSlackInteractionBlockActions method")
//			},
//			HandleSlackInteractionViewSubmissionFunc: func(ctx context.Context, user slack.User, callbackID slack.CallbackID, metadata string, values slack.StateValue) error {
//				panic("mock out the HandleSlackInteractionViewSubmission method")
//			},
//		}
//
//		// use mockedSlackInteractionUsecases in code that requires interfaces.SlackInteractionUsecases
//		// and then make assertions.
//
//	}
type SlackInteractionUsecasesMock struct {
	// HandleSalvageRefreshFunc mocks the HandleSalvageRefresh method.
	HandleSalvageRefreshFunc func(ctx context.Context, user slack.User, metadata string, values slack.StateValue, viewID string) error

	// HandleSlackInteractionBlockActionsFunc mocks the HandleSlackInteractionBlockActions method.
	HandleSlackInteractionBlockActionsFunc func(ctx context.Context, user slack.User, slackThread slack.Thread, actionID slack.ActionID, value string, triggerID string) error

	// HandleSlackInteractionViewSubmissionFunc mocks the HandleSlackInteractionViewSubmission method.
	HandleSlackInteractionViewSubmissionFunc func(ctx context.Context, user slack.User, callbackID slack.CallbackID, metadata string, values slack.StateValue) error

	// calls tracks calls to the methods.
	calls struct {
		// HandleSalvageRefresh holds details about calls to the HandleSalvageRefresh method.
		HandleSalvageRefresh []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User slack.User
			// Metadata is the metadata argument value.
			Metadata string
			// Values is the values argument value.
			Values slack.StateValue
			// ViewID is the viewID argument value.
			ViewID string
		}
		// HandleSlackInteractionBlockActions holds details about calls to the HandleSlackInteractionBlockActions method.
		HandleSlackInteractionBlockActions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User slack.User
			// SlackThread is the slackThread argument value.
			SlackThread slack.Thread
			// ActionID is the actionID argument value.
			ActionID slack.ActionID
			// Value is the value argument value.
			Value string
			// TriggerID is the triggerID argument value.
			TriggerID string
		}
		// HandleSlackInteractionViewSubmission holds details about calls to the HandleSlackInteractionViewSubmission method.
		HandleSlackInteractionViewSubmission []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User slack.User
			// CallbackID is the callbackID argument value.
			CallbackID slack.CallbackID
			// Metadata is the metadata argument value.
			Metadata string
			// Values is the values argument value.
			Values slack.StateValue
		}
	}
	lockHandleSalvageRefresh                 sync.RWMutex
	lockHandleSlackInteractionBlockActions   sync.RWMutex
	lockHandleSlackInteractionViewSubmission sync.RWMutex
}

// HandleSalvageRefresh calls HandleSalvageRefreshFunc.
func (mock *SlackInteractionUsecasesMock) HandleSalvageRefresh(ctx context.Context, user slack.User, metadata string, values slack.StateValue, viewID string) error {
	callInfo := struct {
		Ctx      context.Context
		User     slack.User
		Metadata string
		Values   slack.StateValue
		ViewID   string
	}{
		Ctx:      ctx,
		User:     user,
		Metadata: metadata,
		Values:   values,
		ViewID:   viewID,
	}
	mock.lockHandleSalvageRefresh.Lock()
	mock.calls.HandleSalvageRefresh = append(mock.calls.HandleSalvageRefresh, callInfo)
	mock.lockHandleSalvageRefresh.Unlock()
	if mock.HandleSalvageRefreshFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.HandleSalvageRefreshFunc(ctx, user, metadata, values, viewID)
}

// HandleSalvageRefreshCalls gets all the calls that were made to HandleSalvageRefresh.
// Check the length with:
//
//	len(mockedSlackInteractionUsecases.HandleSalvageRefreshCalls())
func (mock *SlackInteractionUsecasesMock) HandleSalvageRefreshCalls() []struct {
	Ctx      context.Context
	User     slack.User
	Metadata string
	Values   slack.StateValue
	ViewID   string
} {
	var calls []struct {
		Ctx      context.Context
		User     slack.User
		Metadata string
		Values   slack.StateValue
		ViewID   string
	}
	mock.lockHandleSalvageRefresh.RLock()
	calls = mock.calls.HandleSalvageRefresh
	mock.lockHandleSalvageRefresh.RUnlock()
	return calls
}

// HandleSlackInteractionBlockActions calls HandleSlackInteractionBlockActionsFunc.
func (mock *SlackInteractionUsecasesMock) HandleSlackInteractionBlockActions(ctx context.Context, user slack.User, slackThread slack.Thread, actionID slack.ActionID, value string, triggerID string) error {
	callInfo := struct {
		Ctx         context.Context
		User        slack.User
		SlackThread slack.Thread
		ActionID    slack.ActionID
		Value       string
		TriggerID   string
	}{
		Ctx:         ctx,
		User:        user,
		SlackThread: slackThread,
		ActionID:    actionID,
		Value:       value,
		TriggerID:   triggerID,
	}
	mock.lockHandleSlackInteractionBlockActions.Lock()
	mock.calls.HandleSlackInteractionBlockActions = append(mock.calls.HandleSlackInteractionBlockActions, callInfo)
	mock.lockHandleSlackInteractionBlockActions.Unlock()
	if mock.HandleSlackInteractionBlockActionsFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.HandleSlackInteractionBlockActionsFunc(ctx, user, slackThread, actionID, value, triggerID)
}

// HandleSlackInteractionBlockActionsCalls gets all the calls that were made to HandleSlackInteractionBlockActions.
// Check the length with:
//
//	len(mockedSlackInteractionUsecases.HandleSlackInteractionBlockActionsCalls())
func (mock *SlackInteractionUsecasesMock) HandleSlackInteractionBlockActionsCalls() []struct {
	Ctx         context.Context
	User        slack.User
	SlackThread slack.Thread
	ActionID    slack.ActionID
	Value       string
	TriggerID   string
} {
	var calls []struct {
		Ctx         context.Context
		User        slack.User
		SlackThread slack.Thread
		ActionID    slack.ActionID
		Value       string
		TriggerID   string
	}
	mock.lockHandleSlackInteractionBlockActions.RLock()
	calls = mock.calls.HandleSlackInteractionBlockActions
	mock.lockHandleSlackInteractionBlockActions.RUnlock()
	return calls
}

// HandleSlackInteractionViewSubmission calls HandleSlackInteractionViewSubmissionFunc.
func (mock *SlackInteractionUsecasesMock) HandleSlackInteractionViewSubmission(ctx context.Context, user slack.User, callbackID slack.CallbackID, metadata string, values slack.StateValue) error {
	callInfo := struct {
		Ctx        context.Context
		User       slack.User
		CallbackID slack.CallbackID
		Metadata   string
		Values     slack.StateValue
	}{
		Ctx:        ctx,
		User:       user,
		CallbackID: callbackID,
		Metadata:   metadata,
		Values:     values,
	}
	mock.lockHandleSlackInteractionViewSubmission.Lock()
	mock.calls.HandleSlackInteractionViewSubmission = append(mock.calls.HandleSlackInteractionViewSubmission, callInfo)
	mock.lockHandleSlackInteractionViewSubmission.Unlock()
	if mock.HandleSlackInteractionViewSubmissionFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.HandleSlackInteractionViewSubmissionFunc(ctx, user, callbackID, metadata, values)
}

// HandleSlackInteractionViewSubmissionCalls gets all the calls that were made to HandleSlackInteractionViewSubmission.
// Check the length with:
//
//	len(mockedSlackInteractionUsecases.HandleSlackInteractionViewSubmissionCalls())
func (mock *SlackInteractionUsecasesMock) HandleSlackInteractionViewSubmissionCalls() []struct {
	Ctx        context.Context
	User       slack.User
	CallbackID slack.CallbackID
	Metadata   string
	Values     slack.StateValue
} {
	var calls []struct {
		Ctx        context.Context
		User       slack.User
		CallbackID slack.CallbackID
		Metadata   string
		Values     slack.StateValue
	}
	mock.lockHandleSlackInteractionViewSubmission.RLock()
	calls = mock.calls.HandleSlackInteractionViewSubmission
	mock.lockHandleSlackInteractionViewSubmission.RUnlock()
	return calls
}

// AlertUsecasesMock is a mock implementation of interfaces.AlertUsecases.
//
//	func TestSomethingThatUsesAlertUsecases(t *testing.T) {
//
//		// make and configure a mocked interfaces.AlertUsecases
//		mockedAlertUsecases := &AlertUsecasesMock{
//			HandleAlertFunc: func(ctx context.Context, schema types.AlertSchema, alertData any) ([]*alert.Alert, error) {
//				panic("mock out the HandleAlert method")
//			},
//		}
//
//		// use mockedAlertUsecases in code that requires interfaces.AlertUsecases
//		// and then make assertions.
//
//	}
type AlertUsecasesMock struct {
	// HandleAlertFunc mocks the HandleAlert method.
	HandleAlertFunc func(ctx context.Context, schema types.AlertSchema, alertData any) ([]*alert.Alert, error)

	// calls tracks calls to the methods.
	calls struct {
		// HandleAlert holds details about calls to the HandleAlert method.
		HandleAlert []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Schema is the schema argument value.
			Schema types.AlertSchema
			// AlertData is the alertData argument value.
			AlertData any
		}
	}
	lockHandleAlert sync.RWMutex
}

// HandleAlert calls HandleAlertFunc.
func (mock *AlertUsecasesMock) HandleAlert(ctx context.Context, schema types.AlertSchema, alertData any) ([]*alert.Alert, error) {
	callInfo := struct {
		Ctx       context.Context
		Schema    types.AlertSchema
		AlertData any
	}{
		Ctx:       ctx,
		Schema:    schema,
		AlertData: alertData,
	}
	mock.lockHandleAlert.Lock()
	mock.calls.HandleAlert = append(mock.calls.HandleAlert, callInfo)
	mock.lockHandleAlert.Unlock()
	if mock.HandleAlertFunc == nil {
		var (
			alertsOut []*alert.Alert
			errOut    error
		)
		return alertsOut, errOut
	}
	return mock.HandleAlertFunc(ctx, schema, alertData)
}

// HandleAlertCalls gets all the calls that were made to HandleAlert.
// Check the length with:
//
//	len(mockedAlertUsecases.HandleAlertCalls())
func (mock *AlertUsecasesMock) HandleAlertCalls() []struct {
	Ctx       context.Context
	Schema    types.AlertSchema
	AlertData any
} {
	var calls []struct {
		Ctx       context.Context
		Schema    types.AlertSchema
		AlertData any
	}
	mock.lockHandleAlert.RLock()
	calls = mock.calls.HandleAlert
	mock.lockHandleAlert.RUnlock()
	return calls
}

// PromptServiceMock is a mock implementation of interfaces.PromptService.
//
//	func TestSomethingThatUsesPromptService(t *testing.T) {
//
//		// make and configure a mocked interfaces.PromptService
//		mockedPromptService := &PromptServiceMock{
//			GeneratePromptFunc: func(ctx context.Context, templateName string, alertMoqParam *alert.Alert) (string, error) {
//				panic("mock out the GeneratePrompt method")
//			},
//			GeneratePromptWithParamsFunc: func(ctx context.Context, templateName string, alertMoqParam *alert.Alert, params map[string]any) (string, error) {
//				panic("mock out the GeneratePromptWithParams method")
//			},
//			ReadPromptFileFunc: func(ctx context.Context, templateName string) (string, error) {
//				panic("mock out the ReadPromptFile method")
//			},
//		}
//
//		// use mockedPromptService in code that requires interfaces.PromptService
//		// and then make assertions.
//
//	}
type PromptServiceMock struct {
	// GeneratePromptFunc mocks the GeneratePrompt method.
	GeneratePromptFunc func(ctx context.Context, templateName string, alertMoqParam *alert.Alert) (string, error)

	// GeneratePromptWithParamsFunc mocks the GeneratePromptWithParams method.
	GeneratePromptWithParamsFunc func(ctx context.Context, templateName string, alertMoqParam *alert.Alert, params map[string]any) (string, error)

	// ReadPromptFileFunc mocks the ReadPromptFile method.
	ReadPromptFileFunc func(ctx context.Context, templateName string) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// GeneratePrompt holds details about calls to the GeneratePrompt method.
		GeneratePrompt []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TemplateName is the templateName argument value.
			TemplateName string
			// AlertMoqParam is the alertMoqParam argument value.
			AlertMoqParam *alert.Alert
		}
		// GeneratePromptWithParams holds details about calls to the GeneratePromptWithParams method.
		GeneratePromptWithParams []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TemplateName is the templateName argument value.
			TemplateName string
			// AlertMoqParam is the alertMoqParam argument value.
			AlertMoqParam *alert.Alert
			// Params is the params argument value.
			Params map[string]any
		}
		// ReadPromptFile holds details about calls to the ReadPromptFile method.
		ReadPromptFile []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TemplateName is the templateName argument value.
			TemplateName string
		}
	}
	lockGeneratePrompt           sync.RWMutex
	lockGeneratePromptWithParams sync.RWMutex
	lockReadPromptFile           sync.RWMutex
}

// GeneratePrompt calls GeneratePromptFunc.
func (mock *PromptServiceMock) GeneratePrompt(ctx context.Context, templateName string, alertMoqParam *alert.Alert) (string, error) {
	callInfo := struct {
		Ctx           context.Context
		TemplateName  string
		AlertMoqParam *alert.Alert
	}{
		Ctx:           ctx,
		TemplateName:  templateName,
		AlertMoqParam: alertMoqParam,
	}
	mock.lockGeneratePrompt.Lock()
	mock.calls.GeneratePrompt = append(mock.calls.GeneratePrompt, callInfo)
	mock.lockGeneratePrompt.Unlock()
	if mock.GeneratePromptFunc == nil {
		var (
			sOut   string
			errOut error
		)
		return sOut, errOut
	}
	return mock.GeneratePromptFunc(ctx, templateName, alertMoqParam)
}

// GeneratePromptCalls gets all the calls that were made to GeneratePrompt.
// Check the length with:
//
//	len(mockedPromptService.GeneratePromptCalls())
func (mock *PromptServiceMock) GeneratePromptCalls() []struct {
	Ctx           context.Context
	TemplateName  string
	AlertMoqParam *alert.Alert
} {
	var calls []struct {
		Ctx           context.Context
		TemplateName  string
		AlertMoqParam *alert.Alert
	}
	mock.lockGeneratePrompt.RLock()
	calls = mock.calls.GeneratePrompt
	mock.lockGeneratePrompt.RUnlock()
	return calls
}

// GeneratePromptWithParams calls GeneratePromptWithParamsFunc.
func (mock *PromptServiceMock) GeneratePromptWithParams(ctx context.Context, templateName string, alertMoqParam *alert.Alert, params map[string]any) (string, error) {
	callInfo := struct {
		Ctx           context.Context
		TemplateName  string
		AlertMoqParam *alert.Alert
		Params        map[string]any
	}{
		Ctx:           ctx,
		TemplateName:  templateName,
		AlertMoqParam: alertMoqParam,
		Params:        params,
	}
	mock.lockGeneratePromptWithParams.Lock()
	mock.calls.GeneratePromptWithParams = append(mock.calls.GeneratePromptWithParams, callInfo)
	mock.lockGeneratePromptWithParams.Unlock()
	if mock.GeneratePromptWithParamsFunc == nil {
		var (
			sOut   string
			errOut error
		)
		return sOut, errOut
	}
	return mock.GeneratePromptWithParamsFunc(ctx, templateName, alertMoqParam, params)
}

// GeneratePromptWithParamsCalls gets all the calls that were made to GeneratePromptWithParams.
// Check the length with:
//
//	len(mockedPromptService.GeneratePromptWithParamsCalls())
func (mock *PromptServiceMock) GeneratePromptWithParamsCalls() []struct {
	Ctx           context.Context
	TemplateName  string
	AlertMoqParam *alert.Alert
	Params        map[string]any
} {
	var calls []struct {
		Ctx           context.Context
		TemplateName  string
		AlertMoqParam *alert.Alert
		Params        map[string]any
	}
	mock.lockGeneratePromptWithParams.RLock()
	calls = mock.calls.GeneratePromptWithParams
	mock.lockGeneratePromptWithParams.RUnlock()
	return calls
}

// ReadPromptFile calls ReadPromptFileFunc.
func (mock *PromptServiceMock) ReadPromptFile(ctx context.Context, templateName string) (string, error) {
	callInfo := struct {
		Ctx          context.Context
		TemplateName string
	}{
		Ctx:          ctx,
		TemplateName: templateName,
	}
	mock.lockReadPromptFile.Lock()
	mock.calls.ReadPromptFile = append(mock.calls.ReadPromptFile, callInfo)
	mock.lockReadPromptFile.Unlock()
	if mock.ReadPromptFileFunc == nil {
		var (
			sOut   string
			errOut error
		)
		return sOut, errOut
	}
	return mock.ReadPromptFileFunc(ctx, templateName)
}

// ReadPromptFileCalls gets all the calls that were made to ReadPromptFile.
// Check the length with:
//
//	len(mockedPromptService.ReadPromptFileCalls())
func (mock *PromptServiceMock) ReadPromptFileCalls() []struct {
	Ctx          context.Context
	TemplateName string
} {
	var calls []struct {
		Ctx          context.Context
		TemplateName string
	}
	mock.lockReadPromptFile.RLock()
	calls = mock.calls.ReadPromptFile
	mock.lockReadPromptFile.RUnlock()
	return calls
}
