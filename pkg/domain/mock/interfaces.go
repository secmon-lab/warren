// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/m-mizutani/gollem"
	"github.com/m-mizutani/opaq"
	"github.com/secmon-lab/warren/pkg/domain/model/activity"
	"github.com/secmon-lab/warren/pkg/domain/model/alert"
	"github.com/secmon-lab/warren/pkg/domain/model/auth"
	modelslack "github.com/secmon-lab/warren/pkg/domain/model/slack"
	"github.com/secmon-lab/warren/pkg/domain/model/ticket"
	"github.com/secmon-lab/warren/pkg/domain/types"
	slackslack "github.com/slack-go/slack"
	"io"
	"sync"
	"time"
)

// SlackClientMock is a mock implementation of interfaces.SlackClient.
//
//	func TestSomethingThatUsesSlackClient(t *testing.T) {
//
//		// make and configure a mocked interfaces.SlackClient
//		mockedSlackClient := &SlackClientMock{
//			AuthTestFunc: func() (*slackslack.AuthTestResponse, error) {
//				panic("mock out the AuthTest method")
//			},
//			GetBotInfoContextFunc: func(ctx context.Context, parameters slackslack.GetBotInfoParameters) (*slackslack.Bot, error) {
//				panic("mock out the GetBotInfoContext method")
//			},
//			GetConversationInfoFunc: func(input *slackslack.GetConversationInfoInput) (*slackslack.Channel, error) {
//				panic("mock out the GetConversationInfo method")
//			},
//			GetTeamInfoFunc: func() (*slackslack.TeamInfo, error) {
//				panic("mock out the GetTeamInfo method")
//			},
//			GetUserGroupsFunc: func(options ...slackslack.GetUserGroupsOption) ([]slackslack.UserGroup, error) {
//				panic("mock out the GetUserGroups method")
//			},
//			GetUserInfoFunc: func(userID string) (*slackslack.User, error) {
//				panic("mock out the GetUserInfo method")
//			},
//			GetUsersInfoFunc: func(users ...string) (*[]slackslack.User, error) {
//				panic("mock out the GetUsersInfo method")
//			},
//			OpenViewFunc: func(triggerID string, view slackslack.ModalViewRequest) (*slackslack.ViewResponse, error) {
//				panic("mock out the OpenView method")
//			},
//			PostMessageContextFunc: func(ctx context.Context, channelID string, options ...slackslack.MsgOption) (string, string, error) {
//				panic("mock out the PostMessageContext method")
//			},
//			UpdateMessageContextFunc: func(ctx context.Context, channelID string, timestamp string, options ...slackslack.MsgOption) (string, string, string, error) {
//				panic("mock out the UpdateMessageContext method")
//			},
//			UpdateViewFunc: func(view slackslack.ModalViewRequest, externalID string, hash string, viewID string) (*slackslack.ViewResponse, error) {
//				panic("mock out the UpdateView method")
//			},
//			UploadFileV2ContextFunc: func(ctx context.Context, params slackslack.UploadFileV2Parameters) (*slackslack.FileSummary, error) {
//				panic("mock out the UploadFileV2Context method")
//			},
//		}
//
//		// use mockedSlackClient in code that requires interfaces.SlackClient
//		// and then make assertions.
//
//	}
type SlackClientMock struct {
	// AuthTestFunc mocks the AuthTest method.
	AuthTestFunc func() (*slackslack.AuthTestResponse, error)

	// GetBotInfoContextFunc mocks the GetBotInfoContext method.
	GetBotInfoContextFunc func(ctx context.Context, parameters slackslack.GetBotInfoParameters) (*slackslack.Bot, error)

	// GetConversationInfoFunc mocks the GetConversationInfo method.
	GetConversationInfoFunc func(input *slackslack.GetConversationInfoInput) (*slackslack.Channel, error)

	// GetTeamInfoFunc mocks the GetTeamInfo method.
	GetTeamInfoFunc func() (*slackslack.TeamInfo, error)

	// GetUserGroupsFunc mocks the GetUserGroups method.
	GetUserGroupsFunc func(options ...slackslack.GetUserGroupsOption) ([]slackslack.UserGroup, error)

	// GetUserInfoFunc mocks the GetUserInfo method.
	GetUserInfoFunc func(userID string) (*slackslack.User, error)

	// GetUsersInfoFunc mocks the GetUsersInfo method.
	GetUsersInfoFunc func(users ...string) (*[]slackslack.User, error)

	// OpenViewFunc mocks the OpenView method.
	OpenViewFunc func(triggerID string, view slackslack.ModalViewRequest) (*slackslack.ViewResponse, error)

	// PostMessageContextFunc mocks the PostMessageContext method.
	PostMessageContextFunc func(ctx context.Context, channelID string, options ...slackslack.MsgOption) (string, string, error)

	// UpdateMessageContextFunc mocks the UpdateMessageContext method.
	UpdateMessageContextFunc func(ctx context.Context, channelID string, timestamp string, options ...slackslack.MsgOption) (string, string, string, error)

	// UpdateViewFunc mocks the UpdateView method.
	UpdateViewFunc func(view slackslack.ModalViewRequest, externalID string, hash string, viewID string) (*slackslack.ViewResponse, error)

	// UploadFileV2ContextFunc mocks the UploadFileV2Context method.
	UploadFileV2ContextFunc func(ctx context.Context, params slackslack.UploadFileV2Parameters) (*slackslack.FileSummary, error)

	// calls tracks calls to the methods.
	calls struct {
		// AuthTest holds details about calls to the AuthTest method.
		AuthTest []struct {
		}
		// GetBotInfoContext holds details about calls to the GetBotInfoContext method.
		GetBotInfoContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Parameters is the parameters argument value.
			Parameters slackslack.GetBotInfoParameters
		}
		// GetConversationInfo holds details about calls to the GetConversationInfo method.
		GetConversationInfo []struct {
			// Input is the input argument value.
			Input *slackslack.GetConversationInfoInput
		}
		// GetTeamInfo holds details about calls to the GetTeamInfo method.
		GetTeamInfo []struct {
		}
		// GetUserGroups holds details about calls to the GetUserGroups method.
		GetUserGroups []struct {
			// Options is the options argument value.
			Options []slackslack.GetUserGroupsOption
		}
		// GetUserInfo holds details about calls to the GetUserInfo method.
		GetUserInfo []struct {
			// UserID is the userID argument value.
			UserID string
		}
		// GetUsersInfo holds details about calls to the GetUsersInfo method.
		GetUsersInfo []struct {
			// Users is the users argument value.
			Users []string
		}
		// OpenView holds details about calls to the OpenView method.
		OpenView []struct {
			// TriggerID is the triggerID argument value.
			TriggerID string
			// View is the view argument value.
			View slackslack.ModalViewRequest
		}
		// PostMessageContext holds details about calls to the PostMessageContext method.
		PostMessageContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ChannelID is the channelID argument value.
			ChannelID string
			// Options is the options argument value.
			Options []slackslack.MsgOption
		}
		// UpdateMessageContext holds details about calls to the UpdateMessageContext method.
		UpdateMessageContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ChannelID is the channelID argument value.
			ChannelID string
			// Timestamp is the timestamp argument value.
			Timestamp string
			// Options is the options argument value.
			Options []slackslack.MsgOption
		}
		// UpdateView holds details about calls to the UpdateView method.
		UpdateView []struct {
			// View is the view argument value.
			View slackslack.ModalViewRequest
			// ExternalID is the externalID argument value.
			ExternalID string
			// Hash is the hash argument value.
			Hash string
			// ViewID is the viewID argument value.
			ViewID string
		}
		// UploadFileV2Context holds details about calls to the UploadFileV2Context method.
		UploadFileV2Context []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params slackslack.UploadFileV2Parameters
		}
	}
	lockAuthTest             sync.RWMutex
	lockGetBotInfoContext    sync.RWMutex
	lockGetConversationInfo  sync.RWMutex
	lockGetTeamInfo          sync.RWMutex
	lockGetUserGroups        sync.RWMutex
	lockGetUserInfo          sync.RWMutex
	lockGetUsersInfo         sync.RWMutex
	lockOpenView             sync.RWMutex
	lockPostMessageContext   sync.RWMutex
	lockUpdateMessageContext sync.RWMutex
	lockUpdateView           sync.RWMutex
	lockUploadFileV2Context  sync.RWMutex
}

// AuthTest calls AuthTestFunc.
func (mock *SlackClientMock) AuthTest() (*slackslack.AuthTestResponse, error) {
	callInfo := struct {
	}{}
	mock.lockAuthTest.Lock()
	mock.calls.AuthTest = append(mock.calls.AuthTest, callInfo)
	mock.lockAuthTest.Unlock()
	if mock.AuthTestFunc == nil {
		var (
			authTestResponseOut *slackslack.AuthTestResponse
			errOut              error
		)
		return authTestResponseOut, errOut
	}
	return mock.AuthTestFunc()
}

// AuthTestCalls gets all the calls that were made to AuthTest.
// Check the length with:
//
//	len(mockedSlackClient.AuthTestCalls())
func (mock *SlackClientMock) AuthTestCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockAuthTest.RLock()
	calls = mock.calls.AuthTest
	mock.lockAuthTest.RUnlock()
	return calls
}

// GetBotInfoContext calls GetBotInfoContextFunc.
func (mock *SlackClientMock) GetBotInfoContext(ctx context.Context, parameters slackslack.GetBotInfoParameters) (*slackslack.Bot, error) {
	callInfo := struct {
		Ctx        context.Context
		Parameters slackslack.GetBotInfoParameters
	}{
		Ctx:        ctx,
		Parameters: parameters,
	}
	mock.lockGetBotInfoContext.Lock()
	mock.calls.GetBotInfoContext = append(mock.calls.GetBotInfoContext, callInfo)
	mock.lockGetBotInfoContext.Unlock()
	if mock.GetBotInfoContextFunc == nil {
		var (
			botOut *slackslack.Bot
			errOut error
		)
		return botOut, errOut
	}
	return mock.GetBotInfoContextFunc(ctx, parameters)
}

// GetBotInfoContextCalls gets all the calls that were made to GetBotInfoContext.
// Check the length with:
//
//	len(mockedSlackClient.GetBotInfoContextCalls())
func (mock *SlackClientMock) GetBotInfoContextCalls() []struct {
	Ctx        context.Context
	Parameters slackslack.GetBotInfoParameters
} {
	var calls []struct {
		Ctx        context.Context
		Parameters slackslack.GetBotInfoParameters
	}
	mock.lockGetBotInfoContext.RLock()
	calls = mock.calls.GetBotInfoContext
	mock.lockGetBotInfoContext.RUnlock()
	return calls
}

// GetConversationInfo calls GetConversationInfoFunc.
func (mock *SlackClientMock) GetConversationInfo(input *slackslack.GetConversationInfoInput) (*slackslack.Channel, error) {
	callInfo := struct {
		Input *slackslack.GetConversationInfoInput
	}{
		Input: input,
	}
	mock.lockGetConversationInfo.Lock()
	mock.calls.GetConversationInfo = append(mock.calls.GetConversationInfo, callInfo)
	mock.lockGetConversationInfo.Unlock()
	if mock.GetConversationInfoFunc == nil {
		var (
			channelOut *slackslack.Channel
			errOut     error
		)
		return channelOut, errOut
	}
	return mock.GetConversationInfoFunc(input)
}

// GetConversationInfoCalls gets all the calls that were made to GetConversationInfo.
// Check the length with:
//
//	len(mockedSlackClient.GetConversationInfoCalls())
func (mock *SlackClientMock) GetConversationInfoCalls() []struct {
	Input *slackslack.GetConversationInfoInput
} {
	var calls []struct {
		Input *slackslack.GetConversationInfoInput
	}
	mock.lockGetConversationInfo.RLock()
	calls = mock.calls.GetConversationInfo
	mock.lockGetConversationInfo.RUnlock()
	return calls
}

// GetTeamInfo calls GetTeamInfoFunc.
func (mock *SlackClientMock) GetTeamInfo() (*slackslack.TeamInfo, error) {
	callInfo := struct {
	}{}
	mock.lockGetTeamInfo.Lock()
	mock.calls.GetTeamInfo = append(mock.calls.GetTeamInfo, callInfo)
	mock.lockGetTeamInfo.Unlock()
	if mock.GetTeamInfoFunc == nil {
		var (
			teamInfoOut *slackslack.TeamInfo
			errOut      error
		)
		return teamInfoOut, errOut
	}
	return mock.GetTeamInfoFunc()
}

// GetTeamInfoCalls gets all the calls that were made to GetTeamInfo.
// Check the length with:
//
//	len(mockedSlackClient.GetTeamInfoCalls())
func (mock *SlackClientMock) GetTeamInfoCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetTeamInfo.RLock()
	calls = mock.calls.GetTeamInfo
	mock.lockGetTeamInfo.RUnlock()
	return calls
}

// GetUserGroups calls GetUserGroupsFunc.
func (mock *SlackClientMock) GetUserGroups(options ...slackslack.GetUserGroupsOption) ([]slackslack.UserGroup, error) {
	callInfo := struct {
		Options []slackslack.GetUserGroupsOption
	}{
		Options: options,
	}
	mock.lockGetUserGroups.Lock()
	mock.calls.GetUserGroups = append(mock.calls.GetUserGroups, callInfo)
	mock.lockGetUserGroups.Unlock()
	if mock.GetUserGroupsFunc == nil {
		var (
			userGroupsOut []slackslack.UserGroup
			errOut        error
		)
		return userGroupsOut, errOut
	}
	return mock.GetUserGroupsFunc(options...)
}

// GetUserGroupsCalls gets all the calls that were made to GetUserGroups.
// Check the length with:
//
//	len(mockedSlackClient.GetUserGroupsCalls())
func (mock *SlackClientMock) GetUserGroupsCalls() []struct {
	Options []slackslack.GetUserGroupsOption
} {
	var calls []struct {
		Options []slackslack.GetUserGroupsOption
	}
	mock.lockGetUserGroups.RLock()
	calls = mock.calls.GetUserGroups
	mock.lockGetUserGroups.RUnlock()
	return calls
}

// GetUserInfo calls GetUserInfoFunc.
func (mock *SlackClientMock) GetUserInfo(userID string) (*slackslack.User, error) {
	callInfo := struct {
		UserID string
	}{
		UserID: userID,
	}
	mock.lockGetUserInfo.Lock()
	mock.calls.GetUserInfo = append(mock.calls.GetUserInfo, callInfo)
	mock.lockGetUserInfo.Unlock()
	if mock.GetUserInfoFunc == nil {
		var (
			userOut *slackslack.User
			errOut  error
		)
		return userOut, errOut
	}
	return mock.GetUserInfoFunc(userID)
}

// GetUserInfoCalls gets all the calls that were made to GetUserInfo.
// Check the length with:
//
//	len(mockedSlackClient.GetUserInfoCalls())
func (mock *SlackClientMock) GetUserInfoCalls() []struct {
	UserID string
} {
	var calls []struct {
		UserID string
	}
	mock.lockGetUserInfo.RLock()
	calls = mock.calls.GetUserInfo
	mock.lockGetUserInfo.RUnlock()
	return calls
}

// GetUsersInfo calls GetUsersInfoFunc.
func (mock *SlackClientMock) GetUsersInfo(users ...string) (*[]slackslack.User, error) {
	callInfo := struct {
		Users []string
	}{
		Users: users,
	}
	mock.lockGetUsersInfo.Lock()
	mock.calls.GetUsersInfo = append(mock.calls.GetUsersInfo, callInfo)
	mock.lockGetUsersInfo.Unlock()
	if mock.GetUsersInfoFunc == nil {
		var (
			usersOut *[]slackslack.User
			errOut   error
		)
		return usersOut, errOut
	}
	return mock.GetUsersInfoFunc(users...)
}

// GetUsersInfoCalls gets all the calls that were made to GetUsersInfo.
// Check the length with:
//
//	len(mockedSlackClient.GetUsersInfoCalls())
func (mock *SlackClientMock) GetUsersInfoCalls() []struct {
	Users []string
} {
	var calls []struct {
		Users []string
	}
	mock.lockGetUsersInfo.RLock()
	calls = mock.calls.GetUsersInfo
	mock.lockGetUsersInfo.RUnlock()
	return calls
}

// OpenView calls OpenViewFunc.
func (mock *SlackClientMock) OpenView(triggerID string, view slackslack.ModalViewRequest) (*slackslack.ViewResponse, error) {
	callInfo := struct {
		TriggerID string
		View      slackslack.ModalViewRequest
	}{
		TriggerID: triggerID,
		View:      view,
	}
	mock.lockOpenView.Lock()
	mock.calls.OpenView = append(mock.calls.OpenView, callInfo)
	mock.lockOpenView.Unlock()
	if mock.OpenViewFunc == nil {
		var (
			viewResponseOut *slackslack.ViewResponse
			errOut          error
		)
		return viewResponseOut, errOut
	}
	return mock.OpenViewFunc(triggerID, view)
}

// OpenViewCalls gets all the calls that were made to OpenView.
// Check the length with:
//
//	len(mockedSlackClient.OpenViewCalls())
func (mock *SlackClientMock) OpenViewCalls() []struct {
	TriggerID string
	View      slackslack.ModalViewRequest
} {
	var calls []struct {
		TriggerID string
		View      slackslack.ModalViewRequest
	}
	mock.lockOpenView.RLock()
	calls = mock.calls.OpenView
	mock.lockOpenView.RUnlock()
	return calls
}

// PostMessageContext calls PostMessageContextFunc.
func (mock *SlackClientMock) PostMessageContext(ctx context.Context, channelID string, options ...slackslack.MsgOption) (string, string, error) {
	callInfo := struct {
		Ctx       context.Context
		ChannelID string
		Options   []slackslack.MsgOption
	}{
		Ctx:       ctx,
		ChannelID: channelID,
		Options:   options,
	}
	mock.lockPostMessageContext.Lock()
	mock.calls.PostMessageContext = append(mock.calls.PostMessageContext, callInfo)
	mock.lockPostMessageContext.Unlock()
	if mock.PostMessageContextFunc == nil {
		var (
			sOut1  string
			sOut2  string
			errOut error
		)
		return sOut1, sOut2, errOut
	}
	return mock.PostMessageContextFunc(ctx, channelID, options...)
}

// PostMessageContextCalls gets all the calls that were made to PostMessageContext.
// Check the length with:
//
//	len(mockedSlackClient.PostMessageContextCalls())
func (mock *SlackClientMock) PostMessageContextCalls() []struct {
	Ctx       context.Context
	ChannelID string
	Options   []slackslack.MsgOption
} {
	var calls []struct {
		Ctx       context.Context
		ChannelID string
		Options   []slackslack.MsgOption
	}
	mock.lockPostMessageContext.RLock()
	calls = mock.calls.PostMessageContext
	mock.lockPostMessageContext.RUnlock()
	return calls
}

// UpdateMessageContext calls UpdateMessageContextFunc.
func (mock *SlackClientMock) UpdateMessageContext(ctx context.Context, channelID string, timestamp string, options ...slackslack.MsgOption) (string, string, string, error) {
	callInfo := struct {
		Ctx       context.Context
		ChannelID string
		Timestamp string
		Options   []slackslack.MsgOption
	}{
		Ctx:       ctx,
		ChannelID: channelID,
		Timestamp: timestamp,
		Options:   options,
	}
	mock.lockUpdateMessageContext.Lock()
	mock.calls.UpdateMessageContext = append(mock.calls.UpdateMessageContext, callInfo)
	mock.lockUpdateMessageContext.Unlock()
	if mock.UpdateMessageContextFunc == nil {
		var (
			sOut1  string
			sOut2  string
			sOut3  string
			errOut error
		)
		return sOut1, sOut2, sOut3, errOut
	}
	return mock.UpdateMessageContextFunc(ctx, channelID, timestamp, options...)
}

// UpdateMessageContextCalls gets all the calls that were made to UpdateMessageContext.
// Check the length with:
//
//	len(mockedSlackClient.UpdateMessageContextCalls())
func (mock *SlackClientMock) UpdateMessageContextCalls() []struct {
	Ctx       context.Context
	ChannelID string
	Timestamp string
	Options   []slackslack.MsgOption
} {
	var calls []struct {
		Ctx       context.Context
		ChannelID string
		Timestamp string
		Options   []slackslack.MsgOption
	}
	mock.lockUpdateMessageContext.RLock()
	calls = mock.calls.UpdateMessageContext
	mock.lockUpdateMessageContext.RUnlock()
	return calls
}

// UpdateView calls UpdateViewFunc.
func (mock *SlackClientMock) UpdateView(view slackslack.ModalViewRequest, externalID string, hash string, viewID string) (*slackslack.ViewResponse, error) {
	callInfo := struct {
		View       slackslack.ModalViewRequest
		ExternalID string
		Hash       string
		ViewID     string
	}{
		View:       view,
		ExternalID: externalID,
		Hash:       hash,
		ViewID:     viewID,
	}
	mock.lockUpdateView.Lock()
	mock.calls.UpdateView = append(mock.calls.UpdateView, callInfo)
	mock.lockUpdateView.Unlock()
	if mock.UpdateViewFunc == nil {
		var (
			viewResponseOut *slackslack.ViewResponse
			errOut          error
		)
		return viewResponseOut, errOut
	}
	return mock.UpdateViewFunc(view, externalID, hash, viewID)
}

// UpdateViewCalls gets all the calls that were made to UpdateView.
// Check the length with:
//
//	len(mockedSlackClient.UpdateViewCalls())
func (mock *SlackClientMock) UpdateViewCalls() []struct {
	View       slackslack.ModalViewRequest
	ExternalID string
	Hash       string
	ViewID     string
} {
	var calls []struct {
		View       slackslack.ModalViewRequest
		ExternalID string
		Hash       string
		ViewID     string
	}
	mock.lockUpdateView.RLock()
	calls = mock.calls.UpdateView
	mock.lockUpdateView.RUnlock()
	return calls
}

// UploadFileV2Context calls UploadFileV2ContextFunc.
func (mock *SlackClientMock) UploadFileV2Context(ctx context.Context, params slackslack.UploadFileV2Parameters) (*slackslack.FileSummary, error) {
	callInfo := struct {
		Ctx    context.Context
		Params slackslack.UploadFileV2Parameters
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockUploadFileV2Context.Lock()
	mock.calls.UploadFileV2Context = append(mock.calls.UploadFileV2Context, callInfo)
	mock.lockUploadFileV2Context.Unlock()
	if mock.UploadFileV2ContextFunc == nil {
		var (
			fileSummaryOut *slackslack.FileSummary
			errOut         error
		)
		return fileSummaryOut, errOut
	}
	return mock.UploadFileV2ContextFunc(ctx, params)
}

// UploadFileV2ContextCalls gets all the calls that were made to UploadFileV2Context.
// Check the length with:
//
//	len(mockedSlackClient.UploadFileV2ContextCalls())
func (mock *SlackClientMock) UploadFileV2ContextCalls() []struct {
	Ctx    context.Context
	Params slackslack.UploadFileV2Parameters
} {
	var calls []struct {
		Ctx    context.Context
		Params slackslack.UploadFileV2Parameters
	}
	mock.lockUploadFileV2Context.RLock()
	calls = mock.calls.UploadFileV2Context
	mock.lockUploadFileV2Context.RUnlock()
	return calls
}

// SlackThreadServiceMock is a mock implementation of interfaces.SlackThreadService.
//
//	func TestSomethingThatUsesSlackThreadService(t *testing.T) {
//
//		// make and configure a mocked interfaces.SlackThreadService
//		mockedSlackThreadService := &SlackThreadServiceMock{
//			NewStateFuncFunc: func(ctx context.Context, message string) func(ctx context.Context, msg string) {
//				panic("mock out the NewStateFunc method")
//			},
//			ReplyFunc: func(ctx context.Context, message string)  {
//				panic("mock out the Reply method")
//			},
//		}
//
//		// use mockedSlackThreadService in code that requires interfaces.SlackThreadService
//		// and then make assertions.
//
//	}
type SlackThreadServiceMock struct {
	// NewStateFuncFunc mocks the NewStateFunc method.
	NewStateFuncFunc func(ctx context.Context, message string) func(ctx context.Context, msg string)

	// ReplyFunc mocks the Reply method.
	ReplyFunc func(ctx context.Context, message string)

	// calls tracks calls to the methods.
	calls struct {
		// NewStateFunc holds details about calls to the NewStateFunc method.
		NewStateFunc []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Message is the message argument value.
			Message string
		}
		// Reply holds details about calls to the Reply method.
		Reply []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Message is the message argument value.
			Message string
		}
	}
	lockNewStateFunc sync.RWMutex
	lockReply        sync.RWMutex
}

// NewStateFunc calls NewStateFuncFunc.
func (mock *SlackThreadServiceMock) NewStateFunc(ctx context.Context, message string) func(ctx context.Context, msg string) {
	callInfo := struct {
		Ctx     context.Context
		Message string
	}{
		Ctx:     ctx,
		Message: message,
	}
	mock.lockNewStateFunc.Lock()
	mock.calls.NewStateFunc = append(mock.calls.NewStateFunc, callInfo)
	mock.lockNewStateFunc.Unlock()
	if mock.NewStateFuncFunc == nil {
		var (
			fnOut func(ctx context.Context, msg string)
		)
		return fnOut
	}
	return mock.NewStateFuncFunc(ctx, message)
}

// NewStateFuncCalls gets all the calls that were made to NewStateFunc.
// Check the length with:
//
//	len(mockedSlackThreadService.NewStateFuncCalls())
func (mock *SlackThreadServiceMock) NewStateFuncCalls() []struct {
	Ctx     context.Context
	Message string
} {
	var calls []struct {
		Ctx     context.Context
		Message string
	}
	mock.lockNewStateFunc.RLock()
	calls = mock.calls.NewStateFunc
	mock.lockNewStateFunc.RUnlock()
	return calls
}

// Reply calls ReplyFunc.
func (mock *SlackThreadServiceMock) Reply(ctx context.Context, message string) {
	callInfo := struct {
		Ctx     context.Context
		Message string
	}{
		Ctx:     ctx,
		Message: message,
	}
	mock.lockReply.Lock()
	mock.calls.Reply = append(mock.calls.Reply, callInfo)
	mock.lockReply.Unlock()
	if mock.ReplyFunc == nil {
		return
	}
	mock.ReplyFunc(ctx, message)
}

// ReplyCalls gets all the calls that were made to Reply.
// Check the length with:
//
//	len(mockedSlackThreadService.ReplyCalls())
func (mock *SlackThreadServiceMock) ReplyCalls() []struct {
	Ctx     context.Context
	Message string
} {
	var calls []struct {
		Ctx     context.Context
		Message string
	}
	mock.lockReply.RLock()
	calls = mock.calls.Reply
	mock.lockReply.RUnlock()
	return calls
}

// RepositoryMock is a mock implementation of interfaces.Repository.
//
//	func TestSomethingThatUsesRepository(t *testing.T) {
//
//		// make and configure a mocked interfaces.Repository
//		mockedRepository := &RepositoryMock{
//			BatchGetAlertsFunc: func(ctx context.Context, alertIDs []types.AlertID) (alert.Alerts, error) {
//				panic("mock out the BatchGetAlerts method")
//			},
//			BatchGetTicketsFunc: func(ctx context.Context, ticketIDs []types.TicketID) ([]*ticket.Ticket, error) {
//				panic("mock out the BatchGetTickets method")
//			},
//			BatchPutAlertsFunc: func(ctx context.Context, alerts alert.Alerts) error {
//				panic("mock out the BatchPutAlerts method")
//			},
//			BatchUpdateTicketsStatusFunc: func(ctx context.Context, ticketIDs []types.TicketID, status types.TicketStatus) error {
//				panic("mock out the BatchUpdateTicketsStatus method")
//			},
//			BindAlertsToTicketFunc: func(ctx context.Context, alertIDs []types.AlertID, ticketID types.TicketID) error {
//				panic("mock out the BindAlertsToTicket method")
//			},
//			CountActivitiesFunc: func(ctx context.Context) (int, error) {
//				panic("mock out the CountActivities method")
//			},
//			CountAlertsWithoutTicketFunc: func(ctx context.Context) (int, error) {
//				panic("mock out the CountAlertsWithoutTicket method")
//			},
//			CountTicketCommentsFunc: func(ctx context.Context, ticketID types.TicketID) (int, error) {
//				panic("mock out the CountTicketComments method")
//			},
//			CountTicketsByStatusFunc: func(ctx context.Context, statuses []types.TicketStatus) (int, error) {
//				panic("mock out the CountTicketsByStatus method")
//			},
//			DeleteTokenFunc: func(ctx context.Context, tokenID auth.TokenID) error {
//				panic("mock out the DeleteToken method")
//			},
//			FindNearestAlertsFunc: func(ctx context.Context, embedding []float32, limit int) (alert.Alerts, error) {
//				panic("mock out the FindNearestAlerts method")
//			},
//			FindNearestTicketsFunc: func(ctx context.Context, embedding []float32, limit int) ([]*ticket.Ticket, error) {
//				panic("mock out the FindNearestTickets method")
//			},
//			FindNearestTicketsWithSpanFunc: func(ctx context.Context, embedding []float32, begin time.Time, end time.Time, limit int) ([]*ticket.Ticket, error) {
//				panic("mock out the FindNearestTicketsWithSpan method")
//			},
//			GetActivitiesFunc: func(ctx context.Context, offset int, limit int) ([]*activity.Activity, error) {
//				panic("mock out the GetActivities method")
//			},
//			GetAlertFunc: func(ctx context.Context, alertID types.AlertID) (*alert.Alert, error) {
//				panic("mock out the GetAlert method")
//			},
//			GetAlertListFunc: func(ctx context.Context, listID types.AlertListID) (*alert.List, error) {
//				panic("mock out the GetAlertList method")
//			},
//			GetAlertListByThreadFunc: func(ctx context.Context, thread modelslack.Thread) (*alert.List, error) {
//				panic("mock out the GetAlertListByThread method")
//			},
//			GetAlertListsInThreadFunc: func(ctx context.Context, thread modelslack.Thread) ([]*alert.List, error) {
//				panic("mock out the GetAlertListsInThread method")
//			},
//			GetAlertWithoutEmbeddingFunc: func(ctx context.Context) (alert.Alerts, error) {
//				panic("mock out the GetAlertWithoutEmbedding method")
//			},
//			GetAlertWithoutTicketFunc: func(ctx context.Context, offset int, limit int) (alert.Alerts, error) {
//				panic("mock out the GetAlertWithoutTicket method")
//			},
//			GetAlertsBySpanFunc: func(ctx context.Context, begin time.Time, end time.Time) (alert.Alerts, error) {
//				panic("mock out the GetAlertsBySpan method")
//			},
//			GetAlertsWithInvalidEmbeddingFunc: func(ctx context.Context) (alert.Alerts, error) {
//				panic("mock out the GetAlertsWithInvalidEmbedding method")
//			},
//			GetLatestAlertByThreadFunc: func(ctx context.Context, thread modelslack.Thread) (*alert.Alert, error) {
//				panic("mock out the GetLatestAlertByThread method")
//			},
//			GetLatestAlertListInThreadFunc: func(ctx context.Context, thread modelslack.Thread) (*alert.List, error) {
//				panic("mock out the GetLatestAlertListInThread method")
//			},
//			GetLatestHistoryFunc: func(ctx context.Context, ticketID types.TicketID) (*ticket.History, error) {
//				panic("mock out the GetLatestHistory method")
//			},
//			GetTicketFunc: func(ctx context.Context, ticketID types.TicketID) (*ticket.Ticket, error) {
//				panic("mock out the GetTicket method")
//			},
//			GetTicketByThreadFunc: func(ctx context.Context, thread modelslack.Thread) (*ticket.Ticket, error) {
//				panic("mock out the GetTicketByThread method")
//			},
//			GetTicketCommentsFunc: func(ctx context.Context, ticketID types.TicketID) ([]ticket.Comment, error) {
//				panic("mock out the GetTicketComments method")
//			},
//			GetTicketCommentsPaginatedFunc: func(ctx context.Context, ticketID types.TicketID, offset int, limit int) ([]ticket.Comment, error) {
//				panic("mock out the GetTicketCommentsPaginated method")
//			},
//			GetTicketUnpromptedCommentsFunc: func(ctx context.Context, ticketID types.TicketID) ([]ticket.Comment, error) {
//				panic("mock out the GetTicketUnpromptedComments method")
//			},
//			GetTicketsBySpanFunc: func(ctx context.Context, begin time.Time, end time.Time) ([]*ticket.Ticket, error) {
//				panic("mock out the GetTicketsBySpan method")
//			},
//			GetTicketsByStatusFunc: func(ctx context.Context, statuses []types.TicketStatus, offset int, limit int) ([]*ticket.Ticket, error) {
//				panic("mock out the GetTicketsByStatus method")
//			},
//			GetTicketsByStatusAndSpanFunc: func(ctx context.Context, status types.TicketStatus, begin time.Time, end time.Time) ([]*ticket.Ticket, error) {
//				panic("mock out the GetTicketsByStatusAndSpan method")
//			},
//			GetTicketsWithInvalidEmbeddingFunc: func(ctx context.Context) ([]*ticket.Ticket, error) {
//				panic("mock out the GetTicketsWithInvalidEmbedding method")
//			},
//			GetTokenFunc: func(ctx context.Context, tokenID auth.TokenID) (*auth.Token, error) {
//				panic("mock out the GetToken method")
//			},
//			PutActivityFunc: func(ctx context.Context, activityMoqParam *activity.Activity) error {
//				panic("mock out the PutActivity method")
//			},
//			PutAlertFunc: func(ctx context.Context, alertMoqParam alert.Alert) error {
//				panic("mock out the PutAlert method")
//			},
//			PutAlertListFunc: func(ctx context.Context, list *alert.List) error {
//				panic("mock out the PutAlertList method")
//			},
//			PutHistoryFunc: func(ctx context.Context, ticketID types.TicketID, history *ticket.History) error {
//				panic("mock out the PutHistory method")
//			},
//			PutTicketFunc: func(ctx context.Context, ticketMoqParam ticket.Ticket) error {
//				panic("mock out the PutTicket method")
//			},
//			PutTicketCommentFunc: func(ctx context.Context, comment ticket.Comment) error {
//				panic("mock out the PutTicketComment method")
//			},
//			PutTicketCommentsPromptedFunc: func(ctx context.Context, ticketID types.TicketID, commentIDs []types.CommentID) error {
//				panic("mock out the PutTicketCommentsPrompted method")
//			},
//			PutTokenFunc: func(ctx context.Context, token *auth.Token) error {
//				panic("mock out the PutToken method")
//			},
//			SearchAlertsFunc: func(ctx context.Context, path string, op string, value any, limit int) (alert.Alerts, error) {
//				panic("mock out the SearchAlerts method")
//			},
//			UnbindAlertFromTicketFunc: func(ctx context.Context, alertID types.AlertID) error {
//				panic("mock out the UnbindAlertFromTicket method")
//			},
//		}
//
//		// use mockedRepository in code that requires interfaces.Repository
//		// and then make assertions.
//
//	}
type RepositoryMock struct {
	// BatchGetAlertsFunc mocks the BatchGetAlerts method.
	BatchGetAlertsFunc func(ctx context.Context, alertIDs []types.AlertID) (alert.Alerts, error)

	// BatchGetTicketsFunc mocks the BatchGetTickets method.
	BatchGetTicketsFunc func(ctx context.Context, ticketIDs []types.TicketID) ([]*ticket.Ticket, error)

	// BatchPutAlertsFunc mocks the BatchPutAlerts method.
	BatchPutAlertsFunc func(ctx context.Context, alerts alert.Alerts) error

	// BatchUpdateTicketsStatusFunc mocks the BatchUpdateTicketsStatus method.
	BatchUpdateTicketsStatusFunc func(ctx context.Context, ticketIDs []types.TicketID, status types.TicketStatus) error

	// BindAlertsToTicketFunc mocks the BindAlertsToTicket method.
	BindAlertsToTicketFunc func(ctx context.Context, alertIDs []types.AlertID, ticketID types.TicketID) error

	// CountActivitiesFunc mocks the CountActivities method.
	CountActivitiesFunc func(ctx context.Context) (int, error)

	// CountAlertsWithoutTicketFunc mocks the CountAlertsWithoutTicket method.
	CountAlertsWithoutTicketFunc func(ctx context.Context) (int, error)

	// CountTicketCommentsFunc mocks the CountTicketComments method.
	CountTicketCommentsFunc func(ctx context.Context, ticketID types.TicketID) (int, error)

	// CountTicketsByStatusFunc mocks the CountTicketsByStatus method.
	CountTicketsByStatusFunc func(ctx context.Context, statuses []types.TicketStatus) (int, error)

	// DeleteTokenFunc mocks the DeleteToken method.
	DeleteTokenFunc func(ctx context.Context, tokenID auth.TokenID) error

	// FindNearestAlertsFunc mocks the FindNearestAlerts method.
	FindNearestAlertsFunc func(ctx context.Context, embedding []float32, limit int) (alert.Alerts, error)

	// FindNearestTicketsFunc mocks the FindNearestTickets method.
	FindNearestTicketsFunc func(ctx context.Context, embedding []float32, limit int) ([]*ticket.Ticket, error)

	// FindNearestTicketsWithSpanFunc mocks the FindNearestTicketsWithSpan method.
	FindNearestTicketsWithSpanFunc func(ctx context.Context, embedding []float32, begin time.Time, end time.Time, limit int) ([]*ticket.Ticket, error)

	// GetActivitiesFunc mocks the GetActivities method.
	GetActivitiesFunc func(ctx context.Context, offset int, limit int) ([]*activity.Activity, error)

	// GetAlertFunc mocks the GetAlert method.
	GetAlertFunc func(ctx context.Context, alertID types.AlertID) (*alert.Alert, error)

	// GetAlertListFunc mocks the GetAlertList method.
	GetAlertListFunc func(ctx context.Context, listID types.AlertListID) (*alert.List, error)

	// GetAlertListByThreadFunc mocks the GetAlertListByThread method.
	GetAlertListByThreadFunc func(ctx context.Context, thread modelslack.Thread) (*alert.List, error)

	// GetAlertListsInThreadFunc mocks the GetAlertListsInThread method.
	GetAlertListsInThreadFunc func(ctx context.Context, thread modelslack.Thread) ([]*alert.List, error)

	// GetAlertWithoutEmbeddingFunc mocks the GetAlertWithoutEmbedding method.
	GetAlertWithoutEmbeddingFunc func(ctx context.Context) (alert.Alerts, error)

	// GetAlertWithoutTicketFunc mocks the GetAlertWithoutTicket method.
	GetAlertWithoutTicketFunc func(ctx context.Context, offset int, limit int) (alert.Alerts, error)

	// GetAlertsBySpanFunc mocks the GetAlertsBySpan method.
	GetAlertsBySpanFunc func(ctx context.Context, begin time.Time, end time.Time) (alert.Alerts, error)

	// GetAlertsWithInvalidEmbeddingFunc mocks the GetAlertsWithInvalidEmbedding method.
	GetAlertsWithInvalidEmbeddingFunc func(ctx context.Context) (alert.Alerts, error)

	// GetLatestAlertByThreadFunc mocks the GetLatestAlertByThread method.
	GetLatestAlertByThreadFunc func(ctx context.Context, thread modelslack.Thread) (*alert.Alert, error)

	// GetLatestAlertListInThreadFunc mocks the GetLatestAlertListInThread method.
	GetLatestAlertListInThreadFunc func(ctx context.Context, thread modelslack.Thread) (*alert.List, error)

	// GetLatestHistoryFunc mocks the GetLatestHistory method.
	GetLatestHistoryFunc func(ctx context.Context, ticketID types.TicketID) (*ticket.History, error)

	// GetTicketFunc mocks the GetTicket method.
	GetTicketFunc func(ctx context.Context, ticketID types.TicketID) (*ticket.Ticket, error)

	// GetTicketByThreadFunc mocks the GetTicketByThread method.
	GetTicketByThreadFunc func(ctx context.Context, thread modelslack.Thread) (*ticket.Ticket, error)

	// GetTicketCommentsFunc mocks the GetTicketComments method.
	GetTicketCommentsFunc func(ctx context.Context, ticketID types.TicketID) ([]ticket.Comment, error)

	// GetTicketCommentsPaginatedFunc mocks the GetTicketCommentsPaginated method.
	GetTicketCommentsPaginatedFunc func(ctx context.Context, ticketID types.TicketID, offset int, limit int) ([]ticket.Comment, error)

	// GetTicketUnpromptedCommentsFunc mocks the GetTicketUnpromptedComments method.
	GetTicketUnpromptedCommentsFunc func(ctx context.Context, ticketID types.TicketID) ([]ticket.Comment, error)

	// GetTicketsBySpanFunc mocks the GetTicketsBySpan method.
	GetTicketsBySpanFunc func(ctx context.Context, begin time.Time, end time.Time) ([]*ticket.Ticket, error)

	// GetTicketsByStatusFunc mocks the GetTicketsByStatus method.
	GetTicketsByStatusFunc func(ctx context.Context, statuses []types.TicketStatus, offset int, limit int) ([]*ticket.Ticket, error)

	// GetTicketsByStatusAndSpanFunc mocks the GetTicketsByStatusAndSpan method.
	GetTicketsByStatusAndSpanFunc func(ctx context.Context, status types.TicketStatus, begin time.Time, end time.Time) ([]*ticket.Ticket, error)

	// GetTicketsWithInvalidEmbeddingFunc mocks the GetTicketsWithInvalidEmbedding method.
	GetTicketsWithInvalidEmbeddingFunc func(ctx context.Context) ([]*ticket.Ticket, error)

	// GetTokenFunc mocks the GetToken method.
	GetTokenFunc func(ctx context.Context, tokenID auth.TokenID) (*auth.Token, error)

	// PutActivityFunc mocks the PutActivity method.
	PutActivityFunc func(ctx context.Context, activityMoqParam *activity.Activity) error

	// PutAlertFunc mocks the PutAlert method.
	PutAlertFunc func(ctx context.Context, alertMoqParam alert.Alert) error

	// PutAlertListFunc mocks the PutAlertList method.
	PutAlertListFunc func(ctx context.Context, list *alert.List) error

	// PutHistoryFunc mocks the PutHistory method.
	PutHistoryFunc func(ctx context.Context, ticketID types.TicketID, history *ticket.History) error

	// PutTicketFunc mocks the PutTicket method.
	PutTicketFunc func(ctx context.Context, ticketMoqParam ticket.Ticket) error

	// PutTicketCommentFunc mocks the PutTicketComment method.
	PutTicketCommentFunc func(ctx context.Context, comment ticket.Comment) error

	// PutTicketCommentsPromptedFunc mocks the PutTicketCommentsPrompted method.
	PutTicketCommentsPromptedFunc func(ctx context.Context, ticketID types.TicketID, commentIDs []types.CommentID) error

	// PutTokenFunc mocks the PutToken method.
	PutTokenFunc func(ctx context.Context, token *auth.Token) error

	// SearchAlertsFunc mocks the SearchAlerts method.
	SearchAlertsFunc func(ctx context.Context, path string, op string, value any, limit int) (alert.Alerts, error)

	// UnbindAlertFromTicketFunc mocks the UnbindAlertFromTicket method.
	UnbindAlertFromTicketFunc func(ctx context.Context, alertID types.AlertID) error

	// calls tracks calls to the methods.
	calls struct {
		// BatchGetAlerts holds details about calls to the BatchGetAlerts method.
		BatchGetAlerts []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AlertIDs is the alertIDs argument value.
			AlertIDs []types.AlertID
		}
		// BatchGetTickets holds details about calls to the BatchGetTickets method.
		BatchGetTickets []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketIDs is the ticketIDs argument value.
			TicketIDs []types.TicketID
		}
		// BatchPutAlerts holds details about calls to the BatchPutAlerts method.
		BatchPutAlerts []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Alerts is the alerts argument value.
			Alerts alert.Alerts
		}
		// BatchUpdateTicketsStatus holds details about calls to the BatchUpdateTicketsStatus method.
		BatchUpdateTicketsStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketIDs is the ticketIDs argument value.
			TicketIDs []types.TicketID
			// Status is the status argument value.
			Status types.TicketStatus
		}
		// BindAlertsToTicket holds details about calls to the BindAlertsToTicket method.
		BindAlertsToTicket []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AlertIDs is the alertIDs argument value.
			AlertIDs []types.AlertID
			// TicketID is the ticketID argument value.
			TicketID types.TicketID
		}
		// CountActivities holds details about calls to the CountActivities method.
		CountActivities []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// CountAlertsWithoutTicket holds details about calls to the CountAlertsWithoutTicket method.
		CountAlertsWithoutTicket []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// CountTicketComments holds details about calls to the CountTicketComments method.
		CountTicketComments []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketID is the ticketID argument value.
			TicketID types.TicketID
		}
		// CountTicketsByStatus holds details about calls to the CountTicketsByStatus method.
		CountTicketsByStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Statuses is the statuses argument value.
			Statuses []types.TicketStatus
		}
		// DeleteToken holds details about calls to the DeleteToken method.
		DeleteToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TokenID is the tokenID argument value.
			TokenID auth.TokenID
		}
		// FindNearestAlerts holds details about calls to the FindNearestAlerts method.
		FindNearestAlerts []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Embedding is the embedding argument value.
			Embedding []float32
			// Limit is the limit argument value.
			Limit int
		}
		// FindNearestTickets holds details about calls to the FindNearestTickets method.
		FindNearestTickets []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Embedding is the embedding argument value.
			Embedding []float32
			// Limit is the limit argument value.
			Limit int
		}
		// FindNearestTicketsWithSpan holds details about calls to the FindNearestTicketsWithSpan method.
		FindNearestTicketsWithSpan []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Embedding is the embedding argument value.
			Embedding []float32
			// Begin is the begin argument value.
			Begin time.Time
			// End is the end argument value.
			End time.Time
			// Limit is the limit argument value.
			Limit int
		}
		// GetActivities holds details about calls to the GetActivities method.
		GetActivities []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
		}
		// GetAlert holds details about calls to the GetAlert method.
		GetAlert []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AlertID is the alertID argument value.
			AlertID types.AlertID
		}
		// GetAlertList holds details about calls to the GetAlertList method.
		GetAlertList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ListID is the listID argument value.
			ListID types.AlertListID
		}
		// GetAlertListByThread holds details about calls to the GetAlertListByThread method.
		GetAlertListByThread []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Thread is the thread argument value.
			Thread modelslack.Thread
		}
		// GetAlertListsInThread holds details about calls to the GetAlertListsInThread method.
		GetAlertListsInThread []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Thread is the thread argument value.
			Thread modelslack.Thread
		}
		// GetAlertWithoutEmbedding holds details about calls to the GetAlertWithoutEmbedding method.
		GetAlertWithoutEmbedding []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetAlertWithoutTicket holds details about calls to the GetAlertWithoutTicket method.
		GetAlertWithoutTicket []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
		}
		// GetAlertsBySpan holds details about calls to the GetAlertsBySpan method.
		GetAlertsBySpan []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Begin is the begin argument value.
			Begin time.Time
			// End is the end argument value.
			End time.Time
		}
		// GetAlertsWithInvalidEmbedding holds details about calls to the GetAlertsWithInvalidEmbedding method.
		GetAlertsWithInvalidEmbedding []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetLatestAlertByThread holds details about calls to the GetLatestAlertByThread method.
		GetLatestAlertByThread []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Thread is the thread argument value.
			Thread modelslack.Thread
		}
		// GetLatestAlertListInThread holds details about calls to the GetLatestAlertListInThread method.
		GetLatestAlertListInThread []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Thread is the thread argument value.
			Thread modelslack.Thread
		}
		// GetLatestHistory holds details about calls to the GetLatestHistory method.
		GetLatestHistory []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketID is the ticketID argument value.
			TicketID types.TicketID
		}
		// GetTicket holds details about calls to the GetTicket method.
		GetTicket []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketID is the ticketID argument value.
			TicketID types.TicketID
		}
		// GetTicketByThread holds details about calls to the GetTicketByThread method.
		GetTicketByThread []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Thread is the thread argument value.
			Thread modelslack.Thread
		}
		// GetTicketComments holds details about calls to the GetTicketComments method.
		GetTicketComments []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketID is the ticketID argument value.
			TicketID types.TicketID
		}
		// GetTicketCommentsPaginated holds details about calls to the GetTicketCommentsPaginated method.
		GetTicketCommentsPaginated []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketID is the ticketID argument value.
			TicketID types.TicketID
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
		}
		// GetTicketUnpromptedComments holds details about calls to the GetTicketUnpromptedComments method.
		GetTicketUnpromptedComments []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketID is the ticketID argument value.
			TicketID types.TicketID
		}
		// GetTicketsBySpan holds details about calls to the GetTicketsBySpan method.
		GetTicketsBySpan []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Begin is the begin argument value.
			Begin time.Time
			// End is the end argument value.
			End time.Time
		}
		// GetTicketsByStatus holds details about calls to the GetTicketsByStatus method.
		GetTicketsByStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Statuses is the statuses argument value.
			Statuses []types.TicketStatus
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
		}
		// GetTicketsByStatusAndSpan holds details about calls to the GetTicketsByStatusAndSpan method.
		GetTicketsByStatusAndSpan []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Status is the status argument value.
			Status types.TicketStatus
			// Begin is the begin argument value.
			Begin time.Time
			// End is the end argument value.
			End time.Time
		}
		// GetTicketsWithInvalidEmbedding holds details about calls to the GetTicketsWithInvalidEmbedding method.
		GetTicketsWithInvalidEmbedding []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetToken holds details about calls to the GetToken method.
		GetToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TokenID is the tokenID argument value.
			TokenID auth.TokenID
		}
		// PutActivity holds details about calls to the PutActivity method.
		PutActivity []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ActivityMoqParam is the activityMoqParam argument value.
			ActivityMoqParam *activity.Activity
		}
		// PutAlert holds details about calls to the PutAlert method.
		PutAlert []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AlertMoqParam is the alertMoqParam argument value.
			AlertMoqParam alert.Alert
		}
		// PutAlertList holds details about calls to the PutAlertList method.
		PutAlertList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// List is the list argument value.
			List *alert.List
		}
		// PutHistory holds details about calls to the PutHistory method.
		PutHistory []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketID is the ticketID argument value.
			TicketID types.TicketID
			// History is the history argument value.
			History *ticket.History
		}
		// PutTicket holds details about calls to the PutTicket method.
		PutTicket []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketMoqParam is the ticketMoqParam argument value.
			TicketMoqParam ticket.Ticket
		}
		// PutTicketComment holds details about calls to the PutTicketComment method.
		PutTicketComment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Comment is the comment argument value.
			Comment ticket.Comment
		}
		// PutTicketCommentsPrompted holds details about calls to the PutTicketCommentsPrompted method.
		PutTicketCommentsPrompted []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TicketID is the ticketID argument value.
			TicketID types.TicketID
			// CommentIDs is the commentIDs argument value.
			CommentIDs []types.CommentID
		}
		// PutToken holds details about calls to the PutToken method.
		PutToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Token is the token argument value.
			Token *auth.Token
		}
		// SearchAlerts holds details about calls to the SearchAlerts method.
		SearchAlerts []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Path is the path argument value.
			Path string
			// Op is the op argument value.
			Op string
			// Value is the value argument value.
			Value any
			// Limit is the limit argument value.
			Limit int
		}
		// UnbindAlertFromTicket holds details about calls to the UnbindAlertFromTicket method.
		UnbindAlertFromTicket []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AlertID is the alertID argument value.
			AlertID types.AlertID
		}
	}
	lockBatchGetAlerts                 sync.RWMutex
	lockBatchGetTickets                sync.RWMutex
	lockBatchPutAlerts                 sync.RWMutex
	lockBatchUpdateTicketsStatus       sync.RWMutex
	lockBindAlertsToTicket             sync.RWMutex
	lockCountActivities                sync.RWMutex
	lockCountAlertsWithoutTicket       sync.RWMutex
	lockCountTicketComments            sync.RWMutex
	lockCountTicketsByStatus           sync.RWMutex
	lockDeleteToken                    sync.RWMutex
	lockFindNearestAlerts              sync.RWMutex
	lockFindNearestTickets             sync.RWMutex
	lockFindNearestTicketsWithSpan     sync.RWMutex
	lockGetActivities                  sync.RWMutex
	lockGetAlert                       sync.RWMutex
	lockGetAlertList                   sync.RWMutex
	lockGetAlertListByThread           sync.RWMutex
	lockGetAlertListsInThread          sync.RWMutex
	lockGetAlertWithoutEmbedding       sync.RWMutex
	lockGetAlertWithoutTicket          sync.RWMutex
	lockGetAlertsBySpan                sync.RWMutex
	lockGetAlertsWithInvalidEmbedding  sync.RWMutex
	lockGetLatestAlertByThread         sync.RWMutex
	lockGetLatestAlertListInThread     sync.RWMutex
	lockGetLatestHistory               sync.RWMutex
	lockGetTicket                      sync.RWMutex
	lockGetTicketByThread              sync.RWMutex
	lockGetTicketComments              sync.RWMutex
	lockGetTicketCommentsPaginated     sync.RWMutex
	lockGetTicketUnpromptedComments    sync.RWMutex
	lockGetTicketsBySpan               sync.RWMutex
	lockGetTicketsByStatus             sync.RWMutex
	lockGetTicketsByStatusAndSpan      sync.RWMutex
	lockGetTicketsWithInvalidEmbedding sync.RWMutex
	lockGetToken                       sync.RWMutex
	lockPutActivity                    sync.RWMutex
	lockPutAlert                       sync.RWMutex
	lockPutAlertList                   sync.RWMutex
	lockPutHistory                     sync.RWMutex
	lockPutTicket                      sync.RWMutex
	lockPutTicketComment               sync.RWMutex
	lockPutTicketCommentsPrompted      sync.RWMutex
	lockPutToken                       sync.RWMutex
	lockSearchAlerts                   sync.RWMutex
	lockUnbindAlertFromTicket          sync.RWMutex
}

// BatchGetAlerts calls BatchGetAlertsFunc.
func (mock *RepositoryMock) BatchGetAlerts(ctx context.Context, alertIDs []types.AlertID) (alert.Alerts, error) {
	callInfo := struct {
		Ctx      context.Context
		AlertIDs []types.AlertID
	}{
		Ctx:      ctx,
		AlertIDs: alertIDs,
	}
	mock.lockBatchGetAlerts.Lock()
	mock.calls.BatchGetAlerts = append(mock.calls.BatchGetAlerts, callInfo)
	mock.lockBatchGetAlerts.Unlock()
	if mock.BatchGetAlertsFunc == nil {
		var (
			alertsOut alert.Alerts
			errOut    error
		)
		return alertsOut, errOut
	}
	return mock.BatchGetAlertsFunc(ctx, alertIDs)
}

// BatchGetAlertsCalls gets all the calls that were made to BatchGetAlerts.
// Check the length with:
//
//	len(mockedRepository.BatchGetAlertsCalls())
func (mock *RepositoryMock) BatchGetAlertsCalls() []struct {
	Ctx      context.Context
	AlertIDs []types.AlertID
} {
	var calls []struct {
		Ctx      context.Context
		AlertIDs []types.AlertID
	}
	mock.lockBatchGetAlerts.RLock()
	calls = mock.calls.BatchGetAlerts
	mock.lockBatchGetAlerts.RUnlock()
	return calls
}

// BatchGetTickets calls BatchGetTicketsFunc.
func (mock *RepositoryMock) BatchGetTickets(ctx context.Context, ticketIDs []types.TicketID) ([]*ticket.Ticket, error) {
	callInfo := struct {
		Ctx       context.Context
		TicketIDs []types.TicketID
	}{
		Ctx:       ctx,
		TicketIDs: ticketIDs,
	}
	mock.lockBatchGetTickets.Lock()
	mock.calls.BatchGetTickets = append(mock.calls.BatchGetTickets, callInfo)
	mock.lockBatchGetTickets.Unlock()
	if mock.BatchGetTicketsFunc == nil {
		var (
			ticketsOut []*ticket.Ticket
			errOut     error
		)
		return ticketsOut, errOut
	}
	return mock.BatchGetTicketsFunc(ctx, ticketIDs)
}

// BatchGetTicketsCalls gets all the calls that were made to BatchGetTickets.
// Check the length with:
//
//	len(mockedRepository.BatchGetTicketsCalls())
func (mock *RepositoryMock) BatchGetTicketsCalls() []struct {
	Ctx       context.Context
	TicketIDs []types.TicketID
} {
	var calls []struct {
		Ctx       context.Context
		TicketIDs []types.TicketID
	}
	mock.lockBatchGetTickets.RLock()
	calls = mock.calls.BatchGetTickets
	mock.lockBatchGetTickets.RUnlock()
	return calls
}

// BatchPutAlerts calls BatchPutAlertsFunc.
func (mock *RepositoryMock) BatchPutAlerts(ctx context.Context, alerts alert.Alerts) error {
	callInfo := struct {
		Ctx    context.Context
		Alerts alert.Alerts
	}{
		Ctx:    ctx,
		Alerts: alerts,
	}
	mock.lockBatchPutAlerts.Lock()
	mock.calls.BatchPutAlerts = append(mock.calls.BatchPutAlerts, callInfo)
	mock.lockBatchPutAlerts.Unlock()
	if mock.BatchPutAlertsFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.BatchPutAlertsFunc(ctx, alerts)
}

// BatchPutAlertsCalls gets all the calls that were made to BatchPutAlerts.
// Check the length with:
//
//	len(mockedRepository.BatchPutAlertsCalls())
func (mock *RepositoryMock) BatchPutAlertsCalls() []struct {
	Ctx    context.Context
	Alerts alert.Alerts
} {
	var calls []struct {
		Ctx    context.Context
		Alerts alert.Alerts
	}
	mock.lockBatchPutAlerts.RLock()
	calls = mock.calls.BatchPutAlerts
	mock.lockBatchPutAlerts.RUnlock()
	return calls
}

// BatchUpdateTicketsStatus calls BatchUpdateTicketsStatusFunc.
func (mock *RepositoryMock) BatchUpdateTicketsStatus(ctx context.Context, ticketIDs []types.TicketID, status types.TicketStatus) error {
	callInfo := struct {
		Ctx       context.Context
		TicketIDs []types.TicketID
		Status    types.TicketStatus
	}{
		Ctx:       ctx,
		TicketIDs: ticketIDs,
		Status:    status,
	}
	mock.lockBatchUpdateTicketsStatus.Lock()
	mock.calls.BatchUpdateTicketsStatus = append(mock.calls.BatchUpdateTicketsStatus, callInfo)
	mock.lockBatchUpdateTicketsStatus.Unlock()
	if mock.BatchUpdateTicketsStatusFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.BatchUpdateTicketsStatusFunc(ctx, ticketIDs, status)
}

// BatchUpdateTicketsStatusCalls gets all the calls that were made to BatchUpdateTicketsStatus.
// Check the length with:
//
//	len(mockedRepository.BatchUpdateTicketsStatusCalls())
func (mock *RepositoryMock) BatchUpdateTicketsStatusCalls() []struct {
	Ctx       context.Context
	TicketIDs []types.TicketID
	Status    types.TicketStatus
} {
	var calls []struct {
		Ctx       context.Context
		TicketIDs []types.TicketID
		Status    types.TicketStatus
	}
	mock.lockBatchUpdateTicketsStatus.RLock()
	calls = mock.calls.BatchUpdateTicketsStatus
	mock.lockBatchUpdateTicketsStatus.RUnlock()
	return calls
}

// BindAlertsToTicket calls BindAlertsToTicketFunc.
func (mock *RepositoryMock) BindAlertsToTicket(ctx context.Context, alertIDs []types.AlertID, ticketID types.TicketID) error {
	callInfo := struct {
		Ctx      context.Context
		AlertIDs []types.AlertID
		TicketID types.TicketID
	}{
		Ctx:      ctx,
		AlertIDs: alertIDs,
		TicketID: ticketID,
	}
	mock.lockBindAlertsToTicket.Lock()
	mock.calls.BindAlertsToTicket = append(mock.calls.BindAlertsToTicket, callInfo)
	mock.lockBindAlertsToTicket.Unlock()
	if mock.BindAlertsToTicketFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.BindAlertsToTicketFunc(ctx, alertIDs, ticketID)
}

// BindAlertsToTicketCalls gets all the calls that were made to BindAlertsToTicket.
// Check the length with:
//
//	len(mockedRepository.BindAlertsToTicketCalls())
func (mock *RepositoryMock) BindAlertsToTicketCalls() []struct {
	Ctx      context.Context
	AlertIDs []types.AlertID
	TicketID types.TicketID
} {
	var calls []struct {
		Ctx      context.Context
		AlertIDs []types.AlertID
		TicketID types.TicketID
	}
	mock.lockBindAlertsToTicket.RLock()
	calls = mock.calls.BindAlertsToTicket
	mock.lockBindAlertsToTicket.RUnlock()
	return calls
}

// CountActivities calls CountActivitiesFunc.
func (mock *RepositoryMock) CountActivities(ctx context.Context) (int, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockCountActivities.Lock()
	mock.calls.CountActivities = append(mock.calls.CountActivities, callInfo)
	mock.lockCountActivities.Unlock()
	if mock.CountActivitiesFunc == nil {
		var (
			nOut   int
			errOut error
		)
		return nOut, errOut
	}
	return mock.CountActivitiesFunc(ctx)
}

// CountActivitiesCalls gets all the calls that were made to CountActivities.
// Check the length with:
//
//	len(mockedRepository.CountActivitiesCalls())
func (mock *RepositoryMock) CountActivitiesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockCountActivities.RLock()
	calls = mock.calls.CountActivities
	mock.lockCountActivities.RUnlock()
	return calls
}

// CountAlertsWithoutTicket calls CountAlertsWithoutTicketFunc.
func (mock *RepositoryMock) CountAlertsWithoutTicket(ctx context.Context) (int, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockCountAlertsWithoutTicket.Lock()
	mock.calls.CountAlertsWithoutTicket = append(mock.calls.CountAlertsWithoutTicket, callInfo)
	mock.lockCountAlertsWithoutTicket.Unlock()
	if mock.CountAlertsWithoutTicketFunc == nil {
		var (
			nOut   int
			errOut error
		)
		return nOut, errOut
	}
	return mock.CountAlertsWithoutTicketFunc(ctx)
}

// CountAlertsWithoutTicketCalls gets all the calls that were made to CountAlertsWithoutTicket.
// Check the length with:
//
//	len(mockedRepository.CountAlertsWithoutTicketCalls())
func (mock *RepositoryMock) CountAlertsWithoutTicketCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockCountAlertsWithoutTicket.RLock()
	calls = mock.calls.CountAlertsWithoutTicket
	mock.lockCountAlertsWithoutTicket.RUnlock()
	return calls
}

// CountTicketComments calls CountTicketCommentsFunc.
func (mock *RepositoryMock) CountTicketComments(ctx context.Context, ticketID types.TicketID) (int, error) {
	callInfo := struct {
		Ctx      context.Context
		TicketID types.TicketID
	}{
		Ctx:      ctx,
		TicketID: ticketID,
	}
	mock.lockCountTicketComments.Lock()
	mock.calls.CountTicketComments = append(mock.calls.CountTicketComments, callInfo)
	mock.lockCountTicketComments.Unlock()
	if mock.CountTicketCommentsFunc == nil {
		var (
			nOut   int
			errOut error
		)
		return nOut, errOut
	}
	return mock.CountTicketCommentsFunc(ctx, ticketID)
}

// CountTicketCommentsCalls gets all the calls that were made to CountTicketComments.
// Check the length with:
//
//	len(mockedRepository.CountTicketCommentsCalls())
func (mock *RepositoryMock) CountTicketCommentsCalls() []struct {
	Ctx      context.Context
	TicketID types.TicketID
} {
	var calls []struct {
		Ctx      context.Context
		TicketID types.TicketID
	}
	mock.lockCountTicketComments.RLock()
	calls = mock.calls.CountTicketComments
	mock.lockCountTicketComments.RUnlock()
	return calls
}

// CountTicketsByStatus calls CountTicketsByStatusFunc.
func (mock *RepositoryMock) CountTicketsByStatus(ctx context.Context, statuses []types.TicketStatus) (int, error) {
	callInfo := struct {
		Ctx      context.Context
		Statuses []types.TicketStatus
	}{
		Ctx:      ctx,
		Statuses: statuses,
	}
	mock.lockCountTicketsByStatus.Lock()
	mock.calls.CountTicketsByStatus = append(mock.calls.CountTicketsByStatus, callInfo)
	mock.lockCountTicketsByStatus.Unlock()
	if mock.CountTicketsByStatusFunc == nil {
		var (
			nOut   int
			errOut error
		)
		return nOut, errOut
	}
	return mock.CountTicketsByStatusFunc(ctx, statuses)
}

// CountTicketsByStatusCalls gets all the calls that were made to CountTicketsByStatus.
// Check the length with:
//
//	len(mockedRepository.CountTicketsByStatusCalls())
func (mock *RepositoryMock) CountTicketsByStatusCalls() []struct {
	Ctx      context.Context
	Statuses []types.TicketStatus
} {
	var calls []struct {
		Ctx      context.Context
		Statuses []types.TicketStatus
	}
	mock.lockCountTicketsByStatus.RLock()
	calls = mock.calls.CountTicketsByStatus
	mock.lockCountTicketsByStatus.RUnlock()
	return calls
}

// DeleteToken calls DeleteTokenFunc.
func (mock *RepositoryMock) DeleteToken(ctx context.Context, tokenID auth.TokenID) error {
	callInfo := struct {
		Ctx     context.Context
		TokenID auth.TokenID
	}{
		Ctx:     ctx,
		TokenID: tokenID,
	}
	mock.lockDeleteToken.Lock()
	mock.calls.DeleteToken = append(mock.calls.DeleteToken, callInfo)
	mock.lockDeleteToken.Unlock()
	if mock.DeleteTokenFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.DeleteTokenFunc(ctx, tokenID)
}

// DeleteTokenCalls gets all the calls that were made to DeleteToken.
// Check the length with:
//
//	len(mockedRepository.DeleteTokenCalls())
func (mock *RepositoryMock) DeleteTokenCalls() []struct {
	Ctx     context.Context
	TokenID auth.TokenID
} {
	var calls []struct {
		Ctx     context.Context
		TokenID auth.TokenID
	}
	mock.lockDeleteToken.RLock()
	calls = mock.calls.DeleteToken
	mock.lockDeleteToken.RUnlock()
	return calls
}

// FindNearestAlerts calls FindNearestAlertsFunc.
func (mock *RepositoryMock) FindNearestAlerts(ctx context.Context, embedding []float32, limit int) (alert.Alerts, error) {
	callInfo := struct {
		Ctx       context.Context
		Embedding []float32
		Limit     int
	}{
		Ctx:       ctx,
		Embedding: embedding,
		Limit:     limit,
	}
	mock.lockFindNearestAlerts.Lock()
	mock.calls.FindNearestAlerts = append(mock.calls.FindNearestAlerts, callInfo)
	mock.lockFindNearestAlerts.Unlock()
	if mock.FindNearestAlertsFunc == nil {
		var (
			alertsOut alert.Alerts
			errOut    error
		)
		return alertsOut, errOut
	}
	return mock.FindNearestAlertsFunc(ctx, embedding, limit)
}

// FindNearestAlertsCalls gets all the calls that were made to FindNearestAlerts.
// Check the length with:
//
//	len(mockedRepository.FindNearestAlertsCalls())
func (mock *RepositoryMock) FindNearestAlertsCalls() []struct {
	Ctx       context.Context
	Embedding []float32
	Limit     int
} {
	var calls []struct {
		Ctx       context.Context
		Embedding []float32
		Limit     int
	}
	mock.lockFindNearestAlerts.RLock()
	calls = mock.calls.FindNearestAlerts
	mock.lockFindNearestAlerts.RUnlock()
	return calls
}

// FindNearestTickets calls FindNearestTicketsFunc.
func (mock *RepositoryMock) FindNearestTickets(ctx context.Context, embedding []float32, limit int) ([]*ticket.Ticket, error) {
	callInfo := struct {
		Ctx       context.Context
		Embedding []float32
		Limit     int
	}{
		Ctx:       ctx,
		Embedding: embedding,
		Limit:     limit,
	}
	mock.lockFindNearestTickets.Lock()
	mock.calls.FindNearestTickets = append(mock.calls.FindNearestTickets, callInfo)
	mock.lockFindNearestTickets.Unlock()
	if mock.FindNearestTicketsFunc == nil {
		var (
			ticketsOut []*ticket.Ticket
			errOut     error
		)
		return ticketsOut, errOut
	}
	return mock.FindNearestTicketsFunc(ctx, embedding, limit)
}

// FindNearestTicketsCalls gets all the calls that were made to FindNearestTickets.
// Check the length with:
//
//	len(mockedRepository.FindNearestTicketsCalls())
func (mock *RepositoryMock) FindNearestTicketsCalls() []struct {
	Ctx       context.Context
	Embedding []float32
	Limit     int
} {
	var calls []struct {
		Ctx       context.Context
		Embedding []float32
		Limit     int
	}
	mock.lockFindNearestTickets.RLock()
	calls = mock.calls.FindNearestTickets
	mock.lockFindNearestTickets.RUnlock()
	return calls
}

// FindNearestTicketsWithSpan calls FindNearestTicketsWithSpanFunc.
func (mock *RepositoryMock) FindNearestTicketsWithSpan(ctx context.Context, embedding []float32, begin time.Time, end time.Time, limit int) ([]*ticket.Ticket, error) {
	callInfo := struct {
		Ctx       context.Context
		Embedding []float32
		Begin     time.Time
		End       time.Time
		Limit     int
	}{
		Ctx:       ctx,
		Embedding: embedding,
		Begin:     begin,
		End:       end,
		Limit:     limit,
	}
	mock.lockFindNearestTicketsWithSpan.Lock()
	mock.calls.FindNearestTicketsWithSpan = append(mock.calls.FindNearestTicketsWithSpan, callInfo)
	mock.lockFindNearestTicketsWithSpan.Unlock()
	if mock.FindNearestTicketsWithSpanFunc == nil {
		var (
			ticketsOut []*ticket.Ticket
			errOut     error
		)
		return ticketsOut, errOut
	}
	return mock.FindNearestTicketsWithSpanFunc(ctx, embedding, begin, end, limit)
}

// FindNearestTicketsWithSpanCalls gets all the calls that were made to FindNearestTicketsWithSpan.
// Check the length with:
//
//	len(mockedRepository.FindNearestTicketsWithSpanCalls())
func (mock *RepositoryMock) FindNearestTicketsWithSpanCalls() []struct {
	Ctx       context.Context
	Embedding []float32
	Begin     time.Time
	End       time.Time
	Limit     int
} {
	var calls []struct {
		Ctx       context.Context
		Embedding []float32
		Begin     time.Time
		End       time.Time
		Limit     int
	}
	mock.lockFindNearestTicketsWithSpan.RLock()
	calls = mock.calls.FindNearestTicketsWithSpan
	mock.lockFindNearestTicketsWithSpan.RUnlock()
	return calls
}

// GetActivities calls GetActivitiesFunc.
func (mock *RepositoryMock) GetActivities(ctx context.Context, offset int, limit int) ([]*activity.Activity, error) {
	callInfo := struct {
		Ctx    context.Context
		Offset int
		Limit  int
	}{
		Ctx:    ctx,
		Offset: offset,
		Limit:  limit,
	}
	mock.lockGetActivities.Lock()
	mock.calls.GetActivities = append(mock.calls.GetActivities, callInfo)
	mock.lockGetActivities.Unlock()
	if mock.GetActivitiesFunc == nil {
		var (
			activitysOut []*activity.Activity
			errOut       error
		)
		return activitysOut, errOut
	}
	return mock.GetActivitiesFunc(ctx, offset, limit)
}

// GetActivitiesCalls gets all the calls that were made to GetActivities.
// Check the length with:
//
//	len(mockedRepository.GetActivitiesCalls())
func (mock *RepositoryMock) GetActivitiesCalls() []struct {
	Ctx    context.Context
	Offset int
	Limit  int
} {
	var calls []struct {
		Ctx    context.Context
		Offset int
		Limit  int
	}
	mock.lockGetActivities.RLock()
	calls = mock.calls.GetActivities
	mock.lockGetActivities.RUnlock()
	return calls
}

// GetAlert calls GetAlertFunc.
func (mock *RepositoryMock) GetAlert(ctx context.Context, alertID types.AlertID) (*alert.Alert, error) {
	callInfo := struct {
		Ctx     context.Context
		AlertID types.AlertID
	}{
		Ctx:     ctx,
		AlertID: alertID,
	}
	mock.lockGetAlert.Lock()
	mock.calls.GetAlert = append(mock.calls.GetAlert, callInfo)
	mock.lockGetAlert.Unlock()
	if mock.GetAlertFunc == nil {
		var (
			alertOut *alert.Alert
			errOut   error
		)
		return alertOut, errOut
	}
	return mock.GetAlertFunc(ctx, alertID)
}

// GetAlertCalls gets all the calls that were made to GetAlert.
// Check the length with:
//
//	len(mockedRepository.GetAlertCalls())
func (mock *RepositoryMock) GetAlertCalls() []struct {
	Ctx     context.Context
	AlertID types.AlertID
} {
	var calls []struct {
		Ctx     context.Context
		AlertID types.AlertID
	}
	mock.lockGetAlert.RLock()
	calls = mock.calls.GetAlert
	mock.lockGetAlert.RUnlock()
	return calls
}

// GetAlertList calls GetAlertListFunc.
func (mock *RepositoryMock) GetAlertList(ctx context.Context, listID types.AlertListID) (*alert.List, error) {
	callInfo := struct {
		Ctx    context.Context
		ListID types.AlertListID
	}{
		Ctx:    ctx,
		ListID: listID,
	}
	mock.lockGetAlertList.Lock()
	mock.calls.GetAlertList = append(mock.calls.GetAlertList, callInfo)
	mock.lockGetAlertList.Unlock()
	if mock.GetAlertListFunc == nil {
		var (
			listOut *alert.List
			errOut  error
		)
		return listOut, errOut
	}
	return mock.GetAlertListFunc(ctx, listID)
}

// GetAlertListCalls gets all the calls that were made to GetAlertList.
// Check the length with:
//
//	len(mockedRepository.GetAlertListCalls())
func (mock *RepositoryMock) GetAlertListCalls() []struct {
	Ctx    context.Context
	ListID types.AlertListID
} {
	var calls []struct {
		Ctx    context.Context
		ListID types.AlertListID
	}
	mock.lockGetAlertList.RLock()
	calls = mock.calls.GetAlertList
	mock.lockGetAlertList.RUnlock()
	return calls
}

// GetAlertListByThread calls GetAlertListByThreadFunc.
func (mock *RepositoryMock) GetAlertListByThread(ctx context.Context, thread modelslack.Thread) (*alert.List, error) {
	callInfo := struct {
		Ctx    context.Context
		Thread modelslack.Thread
	}{
		Ctx:    ctx,
		Thread: thread,
	}
	mock.lockGetAlertListByThread.Lock()
	mock.calls.GetAlertListByThread = append(mock.calls.GetAlertListByThread, callInfo)
	mock.lockGetAlertListByThread.Unlock()
	if mock.GetAlertListByThreadFunc == nil {
		var (
			listOut *alert.List
			errOut  error
		)
		return listOut, errOut
	}
	return mock.GetAlertListByThreadFunc(ctx, thread)
}

// GetAlertListByThreadCalls gets all the calls that were made to GetAlertListByThread.
// Check the length with:
//
//	len(mockedRepository.GetAlertListByThreadCalls())
func (mock *RepositoryMock) GetAlertListByThreadCalls() []struct {
	Ctx    context.Context
	Thread modelslack.Thread
} {
	var calls []struct {
		Ctx    context.Context
		Thread modelslack.Thread
	}
	mock.lockGetAlertListByThread.RLock()
	calls = mock.calls.GetAlertListByThread
	mock.lockGetAlertListByThread.RUnlock()
	return calls
}

// GetAlertListsInThread calls GetAlertListsInThreadFunc.
func (mock *RepositoryMock) GetAlertListsInThread(ctx context.Context, thread modelslack.Thread) ([]*alert.List, error) {
	callInfo := struct {
		Ctx    context.Context
		Thread modelslack.Thread
	}{
		Ctx:    ctx,
		Thread: thread,
	}
	mock.lockGetAlertListsInThread.Lock()
	mock.calls.GetAlertListsInThread = append(mock.calls.GetAlertListsInThread, callInfo)
	mock.lockGetAlertListsInThread.Unlock()
	if mock.GetAlertListsInThreadFunc == nil {
		var (
			listsOut []*alert.List
			errOut   error
		)
		return listsOut, errOut
	}
	return mock.GetAlertListsInThreadFunc(ctx, thread)
}

// GetAlertListsInThreadCalls gets all the calls that were made to GetAlertListsInThread.
// Check the length with:
//
//	len(mockedRepository.GetAlertListsInThreadCalls())
func (mock *RepositoryMock) GetAlertListsInThreadCalls() []struct {
	Ctx    context.Context
	Thread modelslack.Thread
} {
	var calls []struct {
		Ctx    context.Context
		Thread modelslack.Thread
	}
	mock.lockGetAlertListsInThread.RLock()
	calls = mock.calls.GetAlertListsInThread
	mock.lockGetAlertListsInThread.RUnlock()
	return calls
}

// GetAlertWithoutEmbedding calls GetAlertWithoutEmbeddingFunc.
func (mock *RepositoryMock) GetAlertWithoutEmbedding(ctx context.Context) (alert.Alerts, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAlertWithoutEmbedding.Lock()
	mock.calls.GetAlertWithoutEmbedding = append(mock.calls.GetAlertWithoutEmbedding, callInfo)
	mock.lockGetAlertWithoutEmbedding.Unlock()
	if mock.GetAlertWithoutEmbeddingFunc == nil {
		var (
			alertsOut alert.Alerts
			errOut    error
		)
		return alertsOut, errOut
	}
	return mock.GetAlertWithoutEmbeddingFunc(ctx)
}

// GetAlertWithoutEmbeddingCalls gets all the calls that were made to GetAlertWithoutEmbedding.
// Check the length with:
//
//	len(mockedRepository.GetAlertWithoutEmbeddingCalls())
func (mock *RepositoryMock) GetAlertWithoutEmbeddingCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAlertWithoutEmbedding.RLock()
	calls = mock.calls.GetAlertWithoutEmbedding
	mock.lockGetAlertWithoutEmbedding.RUnlock()
	return calls
}

// GetAlertWithoutTicket calls GetAlertWithoutTicketFunc.
func (mock *RepositoryMock) GetAlertWithoutTicket(ctx context.Context, offset int, limit int) (alert.Alerts, error) {
	callInfo := struct {
		Ctx    context.Context
		Offset int
		Limit  int
	}{
		Ctx:    ctx,
		Offset: offset,
		Limit:  limit,
	}
	mock.lockGetAlertWithoutTicket.Lock()
	mock.calls.GetAlertWithoutTicket = append(mock.calls.GetAlertWithoutTicket, callInfo)
	mock.lockGetAlertWithoutTicket.Unlock()
	if mock.GetAlertWithoutTicketFunc == nil {
		var (
			alertsOut alert.Alerts
			errOut    error
		)
		return alertsOut, errOut
	}
	return mock.GetAlertWithoutTicketFunc(ctx, offset, limit)
}

// GetAlertWithoutTicketCalls gets all the calls that were made to GetAlertWithoutTicket.
// Check the length with:
//
//	len(mockedRepository.GetAlertWithoutTicketCalls())
func (mock *RepositoryMock) GetAlertWithoutTicketCalls() []struct {
	Ctx    context.Context
	Offset int
	Limit  int
} {
	var calls []struct {
		Ctx    context.Context
		Offset int
		Limit  int
	}
	mock.lockGetAlertWithoutTicket.RLock()
	calls = mock.calls.GetAlertWithoutTicket
	mock.lockGetAlertWithoutTicket.RUnlock()
	return calls
}

// GetAlertsBySpan calls GetAlertsBySpanFunc.
func (mock *RepositoryMock) GetAlertsBySpan(ctx context.Context, begin time.Time, end time.Time) (alert.Alerts, error) {
	callInfo := struct {
		Ctx   context.Context
		Begin time.Time
		End   time.Time
	}{
		Ctx:   ctx,
		Begin: begin,
		End:   end,
	}
	mock.lockGetAlertsBySpan.Lock()
	mock.calls.GetAlertsBySpan = append(mock.calls.GetAlertsBySpan, callInfo)
	mock.lockGetAlertsBySpan.Unlock()
	if mock.GetAlertsBySpanFunc == nil {
		var (
			alertsOut alert.Alerts
			errOut    error
		)
		return alertsOut, errOut
	}
	return mock.GetAlertsBySpanFunc(ctx, begin, end)
}

// GetAlertsBySpanCalls gets all the calls that were made to GetAlertsBySpan.
// Check the length with:
//
//	len(mockedRepository.GetAlertsBySpanCalls())
func (mock *RepositoryMock) GetAlertsBySpanCalls() []struct {
	Ctx   context.Context
	Begin time.Time
	End   time.Time
} {
	var calls []struct {
		Ctx   context.Context
		Begin time.Time
		End   time.Time
	}
	mock.lockGetAlertsBySpan.RLock()
	calls = mock.calls.GetAlertsBySpan
	mock.lockGetAlertsBySpan.RUnlock()
	return calls
}

// GetAlertsWithInvalidEmbedding calls GetAlertsWithInvalidEmbeddingFunc.
func (mock *RepositoryMock) GetAlertsWithInvalidEmbedding(ctx context.Context) (alert.Alerts, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAlertsWithInvalidEmbedding.Lock()
	mock.calls.GetAlertsWithInvalidEmbedding = append(mock.calls.GetAlertsWithInvalidEmbedding, callInfo)
	mock.lockGetAlertsWithInvalidEmbedding.Unlock()
	if mock.GetAlertsWithInvalidEmbeddingFunc == nil {
		var (
			alertsOut alert.Alerts
			errOut    error
		)
		return alertsOut, errOut
	}
	return mock.GetAlertsWithInvalidEmbeddingFunc(ctx)
}

// GetAlertsWithInvalidEmbeddingCalls gets all the calls that were made to GetAlertsWithInvalidEmbedding.
// Check the length with:
//
//	len(mockedRepository.GetAlertsWithInvalidEmbeddingCalls())
func (mock *RepositoryMock) GetAlertsWithInvalidEmbeddingCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAlertsWithInvalidEmbedding.RLock()
	calls = mock.calls.GetAlertsWithInvalidEmbedding
	mock.lockGetAlertsWithInvalidEmbedding.RUnlock()
	return calls
}

// GetLatestAlertByThread calls GetLatestAlertByThreadFunc.
func (mock *RepositoryMock) GetLatestAlertByThread(ctx context.Context, thread modelslack.Thread) (*alert.Alert, error) {
	callInfo := struct {
		Ctx    context.Context
		Thread modelslack.Thread
	}{
		Ctx:    ctx,
		Thread: thread,
	}
	mock.lockGetLatestAlertByThread.Lock()
	mock.calls.GetLatestAlertByThread = append(mock.calls.GetLatestAlertByThread, callInfo)
	mock.lockGetLatestAlertByThread.Unlock()
	if mock.GetLatestAlertByThreadFunc == nil {
		var (
			alertOut *alert.Alert
			errOut   error
		)
		return alertOut, errOut
	}
	return mock.GetLatestAlertByThreadFunc(ctx, thread)
}

// GetLatestAlertByThreadCalls gets all the calls that were made to GetLatestAlertByThread.
// Check the length with:
//
//	len(mockedRepository.GetLatestAlertByThreadCalls())
func (mock *RepositoryMock) GetLatestAlertByThreadCalls() []struct {
	Ctx    context.Context
	Thread modelslack.Thread
} {
	var calls []struct {
		Ctx    context.Context
		Thread modelslack.Thread
	}
	mock.lockGetLatestAlertByThread.RLock()
	calls = mock.calls.GetLatestAlertByThread
	mock.lockGetLatestAlertByThread.RUnlock()
	return calls
}

// GetLatestAlertListInThread calls GetLatestAlertListInThreadFunc.
func (mock *RepositoryMock) GetLatestAlertListInThread(ctx context.Context, thread modelslack.Thread) (*alert.List, error) {
	callInfo := struct {
		Ctx    context.Context
		Thread modelslack.Thread
	}{
		Ctx:    ctx,
		Thread: thread,
	}
	mock.lockGetLatestAlertListInThread.Lock()
	mock.calls.GetLatestAlertListInThread = append(mock.calls.GetLatestAlertListInThread, callInfo)
	mock.lockGetLatestAlertListInThread.Unlock()
	if mock.GetLatestAlertListInThreadFunc == nil {
		var (
			listOut *alert.List
			errOut  error
		)
		return listOut, errOut
	}
	return mock.GetLatestAlertListInThreadFunc(ctx, thread)
}

// GetLatestAlertListInThreadCalls gets all the calls that were made to GetLatestAlertListInThread.
// Check the length with:
//
//	len(mockedRepository.GetLatestAlertListInThreadCalls())
func (mock *RepositoryMock) GetLatestAlertListInThreadCalls() []struct {
	Ctx    context.Context
	Thread modelslack.Thread
} {
	var calls []struct {
		Ctx    context.Context
		Thread modelslack.Thread
	}
	mock.lockGetLatestAlertListInThread.RLock()
	calls = mock.calls.GetLatestAlertListInThread
	mock.lockGetLatestAlertListInThread.RUnlock()
	return calls
}

// GetLatestHistory calls GetLatestHistoryFunc.
func (mock *RepositoryMock) GetLatestHistory(ctx context.Context, ticketID types.TicketID) (*ticket.History, error) {
	callInfo := struct {
		Ctx      context.Context
		TicketID types.TicketID
	}{
		Ctx:      ctx,
		TicketID: ticketID,
	}
	mock.lockGetLatestHistory.Lock()
	mock.calls.GetLatestHistory = append(mock.calls.GetLatestHistory, callInfo)
	mock.lockGetLatestHistory.Unlock()
	if mock.GetLatestHistoryFunc == nil {
		var (
			historyOut *ticket.History
			errOut     error
		)
		return historyOut, errOut
	}
	return mock.GetLatestHistoryFunc(ctx, ticketID)
}

// GetLatestHistoryCalls gets all the calls that were made to GetLatestHistory.
// Check the length with:
//
//	len(mockedRepository.GetLatestHistoryCalls())
func (mock *RepositoryMock) GetLatestHistoryCalls() []struct {
	Ctx      context.Context
	TicketID types.TicketID
} {
	var calls []struct {
		Ctx      context.Context
		TicketID types.TicketID
	}
	mock.lockGetLatestHistory.RLock()
	calls = mock.calls.GetLatestHistory
	mock.lockGetLatestHistory.RUnlock()
	return calls
}

// GetTicket calls GetTicketFunc.
func (mock *RepositoryMock) GetTicket(ctx context.Context, ticketID types.TicketID) (*ticket.Ticket, error) {
	callInfo := struct {
		Ctx      context.Context
		TicketID types.TicketID
	}{
		Ctx:      ctx,
		TicketID: ticketID,
	}
	mock.lockGetTicket.Lock()
	mock.calls.GetTicket = append(mock.calls.GetTicket, callInfo)
	mock.lockGetTicket.Unlock()
	if mock.GetTicketFunc == nil {
		var (
			ticketOut *ticket.Ticket
			errOut    error
		)
		return ticketOut, errOut
	}
	return mock.GetTicketFunc(ctx, ticketID)
}

// GetTicketCalls gets all the calls that were made to GetTicket.
// Check the length with:
//
//	len(mockedRepository.GetTicketCalls())
func (mock *RepositoryMock) GetTicketCalls() []struct {
	Ctx      context.Context
	TicketID types.TicketID
} {
	var calls []struct {
		Ctx      context.Context
		TicketID types.TicketID
	}
	mock.lockGetTicket.RLock()
	calls = mock.calls.GetTicket
	mock.lockGetTicket.RUnlock()
	return calls
}

// GetTicketByThread calls GetTicketByThreadFunc.
func (mock *RepositoryMock) GetTicketByThread(ctx context.Context, thread modelslack.Thread) (*ticket.Ticket, error) {
	callInfo := struct {
		Ctx    context.Context
		Thread modelslack.Thread
	}{
		Ctx:    ctx,
		Thread: thread,
	}
	mock.lockGetTicketByThread.Lock()
	mock.calls.GetTicketByThread = append(mock.calls.GetTicketByThread, callInfo)
	mock.lockGetTicketByThread.Unlock()
	if mock.GetTicketByThreadFunc == nil {
		var (
			ticketOut *ticket.Ticket
			errOut    error
		)
		return ticketOut, errOut
	}
	return mock.GetTicketByThreadFunc(ctx, thread)
}

// GetTicketByThreadCalls gets all the calls that were made to GetTicketByThread.
// Check the length with:
//
//	len(mockedRepository.GetTicketByThreadCalls())
func (mock *RepositoryMock) GetTicketByThreadCalls() []struct {
	Ctx    context.Context
	Thread modelslack.Thread
} {
	var calls []struct {
		Ctx    context.Context
		Thread modelslack.Thread
	}
	mock.lockGetTicketByThread.RLock()
	calls = mock.calls.GetTicketByThread
	mock.lockGetTicketByThread.RUnlock()
	return calls
}

// GetTicketComments calls GetTicketCommentsFunc.
func (mock *RepositoryMock) GetTicketComments(ctx context.Context, ticketID types.TicketID) ([]ticket.Comment, error) {
	callInfo := struct {
		Ctx      context.Context
		TicketID types.TicketID
	}{
		Ctx:      ctx,
		TicketID: ticketID,
	}
	mock.lockGetTicketComments.Lock()
	mock.calls.GetTicketComments = append(mock.calls.GetTicketComments, callInfo)
	mock.lockGetTicketComments.Unlock()
	if mock.GetTicketCommentsFunc == nil {
		var (
			commentsOut []ticket.Comment
			errOut      error
		)
		return commentsOut, errOut
	}
	return mock.GetTicketCommentsFunc(ctx, ticketID)
}

// GetTicketCommentsCalls gets all the calls that were made to GetTicketComments.
// Check the length with:
//
//	len(mockedRepository.GetTicketCommentsCalls())
func (mock *RepositoryMock) GetTicketCommentsCalls() []struct {
	Ctx      context.Context
	TicketID types.TicketID
} {
	var calls []struct {
		Ctx      context.Context
		TicketID types.TicketID
	}
	mock.lockGetTicketComments.RLock()
	calls = mock.calls.GetTicketComments
	mock.lockGetTicketComments.RUnlock()
	return calls
}

// GetTicketCommentsPaginated calls GetTicketCommentsPaginatedFunc.
func (mock *RepositoryMock) GetTicketCommentsPaginated(ctx context.Context, ticketID types.TicketID, offset int, limit int) ([]ticket.Comment, error) {
	callInfo := struct {
		Ctx      context.Context
		TicketID types.TicketID
		Offset   int
		Limit    int
	}{
		Ctx:      ctx,
		TicketID: ticketID,
		Offset:   offset,
		Limit:    limit,
	}
	mock.lockGetTicketCommentsPaginated.Lock()
	mock.calls.GetTicketCommentsPaginated = append(mock.calls.GetTicketCommentsPaginated, callInfo)
	mock.lockGetTicketCommentsPaginated.Unlock()
	if mock.GetTicketCommentsPaginatedFunc == nil {
		var (
			commentsOut []ticket.Comment
			errOut      error
		)
		return commentsOut, errOut
	}
	return mock.GetTicketCommentsPaginatedFunc(ctx, ticketID, offset, limit)
}

// GetTicketCommentsPaginatedCalls gets all the calls that were made to GetTicketCommentsPaginated.
// Check the length with:
//
//	len(mockedRepository.GetTicketCommentsPaginatedCalls())
func (mock *RepositoryMock) GetTicketCommentsPaginatedCalls() []struct {
	Ctx      context.Context
	TicketID types.TicketID
	Offset   int
	Limit    int
} {
	var calls []struct {
		Ctx      context.Context
		TicketID types.TicketID
		Offset   int
		Limit    int
	}
	mock.lockGetTicketCommentsPaginated.RLock()
	calls = mock.calls.GetTicketCommentsPaginated
	mock.lockGetTicketCommentsPaginated.RUnlock()
	return calls
}

// GetTicketUnpromptedComments calls GetTicketUnpromptedCommentsFunc.
func (mock *RepositoryMock) GetTicketUnpromptedComments(ctx context.Context, ticketID types.TicketID) ([]ticket.Comment, error) {
	callInfo := struct {
		Ctx      context.Context
		TicketID types.TicketID
	}{
		Ctx:      ctx,
		TicketID: ticketID,
	}
	mock.lockGetTicketUnpromptedComments.Lock()
	mock.calls.GetTicketUnpromptedComments = append(mock.calls.GetTicketUnpromptedComments, callInfo)
	mock.lockGetTicketUnpromptedComments.Unlock()
	if mock.GetTicketUnpromptedCommentsFunc == nil {
		var (
			commentsOut []ticket.Comment
			errOut      error
		)
		return commentsOut, errOut
	}
	return mock.GetTicketUnpromptedCommentsFunc(ctx, ticketID)
}

// GetTicketUnpromptedCommentsCalls gets all the calls that were made to GetTicketUnpromptedComments.
// Check the length with:
//
//	len(mockedRepository.GetTicketUnpromptedCommentsCalls())
func (mock *RepositoryMock) GetTicketUnpromptedCommentsCalls() []struct {
	Ctx      context.Context
	TicketID types.TicketID
} {
	var calls []struct {
		Ctx      context.Context
		TicketID types.TicketID
	}
	mock.lockGetTicketUnpromptedComments.RLock()
	calls = mock.calls.GetTicketUnpromptedComments
	mock.lockGetTicketUnpromptedComments.RUnlock()
	return calls
}

// GetTicketsBySpan calls GetTicketsBySpanFunc.
func (mock *RepositoryMock) GetTicketsBySpan(ctx context.Context, begin time.Time, end time.Time) ([]*ticket.Ticket, error) {
	callInfo := struct {
		Ctx   context.Context
		Begin time.Time
		End   time.Time
	}{
		Ctx:   ctx,
		Begin: begin,
		End:   end,
	}
	mock.lockGetTicketsBySpan.Lock()
	mock.calls.GetTicketsBySpan = append(mock.calls.GetTicketsBySpan, callInfo)
	mock.lockGetTicketsBySpan.Unlock()
	if mock.GetTicketsBySpanFunc == nil {
		var (
			ticketsOut []*ticket.Ticket
			errOut     error
		)
		return ticketsOut, errOut
	}
	return mock.GetTicketsBySpanFunc(ctx, begin, end)
}

// GetTicketsBySpanCalls gets all the calls that were made to GetTicketsBySpan.
// Check the length with:
//
//	len(mockedRepository.GetTicketsBySpanCalls())
func (mock *RepositoryMock) GetTicketsBySpanCalls() []struct {
	Ctx   context.Context
	Begin time.Time
	End   time.Time
} {
	var calls []struct {
		Ctx   context.Context
		Begin time.Time
		End   time.Time
	}
	mock.lockGetTicketsBySpan.RLock()
	calls = mock.calls.GetTicketsBySpan
	mock.lockGetTicketsBySpan.RUnlock()
	return calls
}

// GetTicketsByStatus calls GetTicketsByStatusFunc.
func (mock *RepositoryMock) GetTicketsByStatus(ctx context.Context, statuses []types.TicketStatus, offset int, limit int) ([]*ticket.Ticket, error) {
	callInfo := struct {
		Ctx      context.Context
		Statuses []types.TicketStatus
		Offset   int
		Limit    int
	}{
		Ctx:      ctx,
		Statuses: statuses,
		Offset:   offset,
		Limit:    limit,
	}
	mock.lockGetTicketsByStatus.Lock()
	mock.calls.GetTicketsByStatus = append(mock.calls.GetTicketsByStatus, callInfo)
	mock.lockGetTicketsByStatus.Unlock()
	if mock.GetTicketsByStatusFunc == nil {
		var (
			ticketsOut []*ticket.Ticket
			errOut     error
		)
		return ticketsOut, errOut
	}
	return mock.GetTicketsByStatusFunc(ctx, statuses, offset, limit)
}

// GetTicketsByStatusCalls gets all the calls that were made to GetTicketsByStatus.
// Check the length with:
//
//	len(mockedRepository.GetTicketsByStatusCalls())
func (mock *RepositoryMock) GetTicketsByStatusCalls() []struct {
	Ctx      context.Context
	Statuses []types.TicketStatus
	Offset   int
	Limit    int
} {
	var calls []struct {
		Ctx      context.Context
		Statuses []types.TicketStatus
		Offset   int
		Limit    int
	}
	mock.lockGetTicketsByStatus.RLock()
	calls = mock.calls.GetTicketsByStatus
	mock.lockGetTicketsByStatus.RUnlock()
	return calls
}

// GetTicketsByStatusAndSpan calls GetTicketsByStatusAndSpanFunc.
func (mock *RepositoryMock) GetTicketsByStatusAndSpan(ctx context.Context, status types.TicketStatus, begin time.Time, end time.Time) ([]*ticket.Ticket, error) {
	callInfo := struct {
		Ctx    context.Context
		Status types.TicketStatus
		Begin  time.Time
		End    time.Time
	}{
		Ctx:    ctx,
		Status: status,
		Begin:  begin,
		End:    end,
	}
	mock.lockGetTicketsByStatusAndSpan.Lock()
	mock.calls.GetTicketsByStatusAndSpan = append(mock.calls.GetTicketsByStatusAndSpan, callInfo)
	mock.lockGetTicketsByStatusAndSpan.Unlock()
	if mock.GetTicketsByStatusAndSpanFunc == nil {
		var (
			ticketsOut []*ticket.Ticket
			errOut     error
		)
		return ticketsOut, errOut
	}
	return mock.GetTicketsByStatusAndSpanFunc(ctx, status, begin, end)
}

// GetTicketsByStatusAndSpanCalls gets all the calls that were made to GetTicketsByStatusAndSpan.
// Check the length with:
//
//	len(mockedRepository.GetTicketsByStatusAndSpanCalls())
func (mock *RepositoryMock) GetTicketsByStatusAndSpanCalls() []struct {
	Ctx    context.Context
	Status types.TicketStatus
	Begin  time.Time
	End    time.Time
} {
	var calls []struct {
		Ctx    context.Context
		Status types.TicketStatus
		Begin  time.Time
		End    time.Time
	}
	mock.lockGetTicketsByStatusAndSpan.RLock()
	calls = mock.calls.GetTicketsByStatusAndSpan
	mock.lockGetTicketsByStatusAndSpan.RUnlock()
	return calls
}

// GetTicketsWithInvalidEmbedding calls GetTicketsWithInvalidEmbeddingFunc.
func (mock *RepositoryMock) GetTicketsWithInvalidEmbedding(ctx context.Context) ([]*ticket.Ticket, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetTicketsWithInvalidEmbedding.Lock()
	mock.calls.GetTicketsWithInvalidEmbedding = append(mock.calls.GetTicketsWithInvalidEmbedding, callInfo)
	mock.lockGetTicketsWithInvalidEmbedding.Unlock()
	if mock.GetTicketsWithInvalidEmbeddingFunc == nil {
		var (
			ticketsOut []*ticket.Ticket
			errOut     error
		)
		return ticketsOut, errOut
	}
	return mock.GetTicketsWithInvalidEmbeddingFunc(ctx)
}

// GetTicketsWithInvalidEmbeddingCalls gets all the calls that were made to GetTicketsWithInvalidEmbedding.
// Check the length with:
//
//	len(mockedRepository.GetTicketsWithInvalidEmbeddingCalls())
func (mock *RepositoryMock) GetTicketsWithInvalidEmbeddingCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetTicketsWithInvalidEmbedding.RLock()
	calls = mock.calls.GetTicketsWithInvalidEmbedding
	mock.lockGetTicketsWithInvalidEmbedding.RUnlock()
	return calls
}

// GetToken calls GetTokenFunc.
func (mock *RepositoryMock) GetToken(ctx context.Context, tokenID auth.TokenID) (*auth.Token, error) {
	callInfo := struct {
		Ctx     context.Context
		TokenID auth.TokenID
	}{
		Ctx:     ctx,
		TokenID: tokenID,
	}
	mock.lockGetToken.Lock()
	mock.calls.GetToken = append(mock.calls.GetToken, callInfo)
	mock.lockGetToken.Unlock()
	if mock.GetTokenFunc == nil {
		var (
			tokenOut *auth.Token
			errOut   error
		)
		return tokenOut, errOut
	}
	return mock.GetTokenFunc(ctx, tokenID)
}

// GetTokenCalls gets all the calls that were made to GetToken.
// Check the length with:
//
//	len(mockedRepository.GetTokenCalls())
func (mock *RepositoryMock) GetTokenCalls() []struct {
	Ctx     context.Context
	TokenID auth.TokenID
} {
	var calls []struct {
		Ctx     context.Context
		TokenID auth.TokenID
	}
	mock.lockGetToken.RLock()
	calls = mock.calls.GetToken
	mock.lockGetToken.RUnlock()
	return calls
}

// PutActivity calls PutActivityFunc.
func (mock *RepositoryMock) PutActivity(ctx context.Context, activityMoqParam *activity.Activity) error {
	callInfo := struct {
		Ctx              context.Context
		ActivityMoqParam *activity.Activity
	}{
		Ctx:              ctx,
		ActivityMoqParam: activityMoqParam,
	}
	mock.lockPutActivity.Lock()
	mock.calls.PutActivity = append(mock.calls.PutActivity, callInfo)
	mock.lockPutActivity.Unlock()
	if mock.PutActivityFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PutActivityFunc(ctx, activityMoqParam)
}

// PutActivityCalls gets all the calls that were made to PutActivity.
// Check the length with:
//
//	len(mockedRepository.PutActivityCalls())
func (mock *RepositoryMock) PutActivityCalls() []struct {
	Ctx              context.Context
	ActivityMoqParam *activity.Activity
} {
	var calls []struct {
		Ctx              context.Context
		ActivityMoqParam *activity.Activity
	}
	mock.lockPutActivity.RLock()
	calls = mock.calls.PutActivity
	mock.lockPutActivity.RUnlock()
	return calls
}

// PutAlert calls PutAlertFunc.
func (mock *RepositoryMock) PutAlert(ctx context.Context, alertMoqParam alert.Alert) error {
	callInfo := struct {
		Ctx           context.Context
		AlertMoqParam alert.Alert
	}{
		Ctx:           ctx,
		AlertMoqParam: alertMoqParam,
	}
	mock.lockPutAlert.Lock()
	mock.calls.PutAlert = append(mock.calls.PutAlert, callInfo)
	mock.lockPutAlert.Unlock()
	if mock.PutAlertFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PutAlertFunc(ctx, alertMoqParam)
}

// PutAlertCalls gets all the calls that were made to PutAlert.
// Check the length with:
//
//	len(mockedRepository.PutAlertCalls())
func (mock *RepositoryMock) PutAlertCalls() []struct {
	Ctx           context.Context
	AlertMoqParam alert.Alert
} {
	var calls []struct {
		Ctx           context.Context
		AlertMoqParam alert.Alert
	}
	mock.lockPutAlert.RLock()
	calls = mock.calls.PutAlert
	mock.lockPutAlert.RUnlock()
	return calls
}

// PutAlertList calls PutAlertListFunc.
func (mock *RepositoryMock) PutAlertList(ctx context.Context, list *alert.List) error {
	callInfo := struct {
		Ctx  context.Context
		List *alert.List
	}{
		Ctx:  ctx,
		List: list,
	}
	mock.lockPutAlertList.Lock()
	mock.calls.PutAlertList = append(mock.calls.PutAlertList, callInfo)
	mock.lockPutAlertList.Unlock()
	if mock.PutAlertListFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PutAlertListFunc(ctx, list)
}

// PutAlertListCalls gets all the calls that were made to PutAlertList.
// Check the length with:
//
//	len(mockedRepository.PutAlertListCalls())
func (mock *RepositoryMock) PutAlertListCalls() []struct {
	Ctx  context.Context
	List *alert.List
} {
	var calls []struct {
		Ctx  context.Context
		List *alert.List
	}
	mock.lockPutAlertList.RLock()
	calls = mock.calls.PutAlertList
	mock.lockPutAlertList.RUnlock()
	return calls
}

// PutHistory calls PutHistoryFunc.
func (mock *RepositoryMock) PutHistory(ctx context.Context, ticketID types.TicketID, history *ticket.History) error {
	callInfo := struct {
		Ctx      context.Context
		TicketID types.TicketID
		History  *ticket.History
	}{
		Ctx:      ctx,
		TicketID: ticketID,
		History:  history,
	}
	mock.lockPutHistory.Lock()
	mock.calls.PutHistory = append(mock.calls.PutHistory, callInfo)
	mock.lockPutHistory.Unlock()
	if mock.PutHistoryFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PutHistoryFunc(ctx, ticketID, history)
}

// PutHistoryCalls gets all the calls that were made to PutHistory.
// Check the length with:
//
//	len(mockedRepository.PutHistoryCalls())
func (mock *RepositoryMock) PutHistoryCalls() []struct {
	Ctx      context.Context
	TicketID types.TicketID
	History  *ticket.History
} {
	var calls []struct {
		Ctx      context.Context
		TicketID types.TicketID
		History  *ticket.History
	}
	mock.lockPutHistory.RLock()
	calls = mock.calls.PutHistory
	mock.lockPutHistory.RUnlock()
	return calls
}

// PutTicket calls PutTicketFunc.
func (mock *RepositoryMock) PutTicket(ctx context.Context, ticketMoqParam ticket.Ticket) error {
	callInfo := struct {
		Ctx            context.Context
		TicketMoqParam ticket.Ticket
	}{
		Ctx:            ctx,
		TicketMoqParam: ticketMoqParam,
	}
	mock.lockPutTicket.Lock()
	mock.calls.PutTicket = append(mock.calls.PutTicket, callInfo)
	mock.lockPutTicket.Unlock()
	if mock.PutTicketFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PutTicketFunc(ctx, ticketMoqParam)
}

// PutTicketCalls gets all the calls that were made to PutTicket.
// Check the length with:
//
//	len(mockedRepository.PutTicketCalls())
func (mock *RepositoryMock) PutTicketCalls() []struct {
	Ctx            context.Context
	TicketMoqParam ticket.Ticket
} {
	var calls []struct {
		Ctx            context.Context
		TicketMoqParam ticket.Ticket
	}
	mock.lockPutTicket.RLock()
	calls = mock.calls.PutTicket
	mock.lockPutTicket.RUnlock()
	return calls
}

// PutTicketComment calls PutTicketCommentFunc.
func (mock *RepositoryMock) PutTicketComment(ctx context.Context, comment ticket.Comment) error {
	callInfo := struct {
		Ctx     context.Context
		Comment ticket.Comment
	}{
		Ctx:     ctx,
		Comment: comment,
	}
	mock.lockPutTicketComment.Lock()
	mock.calls.PutTicketComment = append(mock.calls.PutTicketComment, callInfo)
	mock.lockPutTicketComment.Unlock()
	if mock.PutTicketCommentFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PutTicketCommentFunc(ctx, comment)
}

// PutTicketCommentCalls gets all the calls that were made to PutTicketComment.
// Check the length with:
//
//	len(mockedRepository.PutTicketCommentCalls())
func (mock *RepositoryMock) PutTicketCommentCalls() []struct {
	Ctx     context.Context
	Comment ticket.Comment
} {
	var calls []struct {
		Ctx     context.Context
		Comment ticket.Comment
	}
	mock.lockPutTicketComment.RLock()
	calls = mock.calls.PutTicketComment
	mock.lockPutTicketComment.RUnlock()
	return calls
}

// PutTicketCommentsPrompted calls PutTicketCommentsPromptedFunc.
func (mock *RepositoryMock) PutTicketCommentsPrompted(ctx context.Context, ticketID types.TicketID, commentIDs []types.CommentID) error {
	callInfo := struct {
		Ctx        context.Context
		TicketID   types.TicketID
		CommentIDs []types.CommentID
	}{
		Ctx:        ctx,
		TicketID:   ticketID,
		CommentIDs: commentIDs,
	}
	mock.lockPutTicketCommentsPrompted.Lock()
	mock.calls.PutTicketCommentsPrompted = append(mock.calls.PutTicketCommentsPrompted, callInfo)
	mock.lockPutTicketCommentsPrompted.Unlock()
	if mock.PutTicketCommentsPromptedFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PutTicketCommentsPromptedFunc(ctx, ticketID, commentIDs)
}

// PutTicketCommentsPromptedCalls gets all the calls that were made to PutTicketCommentsPrompted.
// Check the length with:
//
//	len(mockedRepository.PutTicketCommentsPromptedCalls())
func (mock *RepositoryMock) PutTicketCommentsPromptedCalls() []struct {
	Ctx        context.Context
	TicketID   types.TicketID
	CommentIDs []types.CommentID
} {
	var calls []struct {
		Ctx        context.Context
		TicketID   types.TicketID
		CommentIDs []types.CommentID
	}
	mock.lockPutTicketCommentsPrompted.RLock()
	calls = mock.calls.PutTicketCommentsPrompted
	mock.lockPutTicketCommentsPrompted.RUnlock()
	return calls
}

// PutToken calls PutTokenFunc.
func (mock *RepositoryMock) PutToken(ctx context.Context, token *auth.Token) error {
	callInfo := struct {
		Ctx   context.Context
		Token *auth.Token
	}{
		Ctx:   ctx,
		Token: token,
	}
	mock.lockPutToken.Lock()
	mock.calls.PutToken = append(mock.calls.PutToken, callInfo)
	mock.lockPutToken.Unlock()
	if mock.PutTokenFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PutTokenFunc(ctx, token)
}

// PutTokenCalls gets all the calls that were made to PutToken.
// Check the length with:
//
//	len(mockedRepository.PutTokenCalls())
func (mock *RepositoryMock) PutTokenCalls() []struct {
	Ctx   context.Context
	Token *auth.Token
} {
	var calls []struct {
		Ctx   context.Context
		Token *auth.Token
	}
	mock.lockPutToken.RLock()
	calls = mock.calls.PutToken
	mock.lockPutToken.RUnlock()
	return calls
}

// SearchAlerts calls SearchAlertsFunc.
func (mock *RepositoryMock) SearchAlerts(ctx context.Context, path string, op string, value any, limit int) (alert.Alerts, error) {
	callInfo := struct {
		Ctx   context.Context
		Path  string
		Op    string
		Value any
		Limit int
	}{
		Ctx:   ctx,
		Path:  path,
		Op:    op,
		Value: value,
		Limit: limit,
	}
	mock.lockSearchAlerts.Lock()
	mock.calls.SearchAlerts = append(mock.calls.SearchAlerts, callInfo)
	mock.lockSearchAlerts.Unlock()
	if mock.SearchAlertsFunc == nil {
		var (
			alertsOut alert.Alerts
			errOut    error
		)
		return alertsOut, errOut
	}
	return mock.SearchAlertsFunc(ctx, path, op, value, limit)
}

// SearchAlertsCalls gets all the calls that were made to SearchAlerts.
// Check the length with:
//
//	len(mockedRepository.SearchAlertsCalls())
func (mock *RepositoryMock) SearchAlertsCalls() []struct {
	Ctx   context.Context
	Path  string
	Op    string
	Value any
	Limit int
} {
	var calls []struct {
		Ctx   context.Context
		Path  string
		Op    string
		Value any
		Limit int
	}
	mock.lockSearchAlerts.RLock()
	calls = mock.calls.SearchAlerts
	mock.lockSearchAlerts.RUnlock()
	return calls
}

// UnbindAlertFromTicket calls UnbindAlertFromTicketFunc.
func (mock *RepositoryMock) UnbindAlertFromTicket(ctx context.Context, alertID types.AlertID) error {
	callInfo := struct {
		Ctx     context.Context
		AlertID types.AlertID
	}{
		Ctx:     ctx,
		AlertID: alertID,
	}
	mock.lockUnbindAlertFromTicket.Lock()
	mock.calls.UnbindAlertFromTicket = append(mock.calls.UnbindAlertFromTicket, callInfo)
	mock.lockUnbindAlertFromTicket.Unlock()
	if mock.UnbindAlertFromTicketFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.UnbindAlertFromTicketFunc(ctx, alertID)
}

// UnbindAlertFromTicketCalls gets all the calls that were made to UnbindAlertFromTicket.
// Check the length with:
//
//	len(mockedRepository.UnbindAlertFromTicketCalls())
func (mock *RepositoryMock) UnbindAlertFromTicketCalls() []struct {
	Ctx     context.Context
	AlertID types.AlertID
} {
	var calls []struct {
		Ctx     context.Context
		AlertID types.AlertID
	}
	mock.lockUnbindAlertFromTicket.RLock()
	calls = mock.calls.UnbindAlertFromTicket
	mock.lockUnbindAlertFromTicket.RUnlock()
	return calls
}

// PolicyClientMock is a mock implementation of interfaces.PolicyClient.
//
//	func TestSomethingThatUsesPolicyClient(t *testing.T) {
//
//		// make and configure a mocked interfaces.PolicyClient
//		mockedPolicyClient := &PolicyClientMock{
//			QueryFunc: func(contextMoqParam context.Context, s string, v1 any, v2 any, queryOptions ...opaq.QueryOption) error {
//				panic("mock out the Query method")
//			},
//			SourcesFunc: func() map[string]string {
//				panic("mock out the Sources method")
//			},
//		}
//
//		// use mockedPolicyClient in code that requires interfaces.PolicyClient
//		// and then make assertions.
//
//	}
type PolicyClientMock struct {
	// QueryFunc mocks the Query method.
	QueryFunc func(contextMoqParam context.Context, s string, v1 any, v2 any, queryOptions ...opaq.QueryOption) error

	// SourcesFunc mocks the Sources method.
	SourcesFunc func() map[string]string

	// calls tracks calls to the methods.
	calls struct {
		// Query holds details about calls to the Query method.
		Query []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// S is the s argument value.
			S string
			// V1 is the v1 argument value.
			V1 any
			// V2 is the v2 argument value.
			V2 any
			// QueryOptions is the queryOptions argument value.
			QueryOptions []opaq.QueryOption
		}
		// Sources holds details about calls to the Sources method.
		Sources []struct {
		}
	}
	lockQuery   sync.RWMutex
	lockSources sync.RWMutex
}

// Query calls QueryFunc.
func (mock *PolicyClientMock) Query(contextMoqParam context.Context, s string, v1 any, v2 any, queryOptions ...opaq.QueryOption) error {
	callInfo := struct {
		ContextMoqParam context.Context
		S               string
		V1              any
		V2              any
		QueryOptions    []opaq.QueryOption
	}{
		ContextMoqParam: contextMoqParam,
		S:               s,
		V1:              v1,
		V2:              v2,
		QueryOptions:    queryOptions,
	}
	mock.lockQuery.Lock()
	mock.calls.Query = append(mock.calls.Query, callInfo)
	mock.lockQuery.Unlock()
	if mock.QueryFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.QueryFunc(contextMoqParam, s, v1, v2, queryOptions...)
}

// QueryCalls gets all the calls that were made to Query.
// Check the length with:
//
//	len(mockedPolicyClient.QueryCalls())
func (mock *PolicyClientMock) QueryCalls() []struct {
	ContextMoqParam context.Context
	S               string
	V1              any
	V2              any
	QueryOptions    []opaq.QueryOption
} {
	var calls []struct {
		ContextMoqParam context.Context
		S               string
		V1              any
		V2              any
		QueryOptions    []opaq.QueryOption
	}
	mock.lockQuery.RLock()
	calls = mock.calls.Query
	mock.lockQuery.RUnlock()
	return calls
}

// Sources calls SourcesFunc.
func (mock *PolicyClientMock) Sources() map[string]string {
	callInfo := struct {
	}{}
	mock.lockSources.Lock()
	mock.calls.Sources = append(mock.calls.Sources, callInfo)
	mock.lockSources.Unlock()
	if mock.SourcesFunc == nil {
		var (
			stringToStringOut map[string]string
		)
		return stringToStringOut
	}
	return mock.SourcesFunc()
}

// SourcesCalls gets all the calls that were made to Sources.
// Check the length with:
//
//	len(mockedPolicyClient.SourcesCalls())
func (mock *PolicyClientMock) SourcesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSources.RLock()
	calls = mock.calls.Sources
	mock.lockSources.RUnlock()
	return calls
}

// EmbeddingClientMock is a mock implementation of interfaces.EmbeddingClient.
//
//	func TestSomethingThatUsesEmbeddingClient(t *testing.T) {
//
//		// make and configure a mocked interfaces.EmbeddingClient
//		mockedEmbeddingClient := &EmbeddingClientMock{
//			EmbeddingsFunc: func(ctx context.Context, texts []string, dimensionality int) ([][]float32, error) {
//				panic("mock out the Embeddings method")
//			},
//		}
//
//		// use mockedEmbeddingClient in code that requires interfaces.EmbeddingClient
//		// and then make assertions.
//
//	}
type EmbeddingClientMock struct {
	// EmbeddingsFunc mocks the Embeddings method.
	EmbeddingsFunc func(ctx context.Context, texts []string, dimensionality int) ([][]float32, error)

	// calls tracks calls to the methods.
	calls struct {
		// Embeddings holds details about calls to the Embeddings method.
		Embeddings []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Texts is the texts argument value.
			Texts []string
			// Dimensionality is the dimensionality argument value.
			Dimensionality int
		}
	}
	lockEmbeddings sync.RWMutex
}

// Embeddings calls EmbeddingsFunc.
func (mock *EmbeddingClientMock) Embeddings(ctx context.Context, texts []string, dimensionality int) ([][]float32, error) {
	callInfo := struct {
		Ctx            context.Context
		Texts          []string
		Dimensionality int
	}{
		Ctx:            ctx,
		Texts:          texts,
		Dimensionality: dimensionality,
	}
	mock.lockEmbeddings.Lock()
	mock.calls.Embeddings = append(mock.calls.Embeddings, callInfo)
	mock.lockEmbeddings.Unlock()
	if mock.EmbeddingsFunc == nil {
		var (
			float32ssOut [][]float32
			errOut       error
		)
		return float32ssOut, errOut
	}
	return mock.EmbeddingsFunc(ctx, texts, dimensionality)
}

// EmbeddingsCalls gets all the calls that were made to Embeddings.
// Check the length with:
//
//	len(mockedEmbeddingClient.EmbeddingsCalls())
func (mock *EmbeddingClientMock) EmbeddingsCalls() []struct {
	Ctx            context.Context
	Texts          []string
	Dimensionality int
} {
	var calls []struct {
		Ctx            context.Context
		Texts          []string
		Dimensionality int
	}
	mock.lockEmbeddings.RLock()
	calls = mock.calls.Embeddings
	mock.lockEmbeddings.RUnlock()
	return calls
}

// StorageClientMock is a mock implementation of interfaces.StorageClient.
//
//	func TestSomethingThatUsesStorageClient(t *testing.T) {
//
//		// make and configure a mocked interfaces.StorageClient
//		mockedStorageClient := &StorageClientMock{
//			CloseFunc: func(ctx context.Context)  {
//				panic("mock out the Close method")
//			},
//			GetObjectFunc: func(ctx context.Context, object string) (io.ReadCloser, error) {
//				panic("mock out the GetObject method")
//			},
//			PutObjectFunc: func(ctx context.Context, object string) io.WriteCloser {
//				panic("mock out the PutObject method")
//			},
//		}
//
//		// use mockedStorageClient in code that requires interfaces.StorageClient
//		// and then make assertions.
//
//	}
type StorageClientMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func(ctx context.Context)

	// GetObjectFunc mocks the GetObject method.
	GetObjectFunc func(ctx context.Context, object string) (io.ReadCloser, error)

	// PutObjectFunc mocks the PutObject method.
	PutObjectFunc func(ctx context.Context, object string) io.WriteCloser

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetObject holds details about calls to the GetObject method.
		GetObject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Object is the object argument value.
			Object string
		}
		// PutObject holds details about calls to the PutObject method.
		PutObject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Object is the object argument value.
			Object string
		}
	}
	lockClose     sync.RWMutex
	lockGetObject sync.RWMutex
	lockPutObject sync.RWMutex
}

// Close calls CloseFunc.
func (mock *StorageClientMock) Close(ctx context.Context) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	if mock.CloseFunc == nil {
		return
	}
	mock.CloseFunc(ctx)
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedStorageClient.CloseCalls())
func (mock *StorageClientMock) CloseCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// GetObject calls GetObjectFunc.
func (mock *StorageClientMock) GetObject(ctx context.Context, object string) (io.ReadCloser, error) {
	callInfo := struct {
		Ctx    context.Context
		Object string
	}{
		Ctx:    ctx,
		Object: object,
	}
	mock.lockGetObject.Lock()
	mock.calls.GetObject = append(mock.calls.GetObject, callInfo)
	mock.lockGetObject.Unlock()
	if mock.GetObjectFunc == nil {
		var (
			readCloserOut io.ReadCloser
			errOut        error
		)
		return readCloserOut, errOut
	}
	return mock.GetObjectFunc(ctx, object)
}

// GetObjectCalls gets all the calls that were made to GetObject.
// Check the length with:
//
//	len(mockedStorageClient.GetObjectCalls())
func (mock *StorageClientMock) GetObjectCalls() []struct {
	Ctx    context.Context
	Object string
} {
	var calls []struct {
		Ctx    context.Context
		Object string
	}
	mock.lockGetObject.RLock()
	calls = mock.calls.GetObject
	mock.lockGetObject.RUnlock()
	return calls
}

// PutObject calls PutObjectFunc.
func (mock *StorageClientMock) PutObject(ctx context.Context, object string) io.WriteCloser {
	callInfo := struct {
		Ctx    context.Context
		Object string
	}{
		Ctx:    ctx,
		Object: object,
	}
	mock.lockPutObject.Lock()
	mock.calls.PutObject = append(mock.calls.PutObject, callInfo)
	mock.lockPutObject.Unlock()
	if mock.PutObjectFunc == nil {
		var (
			writeCloserOut io.WriteCloser
		)
		return writeCloserOut
	}
	return mock.PutObjectFunc(ctx, object)
}

// PutObjectCalls gets all the calls that were made to PutObject.
// Check the length with:
//
//	len(mockedStorageClient.PutObjectCalls())
func (mock *StorageClientMock) PutObjectCalls() []struct {
	Ctx    context.Context
	Object string
} {
	var calls []struct {
		Ctx    context.Context
		Object string
	}
	mock.lockPutObject.RLock()
	calls = mock.calls.PutObject
	mock.lockPutObject.RUnlock()
	return calls
}

// LLMClientMock is a mock implementation of interfaces.LLMClient.
//
//	func TestSomethingThatUsesLLMClient(t *testing.T) {
//
//		// make and configure a mocked interfaces.LLMClient
//		mockedLLMClient := &LLMClientMock{
//			GenerateEmbeddingFunc: func(ctx context.Context, dimension int, input []string) ([][]float64, error) {
//				panic("mock out the GenerateEmbedding method")
//			},
//			NewSessionFunc: func(ctx context.Context, options ...gollem.SessionOption) (gollem.Session, error) {
//				panic("mock out the NewSession method")
//			},
//		}
//
//		// use mockedLLMClient in code that requires interfaces.LLMClient
//		// and then make assertions.
//
//	}
type LLMClientMock struct {
	// GenerateEmbeddingFunc mocks the GenerateEmbedding method.
	GenerateEmbeddingFunc func(ctx context.Context, dimension int, input []string) ([][]float64, error)

	// NewSessionFunc mocks the NewSession method.
	NewSessionFunc func(ctx context.Context, options ...gollem.SessionOption) (gollem.Session, error)

	// calls tracks calls to the methods.
	calls struct {
		// GenerateEmbedding holds details about calls to the GenerateEmbedding method.
		GenerateEmbedding []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dimension is the dimension argument value.
			Dimension int
			// Input is the input argument value.
			Input []string
		}
		// NewSession holds details about calls to the NewSession method.
		NewSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Options is the options argument value.
			Options []gollem.SessionOption
		}
	}
	lockGenerateEmbedding sync.RWMutex
	lockNewSession        sync.RWMutex
}

// GenerateEmbedding calls GenerateEmbeddingFunc.
func (mock *LLMClientMock) GenerateEmbedding(ctx context.Context, dimension int, input []string) ([][]float64, error) {
	callInfo := struct {
		Ctx       context.Context
		Dimension int
		Input     []string
	}{
		Ctx:       ctx,
		Dimension: dimension,
		Input:     input,
	}
	mock.lockGenerateEmbedding.Lock()
	mock.calls.GenerateEmbedding = append(mock.calls.GenerateEmbedding, callInfo)
	mock.lockGenerateEmbedding.Unlock()
	if mock.GenerateEmbeddingFunc == nil {
		var (
			float64ssOut [][]float64
			errOut       error
		)
		return float64ssOut, errOut
	}
	return mock.GenerateEmbeddingFunc(ctx, dimension, input)
}

// GenerateEmbeddingCalls gets all the calls that were made to GenerateEmbedding.
// Check the length with:
//
//	len(mockedLLMClient.GenerateEmbeddingCalls())
func (mock *LLMClientMock) GenerateEmbeddingCalls() []struct {
	Ctx       context.Context
	Dimension int
	Input     []string
} {
	var calls []struct {
		Ctx       context.Context
		Dimension int
		Input     []string
	}
	mock.lockGenerateEmbedding.RLock()
	calls = mock.calls.GenerateEmbedding
	mock.lockGenerateEmbedding.RUnlock()
	return calls
}

// NewSession calls NewSessionFunc.
func (mock *LLMClientMock) NewSession(ctx context.Context, options ...gollem.SessionOption) (gollem.Session, error) {
	callInfo := struct {
		Ctx     context.Context
		Options []gollem.SessionOption
	}{
		Ctx:     ctx,
		Options: options,
	}
	mock.lockNewSession.Lock()
	mock.calls.NewSession = append(mock.calls.NewSession, callInfo)
	mock.lockNewSession.Unlock()
	if mock.NewSessionFunc == nil {
		var (
			sessionOut gollem.Session
			errOut     error
		)
		return sessionOut, errOut
	}
	return mock.NewSessionFunc(ctx, options...)
}

// NewSessionCalls gets all the calls that were made to NewSession.
// Check the length with:
//
//	len(mockedLLMClient.NewSessionCalls())
func (mock *LLMClientMock) NewSessionCalls() []struct {
	Ctx     context.Context
	Options []gollem.SessionOption
} {
	var calls []struct {
		Ctx     context.Context
		Options []gollem.SessionOption
	}
	mock.lockNewSession.RLock()
	calls = mock.calls.NewSession
	mock.lockNewSession.RUnlock()
	return calls
}

// LLMSessionMock is a mock implementation of interfaces.LLMSession.
//
//	func TestSomethingThatUsesLLMSession(t *testing.T) {
//
//		// make and configure a mocked interfaces.LLMSession
//		mockedLLMSession := &LLMSessionMock{
//			GenerateContentFunc: func(ctx context.Context, input ...gollem.Input) (*gollem.Response, error) {
//				panic("mock out the GenerateContent method")
//			},
//			GenerateStreamFunc: func(ctx context.Context, input ...gollem.Input) (<-chan *gollem.Response, error) {
//				panic("mock out the GenerateStream method")
//			},
//			HistoryFunc: func() *gollem.History {
//				panic("mock out the History method")
//			},
//		}
//
//		// use mockedLLMSession in code that requires interfaces.LLMSession
//		// and then make assertions.
//
//	}
type LLMSessionMock struct {
	// GenerateContentFunc mocks the GenerateContent method.
	GenerateContentFunc func(ctx context.Context, input ...gollem.Input) (*gollem.Response, error)

	// GenerateStreamFunc mocks the GenerateStream method.
	GenerateStreamFunc func(ctx context.Context, input ...gollem.Input) (<-chan *gollem.Response, error)

	// HistoryFunc mocks the History method.
	HistoryFunc func() *gollem.History

	// calls tracks calls to the methods.
	calls struct {
		// GenerateContent holds details about calls to the GenerateContent method.
		GenerateContent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input []gollem.Input
		}
		// GenerateStream holds details about calls to the GenerateStream method.
		GenerateStream []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input []gollem.Input
		}
		// History holds details about calls to the History method.
		History []struct {
		}
	}
	lockGenerateContent sync.RWMutex
	lockGenerateStream  sync.RWMutex
	lockHistory         sync.RWMutex
}

// GenerateContent calls GenerateContentFunc.
func (mock *LLMSessionMock) GenerateContent(ctx context.Context, input ...gollem.Input) (*gollem.Response, error) {
	callInfo := struct {
		Ctx   context.Context
		Input []gollem.Input
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockGenerateContent.Lock()
	mock.calls.GenerateContent = append(mock.calls.GenerateContent, callInfo)
	mock.lockGenerateContent.Unlock()
	if mock.GenerateContentFunc == nil {
		var (
			responseOut *gollem.Response
			errOut      error
		)
		return responseOut, errOut
	}
	return mock.GenerateContentFunc(ctx, input...)
}

// GenerateContentCalls gets all the calls that were made to GenerateContent.
// Check the length with:
//
//	len(mockedLLMSession.GenerateContentCalls())
func (mock *LLMSessionMock) GenerateContentCalls() []struct {
	Ctx   context.Context
	Input []gollem.Input
} {
	var calls []struct {
		Ctx   context.Context
		Input []gollem.Input
	}
	mock.lockGenerateContent.RLock()
	calls = mock.calls.GenerateContent
	mock.lockGenerateContent.RUnlock()
	return calls
}

// GenerateStream calls GenerateStreamFunc.
func (mock *LLMSessionMock) GenerateStream(ctx context.Context, input ...gollem.Input) (<-chan *gollem.Response, error) {
	callInfo := struct {
		Ctx   context.Context
		Input []gollem.Input
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockGenerateStream.Lock()
	mock.calls.GenerateStream = append(mock.calls.GenerateStream, callInfo)
	mock.lockGenerateStream.Unlock()
	if mock.GenerateStreamFunc == nil {
		var (
			responseChOut <-chan *gollem.Response
			errOut        error
		)
		return responseChOut, errOut
	}
	return mock.GenerateStreamFunc(ctx, input...)
}

// GenerateStreamCalls gets all the calls that were made to GenerateStream.
// Check the length with:
//
//	len(mockedLLMSession.GenerateStreamCalls())
func (mock *LLMSessionMock) GenerateStreamCalls() []struct {
	Ctx   context.Context
	Input []gollem.Input
} {
	var calls []struct {
		Ctx   context.Context
		Input []gollem.Input
	}
	mock.lockGenerateStream.RLock()
	calls = mock.calls.GenerateStream
	mock.lockGenerateStream.RUnlock()
	return calls
}

// History calls HistoryFunc.
func (mock *LLMSessionMock) History() *gollem.History {
	callInfo := struct {
	}{}
	mock.lockHistory.Lock()
	mock.calls.History = append(mock.calls.History, callInfo)
	mock.lockHistory.Unlock()
	if mock.HistoryFunc == nil {
		var (
			historyOut *gollem.History
		)
		return historyOut
	}
	return mock.HistoryFunc()
}

// HistoryCalls gets all the calls that were made to History.
// Check the length with:
//
//	len(mockedLLMSession.HistoryCalls())
func (mock *LLMSessionMock) HistoryCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockHistory.RLock()
	calls = mock.calls.History
	mock.lockHistory.RUnlock()
	return calls
}

// SlackEventUsecasesMock is a mock implementation of interfaces.SlackEventUsecases.
//
//	func TestSomethingThatUsesSlackEventUsecases(t *testing.T) {
//
//		// make and configure a mocked interfaces.SlackEventUsecases
//		mockedSlackEventUsecases := &SlackEventUsecasesMock{
//			HandleSlackAppMentionFunc: func(ctx context.Context, slackMsg modelslack.Message) error {
//				panic("mock out the HandleSlackAppMention method")
//			},
//			HandleSlackMessageFunc: func(ctx context.Context, slackMsg modelslack.Message) error {
//				panic("mock out the HandleSlackMessage method")
//			},
//		}
//
//		// use mockedSlackEventUsecases in code that requires interfaces.SlackEventUsecases
//		// and then make assertions.
//
//	}
type SlackEventUsecasesMock struct {
	// HandleSlackAppMentionFunc mocks the HandleSlackAppMention method.
	HandleSlackAppMentionFunc func(ctx context.Context, slackMsg modelslack.Message) error

	// HandleSlackMessageFunc mocks the HandleSlackMessage method.
	HandleSlackMessageFunc func(ctx context.Context, slackMsg modelslack.Message) error

	// calls tracks calls to the methods.
	calls struct {
		// HandleSlackAppMention holds details about calls to the HandleSlackAppMention method.
		HandleSlackAppMention []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SlackMsg is the slackMsg argument value.
			SlackMsg modelslack.Message
		}
		// HandleSlackMessage holds details about calls to the HandleSlackMessage method.
		HandleSlackMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SlackMsg is the slackMsg argument value.
			SlackMsg modelslack.Message
		}
	}
	lockHandleSlackAppMention sync.RWMutex
	lockHandleSlackMessage    sync.RWMutex
}

// HandleSlackAppMention calls HandleSlackAppMentionFunc.
func (mock *SlackEventUsecasesMock) HandleSlackAppMention(ctx context.Context, slackMsg modelslack.Message) error {
	callInfo := struct {
		Ctx      context.Context
		SlackMsg modelslack.Message
	}{
		Ctx:      ctx,
		SlackMsg: slackMsg,
	}
	mock.lockHandleSlackAppMention.Lock()
	mock.calls.HandleSlackAppMention = append(mock.calls.HandleSlackAppMention, callInfo)
	mock.lockHandleSlackAppMention.Unlock()
	if mock.HandleSlackAppMentionFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.HandleSlackAppMentionFunc(ctx, slackMsg)
}

// HandleSlackAppMentionCalls gets all the calls that were made to HandleSlackAppMention.
// Check the length with:
//
//	len(mockedSlackEventUsecases.HandleSlackAppMentionCalls())
func (mock *SlackEventUsecasesMock) HandleSlackAppMentionCalls() []struct {
	Ctx      context.Context
	SlackMsg modelslack.Message
} {
	var calls []struct {
		Ctx      context.Context
		SlackMsg modelslack.Message
	}
	mock.lockHandleSlackAppMention.RLock()
	calls = mock.calls.HandleSlackAppMention
	mock.lockHandleSlackAppMention.RUnlock()
	return calls
}

// HandleSlackMessage calls HandleSlackMessageFunc.
func (mock *SlackEventUsecasesMock) HandleSlackMessage(ctx context.Context, slackMsg modelslack.Message) error {
	callInfo := struct {
		Ctx      context.Context
		SlackMsg modelslack.Message
	}{
		Ctx:      ctx,
		SlackMsg: slackMsg,
	}
	mock.lockHandleSlackMessage.Lock()
	mock.calls.HandleSlackMessage = append(mock.calls.HandleSlackMessage, callInfo)
	mock.lockHandleSlackMessage.Unlock()
	if mock.HandleSlackMessageFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.HandleSlackMessageFunc(ctx, slackMsg)
}

// HandleSlackMessageCalls gets all the calls that were made to HandleSlackMessage.
// Check the length with:
//
//	len(mockedSlackEventUsecases.HandleSlackMessageCalls())
func (mock *SlackEventUsecasesMock) HandleSlackMessageCalls() []struct {
	Ctx      context.Context
	SlackMsg modelslack.Message
} {
	var calls []struct {
		Ctx      context.Context
		SlackMsg modelslack.Message
	}
	mock.lockHandleSlackMessage.RLock()
	calls = mock.calls.HandleSlackMessage
	mock.lockHandleSlackMessage.RUnlock()
	return calls
}

// SlackInteractionUsecasesMock is a mock implementation of interfaces.SlackInteractionUsecases.
//
//	func TestSomethingThatUsesSlackInteractionUsecases(t *testing.T) {
//
//		// make and configure a mocked interfaces.SlackInteractionUsecases
//		mockedSlackInteractionUsecases := &SlackInteractionUsecasesMock{
//			HandleSalvageRefreshFunc: func(ctx context.Context, user modelslack.User, metadata string, values modelslack.StateValue, viewID string) error {
//				panic("mock out the HandleSalvageRefresh method")
//			},
//			HandleSlackInteractionBlockActionsFunc: func(ctx context.Context, user modelslack.User, slackThread modelslack.Thread, actionID modelslack.ActionID, value string, triggerID string) error {
//				panic("mock out the HandleSlackInteractionBlockActions method")
//			},
//			HandleSlackInteractionViewSubmissionFunc: func(ctx context.Context, user modelslack.User, callbackID modelslack.CallbackID, metadata string, values modelslack.StateValue) error {
//				panic("mock out the HandleSlackInteractionViewSubmission method")
//			},
//		}
//
//		// use mockedSlackInteractionUsecases in code that requires interfaces.SlackInteractionUsecases
//		// and then make assertions.
//
//	}
type SlackInteractionUsecasesMock struct {
	// HandleSalvageRefreshFunc mocks the HandleSalvageRefresh method.
	HandleSalvageRefreshFunc func(ctx context.Context, user modelslack.User, metadata string, values modelslack.StateValue, viewID string) error

	// HandleSlackInteractionBlockActionsFunc mocks the HandleSlackInteractionBlockActions method.
	HandleSlackInteractionBlockActionsFunc func(ctx context.Context, user modelslack.User, slackThread modelslack.Thread, actionID modelslack.ActionID, value string, triggerID string) error

	// HandleSlackInteractionViewSubmissionFunc mocks the HandleSlackInteractionViewSubmission method.
	HandleSlackInteractionViewSubmissionFunc func(ctx context.Context, user modelslack.User, callbackID modelslack.CallbackID, metadata string, values modelslack.StateValue) error

	// calls tracks calls to the methods.
	calls struct {
		// HandleSalvageRefresh holds details about calls to the HandleSalvageRefresh method.
		HandleSalvageRefresh []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User modelslack.User
			// Metadata is the metadata argument value.
			Metadata string
			// Values is the values argument value.
			Values modelslack.StateValue
			// ViewID is the viewID argument value.
			ViewID string
		}
		// HandleSlackInteractionBlockActions holds details about calls to the HandleSlackInteractionBlockActions method.
		HandleSlackInteractionBlockActions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User modelslack.User
			// SlackThread is the slackThread argument value.
			SlackThread modelslack.Thread
			// ActionID is the actionID argument value.
			ActionID modelslack.ActionID
			// Value is the value argument value.
			Value string
			// TriggerID is the triggerID argument value.
			TriggerID string
		}
		// HandleSlackInteractionViewSubmission holds details about calls to the HandleSlackInteractionViewSubmission method.
		HandleSlackInteractionViewSubmission []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User modelslack.User
			// CallbackID is the callbackID argument value.
			CallbackID modelslack.CallbackID
			// Metadata is the metadata argument value.
			Metadata string
			// Values is the values argument value.
			Values modelslack.StateValue
		}
	}
	lockHandleSalvageRefresh                 sync.RWMutex
	lockHandleSlackInteractionBlockActions   sync.RWMutex
	lockHandleSlackInteractionViewSubmission sync.RWMutex
}

// HandleSalvageRefresh calls HandleSalvageRefreshFunc.
func (mock *SlackInteractionUsecasesMock) HandleSalvageRefresh(ctx context.Context, user modelslack.User, metadata string, values modelslack.StateValue, viewID string) error {
	callInfo := struct {
		Ctx      context.Context
		User     modelslack.User
		Metadata string
		Values   modelslack.StateValue
		ViewID   string
	}{
		Ctx:      ctx,
		User:     user,
		Metadata: metadata,
		Values:   values,
		ViewID:   viewID,
	}
	mock.lockHandleSalvageRefresh.Lock()
	mock.calls.HandleSalvageRefresh = append(mock.calls.HandleSalvageRefresh, callInfo)
	mock.lockHandleSalvageRefresh.Unlock()
	if mock.HandleSalvageRefreshFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.HandleSalvageRefreshFunc(ctx, user, metadata, values, viewID)
}

// HandleSalvageRefreshCalls gets all the calls that were made to HandleSalvageRefresh.
// Check the length with:
//
//	len(mockedSlackInteractionUsecases.HandleSalvageRefreshCalls())
func (mock *SlackInteractionUsecasesMock) HandleSalvageRefreshCalls() []struct {
	Ctx      context.Context
	User     modelslack.User
	Metadata string
	Values   modelslack.StateValue
	ViewID   string
} {
	var calls []struct {
		Ctx      context.Context
		User     modelslack.User
		Metadata string
		Values   modelslack.StateValue
		ViewID   string
	}
	mock.lockHandleSalvageRefresh.RLock()
	calls = mock.calls.HandleSalvageRefresh
	mock.lockHandleSalvageRefresh.RUnlock()
	return calls
}

// HandleSlackInteractionBlockActions calls HandleSlackInteractionBlockActionsFunc.
func (mock *SlackInteractionUsecasesMock) HandleSlackInteractionBlockActions(ctx context.Context, user modelslack.User, slackThread modelslack.Thread, actionID modelslack.ActionID, value string, triggerID string) error {
	callInfo := struct {
		Ctx         context.Context
		User        modelslack.User
		SlackThread modelslack.Thread
		ActionID    modelslack.ActionID
		Value       string
		TriggerID   string
	}{
		Ctx:         ctx,
		User:        user,
		SlackThread: slackThread,
		ActionID:    actionID,
		Value:       value,
		TriggerID:   triggerID,
	}
	mock.lockHandleSlackInteractionBlockActions.Lock()
	mock.calls.HandleSlackInteractionBlockActions = append(mock.calls.HandleSlackInteractionBlockActions, callInfo)
	mock.lockHandleSlackInteractionBlockActions.Unlock()
	if mock.HandleSlackInteractionBlockActionsFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.HandleSlackInteractionBlockActionsFunc(ctx, user, slackThread, actionID, value, triggerID)
}

// HandleSlackInteractionBlockActionsCalls gets all the calls that were made to HandleSlackInteractionBlockActions.
// Check the length with:
//
//	len(mockedSlackInteractionUsecases.HandleSlackInteractionBlockActionsCalls())
func (mock *SlackInteractionUsecasesMock) HandleSlackInteractionBlockActionsCalls() []struct {
	Ctx         context.Context
	User        modelslack.User
	SlackThread modelslack.Thread
	ActionID    modelslack.ActionID
	Value       string
	TriggerID   string
} {
	var calls []struct {
		Ctx         context.Context
		User        modelslack.User
		SlackThread modelslack.Thread
		ActionID    modelslack.ActionID
		Value       string
		TriggerID   string
	}
	mock.lockHandleSlackInteractionBlockActions.RLock()
	calls = mock.calls.HandleSlackInteractionBlockActions
	mock.lockHandleSlackInteractionBlockActions.RUnlock()
	return calls
}

// HandleSlackInteractionViewSubmission calls HandleSlackInteractionViewSubmissionFunc.
func (mock *SlackInteractionUsecasesMock) HandleSlackInteractionViewSubmission(ctx context.Context, user modelslack.User, callbackID modelslack.CallbackID, metadata string, values modelslack.StateValue) error {
	callInfo := struct {
		Ctx        context.Context
		User       modelslack.User
		CallbackID modelslack.CallbackID
		Metadata   string
		Values     modelslack.StateValue
	}{
		Ctx:        ctx,
		User:       user,
		CallbackID: callbackID,
		Metadata:   metadata,
		Values:     values,
	}
	mock.lockHandleSlackInteractionViewSubmission.Lock()
	mock.calls.HandleSlackInteractionViewSubmission = append(mock.calls.HandleSlackInteractionViewSubmission, callInfo)
	mock.lockHandleSlackInteractionViewSubmission.Unlock()
	if mock.HandleSlackInteractionViewSubmissionFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.HandleSlackInteractionViewSubmissionFunc(ctx, user, callbackID, metadata, values)
}

// HandleSlackInteractionViewSubmissionCalls gets all the calls that were made to HandleSlackInteractionViewSubmission.
// Check the length with:
//
//	len(mockedSlackInteractionUsecases.HandleSlackInteractionViewSubmissionCalls())
func (mock *SlackInteractionUsecasesMock) HandleSlackInteractionViewSubmissionCalls() []struct {
	Ctx        context.Context
	User       modelslack.User
	CallbackID modelslack.CallbackID
	Metadata   string
	Values     modelslack.StateValue
} {
	var calls []struct {
		Ctx        context.Context
		User       modelslack.User
		CallbackID modelslack.CallbackID
		Metadata   string
		Values     modelslack.StateValue
	}
	mock.lockHandleSlackInteractionViewSubmission.RLock()
	calls = mock.calls.HandleSlackInteractionViewSubmission
	mock.lockHandleSlackInteractionViewSubmission.RUnlock()
	return calls
}

// AlertUsecasesMock is a mock implementation of interfaces.AlertUsecases.
//
//	func TestSomethingThatUsesAlertUsecases(t *testing.T) {
//
//		// make and configure a mocked interfaces.AlertUsecases
//		mockedAlertUsecases := &AlertUsecasesMock{
//			HandleAlertFunc: func(ctx context.Context, schema types.AlertSchema, alertData any) ([]*alert.Alert, error) {
//				panic("mock out the HandleAlert method")
//			},
//		}
//
//		// use mockedAlertUsecases in code that requires interfaces.AlertUsecases
//		// and then make assertions.
//
//	}
type AlertUsecasesMock struct {
	// HandleAlertFunc mocks the HandleAlert method.
	HandleAlertFunc func(ctx context.Context, schema types.AlertSchema, alertData any) ([]*alert.Alert, error)

	// calls tracks calls to the methods.
	calls struct {
		// HandleAlert holds details about calls to the HandleAlert method.
		HandleAlert []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Schema is the schema argument value.
			Schema types.AlertSchema
			// AlertData is the alertData argument value.
			AlertData any
		}
	}
	lockHandleAlert sync.RWMutex
}

// HandleAlert calls HandleAlertFunc.
func (mock *AlertUsecasesMock) HandleAlert(ctx context.Context, schema types.AlertSchema, alertData any) ([]*alert.Alert, error) {
	callInfo := struct {
		Ctx       context.Context
		Schema    types.AlertSchema
		AlertData any
	}{
		Ctx:       ctx,
		Schema:    schema,
		AlertData: alertData,
	}
	mock.lockHandleAlert.Lock()
	mock.calls.HandleAlert = append(mock.calls.HandleAlert, callInfo)
	mock.lockHandleAlert.Unlock()
	if mock.HandleAlertFunc == nil {
		var (
			alertsOut []*alert.Alert
			errOut    error
		)
		return alertsOut, errOut
	}
	return mock.HandleAlertFunc(ctx, schema, alertData)
}

// HandleAlertCalls gets all the calls that were made to HandleAlert.
// Check the length with:
//
//	len(mockedAlertUsecases.HandleAlertCalls())
func (mock *AlertUsecasesMock) HandleAlertCalls() []struct {
	Ctx       context.Context
	Schema    types.AlertSchema
	AlertData any
} {
	var calls []struct {
		Ctx       context.Context
		Schema    types.AlertSchema
		AlertData any
	}
	mock.lockHandleAlert.RLock()
	calls = mock.calls.HandleAlert
	mock.lockHandleAlert.RUnlock()
	return calls
}
