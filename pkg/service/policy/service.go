package policy

import (
	"context"
	"errors"

	"github.com/m-mizutani/goerr/v2"
	"github.com/m-mizutani/opaq"
	"github.com/secmon-lab/warren/pkg/domain/interfaces"
	"github.com/secmon-lab/warren/pkg/domain/model/alert"
	"github.com/secmon-lab/warren/pkg/domain/model/policy"
	"github.com/secmon-lab/warren/pkg/domain/types"
	"github.com/secmon-lab/warren/pkg/utils/logging"
)

type Service struct {
	policyClient interfaces.PolicyClient
	strictAlert  bool
}

func New(policyClient interfaces.PolicyClient) *Service {
	return &Service{
		policyClient: policyClient,
		strictAlert:  false,
	}
}

func NewWithStrictMode(policyClient interfaces.PolicyClient, strictAlert bool) *Service {
	return &Service{
		policyClient: policyClient,
		strictAlert:  strictAlert,
	}
}

// EvaluateEnrichPolicy evaluates the enrich policy for the given alert
func (s *Service) EvaluateEnrichPolicy(ctx context.Context, alert *alert.Alert) (*policy.EnrichPolicyResult, error) {
	var result policy.EnrichPolicyResult
	query := "data.enrich"

	err := s.policyClient.Query(ctx, query, alert, &result)
	logging.From(ctx).Debug("enrich policy result", "input", alert, "output", result, "query", query, "error", err)
	if err != nil {
		if errors.Is(err, opaq.ErrNoEvalResult) {
			// No enrich policy defined, return empty result
			return &policy.EnrichPolicyResult{}, nil
		}
		return nil, goerr.Wrap(err, "failed to evaluate enrich policy")
	}

	// Ensure all tasks have IDs
	result.EnsureTaskIDs()

	return &result, nil
}

// EvaluateTriagePolicy evaluates triage policy
func (s *Service) EvaluateTriagePolicy(ctx context.Context, alert *alert.Alert, enrichResults policy.EnrichResults) (*policy.TriagePolicyResult, error) {
	// Create input matching doc/policy.md format: input.alert.metadata.title
	queryInput := policy.NewTriagePolicyInput(alert, enrichResults)

	var result policy.TriagePolicyResult
	query := "data.triage"

	err := s.policyClient.Query(ctx, query, queryInput, &result)
	logging.From(ctx).Debug("triage policy result", "input", queryInput, "output", result, "query", query, "error", err)
	if err != nil {
		if errors.Is(err, opaq.ErrNoEvalResult) {
			// No triage policy defined, return default behavior
			return &policy.TriagePolicyResult{
				Publish: types.PublishTypeAlert,
			}, nil
		}
		return nil, goerr.Wrap(err, "failed to evaluate triage policy")
	}

	// Set default publish type if empty
	if result.Publish == "" {
		result.Publish = types.PublishTypeAlert
	}

	return &result, nil
}

// EvaluateIngestPolicy evaluates ingest policy and returns alerts
func (s *Service) EvaluateIngestPolicy(ctx context.Context, schema types.AlertSchema, alertData any) ([]*alert.Alert, error) {
	logger := logging.From(ctx)

	var result alert.QueryOutput
	query := "data.ingest." + string(schema)
	hook := func(ctx context.Context, loc opaq.PrintLocation, msg string) error {
		logging.From(ctx).Debug("[rego.print] "+msg, "location", loc)
		return nil
	}

	err := s.policyClient.Query(ctx, query, alertData, &result, opaq.WithPrintHook(hook))
	logger.Debug("ingest policy result", "input", alertData, "output", result, "query", query)

	if err != nil {
		// Check if it's a "no evaluation result" error (package not found)
		if errors.Is(err, opaq.ErrNoEvalResult) {
			if s.strictAlert {
				// In strict mode, return error for missing policy package
				return nil, goerr.Wrap(err, "no policy package found for schema",
					goerr.V("schema", schema),
					goerr.V("alert", alertData))
			}

			// Default mode: generate default alert
			logger.Info("no policy package found, generating default alert",
				"schema", schema)

			defaultAlert := alert.New(ctx, schema, alertData, alert.Metadata{
				// Title and Description will be generated by FillMetadata
			})

			return []*alert.Alert{&defaultAlert}, nil
		}

		// Other errors should be returned as-is
		return nil, goerr.Wrap(err, "failed to query policy",
			goerr.V("schema", schema),
			goerr.V("alert", alertData))
	}

	var alerts []*alert.Alert
	for _, a := range result.Alerts {
		newAlert := alert.New(ctx, schema, alertData, a)
		if newAlert.Data == nil {
			newAlert.Data = alertData
		}

		alerts = append(alerts, &newAlert)
	}

	return alerts, nil
}
