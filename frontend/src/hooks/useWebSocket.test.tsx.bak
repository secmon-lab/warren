import { renderHook, act, waitFor } from '@testing-library/react';
import { useWebSocket } from './useWebSocket';
import { AuthProvider } from '@/contexts/auth-context';
import React from 'react';

// Mock WebSocket
class MockWebSocket {
  url: string;
  readyState: number;
  onopen: ((event: Event) => void) | null = null;
  onclose: ((event: CloseEvent) => void) | null = null;
  onerror: ((event: Event) => void) | null = null;
  onmessage: ((event: MessageEvent) => void) | null = null;

  constructor(url: string) {
    this.url = url;
    this.readyState = WebSocket.CONNECTING;
    
    // Simulate connection
    setTimeout(() => {
      this.readyState = WebSocket.OPEN;
      if (this.onopen) {
        this.onopen(new Event('open'));
      }
    }, 10);
  }

  send(data: string) {
    if (this.readyState !== WebSocket.OPEN) {
      throw new Error('WebSocket is not open');
    }
  }

  close() {
    this.readyState = WebSocket.CLOSED;
    if (this.onclose) {
      this.onclose(new CloseEvent('close'));
    }
  }
}

// Mock auth context
const mockAuthContext = {
  token: 'test-token',
  isAuthenticated: true,
  login: jest.fn(),
  logout: jest.fn(),
  loading: false,
};

jest.mock('@/contexts/auth-context', () => ({
  useAuth: () => mockAuthContext,
}));

describe('useWebSocket', () => {
  let mockWebSocket: MockWebSocket;

  beforeEach(() => {
    // Reset WebSocket mock
    (global as any).WebSocket = jest.fn((url: string) => {
      mockWebSocket = new MockWebSocket(url);
      return mockWebSocket;
    });

    // Clear all timers
    jest.clearAllTimers();
    jest.useFakeTimers();
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  const wrapper = ({ children }: { children: React.ReactNode }) => (
    <AuthProvider>{children}</AuthProvider>
  );

  it('should connect to WebSocket on mount', async () => {
    const { result } = renderHook(() => useWebSocket('test-ticket'), { wrapper });

    expect(result.current.status).toBe('connecting');

    // Wait for connection
    await waitFor(() => {
      expect(result.current.status).toBe('connected');
    });

    expect(global.WebSocket).toHaveBeenCalledWith(
      expect.stringContaining('/ws/chat/ticket/test-ticket')
    );
  });

  it('should handle incoming messages', async () => {
    const onMessage = jest.fn();
    const { result } = renderHook(
      () => useWebSocket('test-ticket', { onMessage }),
      { wrapper }
    );

    // Wait for connection
    await waitFor(() => {
      expect(result.current.status).toBe('connected');
    });

    // Simulate incoming message
    const testMessage = {
      type: 'message',
      content: 'Hello',
      user: { id: 'user1', name: 'Test User' },
      timestamp: Date.now(),
    };

    act(() => {
      if (mockWebSocket.onmessage) {
        mockWebSocket.onmessage(
          new MessageEvent('message', { data: JSON.stringify(testMessage) })
        );
      }
    });

    expect(onMessage).toHaveBeenCalledWith(testMessage);
    expect(result.current.messages).toHaveLength(1);
    expect(result.current.messages[0]).toEqual(testMessage);
  });

  it('should send messages when connected', async () => {
    const { result } = renderHook(() => useWebSocket('test-ticket'), { wrapper });

    // Wait for connection
    await waitFor(() => {
      expect(result.current.status).toBe('connected');
    });

    const sendSpy = jest.spyOn(mockWebSocket, 'send');

    act(() => {
      const success = result.current.sendMessage('Test message');
      expect(success).toBe(true);
    });

    expect(sendSpy).toHaveBeenCalledWith(
      expect.stringContaining('"content":"Test message"')
    );
  });

  it('should not send messages when disconnected', () => {
    const { result } = renderHook(() => useWebSocket('test-ticket'), { wrapper });

    // Don't wait for connection, try to send immediately
    act(() => {
      const success = result.current.sendMessage('Test message');
      expect(success).toBe(false);
    });
  });

  it('should handle connection errors', async () => {
    const onStatusChange = jest.fn();
    const { result } = renderHook(
      () => useWebSocket('test-ticket', { onStatusChange }),
      { wrapper }
    );

    // Wait for connection
    await waitFor(() => {
      expect(result.current.status).toBe('connected');
    });

    // Simulate error
    act(() => {
      if (mockWebSocket.onerror) {
        mockWebSocket.onerror(new Event('error'));
      }
    });

    expect(result.current.status).toBe('error');
    expect(onStatusChange).toHaveBeenCalledWith('error');
  });

  it('should attempt to reconnect on disconnect', async () => {
    const { result } = renderHook(
      () => useWebSocket('test-ticket', { reconnectInterval: 100, maxReconnectAttempts: 2 }),
      { wrapper }
    );

    // Wait for initial connection
    await waitFor(() => {
      expect(result.current.status).toBe('connected');
    });

    const initialCallCount = (global.WebSocket as jest.Mock).mock.calls.length;

    // Simulate disconnect
    act(() => {
      mockWebSocket.close();
    });

    expect(result.current.status).toBe('disconnected');

    // Fast-forward time to trigger reconnect
    act(() => {
      jest.advanceTimersByTime(100);
    });

    // Should attempt to reconnect
    await waitFor(() => {
      expect((global.WebSocket as jest.Mock).mock.calls.length).toBe(initialCallCount + 1);
    });
  });

  it('should disconnect on unmount', async () => {
    const { result, unmount } = renderHook(() => useWebSocket('test-ticket'), { wrapper });

    // Wait for connection
    await waitFor(() => {
      expect(result.current.status).toBe('connected');
    });

    const closeSpy = jest.spyOn(mockWebSocket, 'close');

    // Unmount the hook
    unmount();

    expect(closeSpy).toHaveBeenCalled();
  });

  it('should filter out pong messages from message history', async () => {
    const { result } = renderHook(() => useWebSocket('test-ticket'), { wrapper });

    // Wait for connection
    await waitFor(() => {
      expect(result.current.status).toBe('connected');
    });

    // Send a regular message
    act(() => {
      if (mockWebSocket.onmessage) {
        mockWebSocket.onmessage(
          new MessageEvent('message', {
            data: JSON.stringify({
              type: 'message',
              content: 'Hello',
              timestamp: Date.now(),
            }),
          })
        );
      }
    });

    // Send a pong message
    act(() => {
      if (mockWebSocket.onmessage) {
        mockWebSocket.onmessage(
          new MessageEvent('message', {
            data: JSON.stringify({
              type: 'pong',
              content: '',
              timestamp: Date.now(),
            }),
          })
        );
      }
    });

    // Only the regular message should be in the history
    expect(result.current.messages).toHaveLength(1);
    expect(result.current.messages[0].type).toBe('message');
  });

  it('should send ping messages periodically', async () => {
    const { result } = renderHook(() => useWebSocket('test-ticket'), { wrapper });

    // Wait for connection
    await waitFor(() => {
      expect(result.current.status).toBe('connected');
    });

    const sendSpy = jest.spyOn(mockWebSocket, 'send');

    // Fast-forward 30 seconds to trigger ping
    act(() => {
      jest.advanceTimersByTime(30000);
    });

    expect(sendSpy).toHaveBeenCalledWith(
      expect.stringContaining('"type":"ping"')
    );
  });
});