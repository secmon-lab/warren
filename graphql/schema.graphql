type TagObject {
  id: ID!
  name: String!
}

type Ticket {
  id: ID!
  status: String!
  title: String!
  description: String!
  summary: String!
  assignee: User
  alerts: [Alert!]!
  alertsPaginated(offset: Int, limit: Int): AlertsResponse!
  comments: [Comment!]!
  alertsCount: Int!
  commentsCount: Int!
  conclusion: String
  reason: String
  finding: Finding
  slackLink: String
  createdAt: String!
  updatedAt: String!
  isTest: Boolean!
  tags: [String!]!
  tagObjects: [TagObject!]!
}

type User {
  id: ID!
  name: String!
  icon: String
}

type Comment {
  id: ID!
  content: String!
  user: User
  createdAt: String!
  updatedAt: String!
}

type Alert {
  id: ID!
  title: String!
  description: String
  schema: String!
  data: String!
  attributes: [AlertAttribute!]!
  createdAt: String!
  ticket: Ticket
  tags: [String!]!
  tagObjects: [TagObject!]!
}

type AlertAttribute {
  key: String!
  value: String!
  link: String
  auto: Boolean!
}

type Finding {
  severity: String!
  summary: String!
  reason: String!
  recommendation: String!
}

type TicketsResponse {
  tickets: [Ticket!]!
  totalCount: Int!
}

type CommentsResponse {
  comments: [Comment!]!
  totalCount: Int!
}

type Activity {
  id: ID!
  type: String!
  userID: String
  alertID: String
  ticketID: String
  commentID: String
  createdAt: String!
  metadata: String
  user: User
  alert: Alert
  ticket: Ticket
}

type ActivitiesResponse {
  activities: [Activity!]!
  totalCount: Int!
}

type AlertsResponse {
  alerts: [Alert!]!
  totalCount: Int!
}

type DashboardStats {
  openTicketsCount: Int!
  unboundAlertsCount: Int!
  openTickets: [Ticket!]!
  unboundAlerts: [Alert!]!
}

type AlertCluster {
  id: ID!
  centerAlert: Alert!
  alerts: [Alert!]!
  size: Int!
  keywords: [String!]
  createdAt: String!
}

type ClusteringSummary {
  clusters: [AlertCluster!]!
  noiseAlerts: [Alert!]!
  parameters: DBSCANParameters!
  computedAt: String!
  totalCount: Int!
}

type DBSCANParameters {
  eps: Float!
  minSamples: Int!
}

type TagMetadata {
  id: ID!
  name: String!
  description: String
  color: String!
  createdAt: String!
  updatedAt: String!
}

type AlertsConnection {
  alerts: [Alert!]!
  totalCount: Int!
}

type Query {
  ticket(id: ID!): Ticket
  tickets(statuses: [String!], offset: Int, limit: Int): TicketsResponse!
  similarTickets(
    ticketId: ID!
    threshold: Float!
    offset: Int
    limit: Int
  ): TicketsResponse!
  similarTicketsForAlert(
    alertId: ID!
    threshold: Float!
    offset: Int
    limit: Int
  ): TicketsResponse!
  ticketComments(ticketId: ID!, offset: Int, limit: Int): CommentsResponse!
  alert(id: ID!): Alert
  alerts(offset: Int, limit: Int): AlertsResponse!
  unboundAlerts(
    threshold: Float
    keyword: String
    ticketId: ID
    offset: Int
    limit: Int
  ): AlertsResponse!
  dashboard: DashboardStats!
  activities(offset: Int, limit: Int): ActivitiesResponse!
  alertClusters(
    limit: Int
    offset: Int
    minClusterSize: Int
    eps: Float
    minSamples: Int
    keyword: String
  ): ClusteringSummary!
  clusterAlerts(
    clusterID: ID!
    keyword: String
    limit: Int
    offset: Int
  ): AlertsConnection!
  tags: [TagMetadata!]!
  availableTagColors: [String!]!
  availableTagColorNames: [String!]!
}

type Mutation {
  updateTicketStatus(id: ID!, status: String!): Ticket!
  updateMultipleTicketsStatus(ids: [ID!]!, status: String!): [Ticket!]!
  updateTicketConclusion(id: ID!, conclusion: String!, reason: String!): Ticket!
  updateTicket(id: ID!, title: String!, description: String): Ticket!
  createTicket(title: String!, description: String!, isTest: Boolean): Ticket!
  createTicketFromAlerts(
    alertIds: [ID!]!
    title: String
    description: String
  ): Ticket!
  bindAlertsToTicket(ticketId: ID!, alertIds: [ID!]!): Ticket!
  updateAlertTags(alertId: ID!, tagIds: [ID!]!): Alert!
  updateTicketTags(ticketId: ID!, tagIds: [ID!]!): Ticket!
  createTag(name: String!): TagMetadata!
  deleteTag(id: ID!): Boolean!
  updateTag(input: UpdateTagInput!): TagMetadata!
}

input UpdateTagInput {
  id: ID!
  name: String!
  color: String!
  description: String
}

input CreateKnowledgeInput {
  topic: String!
  slug: String!
  name: String!
  content: String!
}

input UpdateKnowledgeInput {
  topic: String!
  slug: String!
  name: String!
  content: String!
}

type Knowledge {
  slug: String!
  name: String!
  topic: String!
  content: String!
  commitID: String!
  authorID: String!
  author: User!
  createdAt: String!
  updatedAt: String!
  state: String!
}

type TopicSummary {
  topic: String!
  count: Int!
}

extend type Query {
  knowledgeTopics: [TopicSummary!]!
  knowledgesByTopic(topic: String!): [Knowledge!]!
}

extend type Mutation {
  createKnowledge(input: CreateKnowledgeInput!): Knowledge!
  updateKnowledge(input: UpdateKnowledgeInput!): Knowledge!
  archiveKnowledge(topic: String!, slug: String!): Boolean!
}

type Session {
  id: ID!
  ticketID: ID!
  status: String!
  userID: String
  user: User
  query: String
  slackURL: String
  intent: String
  createdAt: String!
  updatedAt: String!
}

type SessionMessage {
  id: ID!
  sessionID: ID!
  type: String!
  content: String!
  createdAt: String!
  updatedAt: String!
}

extend type Query {
  ticketSessions(ticketId: ID!): [Session!]!
  session(id: ID!): Session
  sessionMessages(sessionId: ID!): [SessionMessage!]!
}

type AgentMemory {
  id: ID!
  agentID: String!
  query: String!
  claim: String!
  score: Float!
  createdAt: String!
  lastUsedAt: String
}

type AgentSummary {
  agentID: String!
  memoriesCount: Int!
  latestMemoryAt: String
}

type AgentMemoriesResponse {
  memories: [AgentMemory!]!
  totalCount: Int!
}

type AgentSummariesResponse {
  agents: [AgentSummary!]!
  totalCount: Int!
}

enum MemorySortField {
  SCORE
  CREATED_AT
  LAST_USED_AT
}

enum SortOrder {
  ASC
  DESC
}

extend type Query {
  listAgentSummaries(offset: Int, limit: Int, keyword: String): AgentSummariesResponse!
  listAgentMemories(
    agentID: String!
    offset: Int
    limit: Int
    sortBy: MemorySortField
    sortOrder: SortOrder
    keyword: String
    minScore: Float
    maxScore: Float
  ): AgentMemoriesResponse!
  getAgentMemory(agentID: String!, memoryID: ID!): AgentMemory
}

schema {
  query: Query
  mutation: Mutation
}
